/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package tr.biznet.bizzy.service.pentest.dao;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;
import tr.biznet.bizzy.plugins.fortify.domain.ProjectDetails;
import tr.biznet.bizzy.service.server.domain.Server;
import tr.biznet.bizzy.service.aa.domain.User;
import tr.biznet.bizzy.service.customer.dao.CustomerDao;
import tr.biznet.bizzy.service.customer.domain.Customer;
import tr.biznet.bizzy.service.dao.BaseScanDao;
import tr.biznet.bizzy.service.dao.ColumnNameMapper;
import tr.biznet.bizzy.service.dao.CustomParameterSource;
import tr.biznet.bizzy.service.kb.KBService;
import tr.biznet.bizzy.service.pci.domain.OccurrenceType;
import tr.biznet.bizzy.service.pci.domain.ScanAsset;
import tr.biznet.bizzy.service.pentest.domain.ScanStatus;
import tr.biznet.bizzy.service.pci.domain.ScanVulnerability;
import tr.biznet.bizzy.service.pci.domain.ScanVulnerabilityDetails;
import tr.biznet.bizzy.service.pentest.domain.AssetDiscovery;
import tr.biznet.bizzy.service.pentest.domain.PentestScan;
import tr.biznet.bizzy.service.pentest.domain.NessusScanStatus;
import tr.biznet.bizzy.service.pentest.domain.AssetDiscoveryResult;
import tr.biznet.bizzy.service.pentest.domain.PentestPolicy;
import tr.biznet.bizzy.service.pentest.domain.PentestScanner;
import tr.biznet.bizzy.service.pentest.domain.PentestTimezone;
import tr.biznet.bizzy.service.pentest.domain.ScanDiff;
import tr.biznet.bizzy.service.pentest.domain.ScanLaunch;
import tr.biznet.bizzy.service.pentest.domain.ScheduledAssetDiscovery;
import tr.biznet.bizzy.service.pentest.domain.ScheduledPentestScan;
import tr.biznet.bizzy.service.scan.domain.AssetVulnerability;
import tr.biznet.bizzy.service.scan.domain.Category;
import tr.biznet.bizzy.service.scan.domain.CveId;
import tr.biznet.bizzy.service.scan.domain.CweId;
import tr.biznet.bizzy.service.scan.domain.Label;
import tr.biznet.bizzy.service.scan.domain.Port;
import tr.biznet.bizzy.service.pci.domain.WebApp;
import tr.biznet.bizzy.service.pentest.domain.CalendarProject;
import tr.biznet.bizzy.service.pentest.domain.CalendarProjectTimeGraph;
import tr.biznet.bizzy.service.pentest.domain.Effort;
import tr.biznet.bizzy.service.pentest.domain.EffortFilter;
import tr.biznet.bizzy.service.pentest.domain.ScanLabel;
import tr.biznet.bizzy.service.pentest.domain.ScanProcess;
import tr.biznet.bizzy.service.pentest.domain.Schedule;
import tr.biznet.bizzy.service.scan.domain.Asset;
import tr.biznet.bizzy.service.scan.domain.AssetFilter;
import tr.biznet.bizzy.service.scan.domain.AssetType;
import tr.biznet.bizzy.service.scan.domain.Vulnerability;
import tr.biznet.bizzy.service.scan.domain.Source;
import tr.biznet.bizzy.service.scan.domain.ScanResultsFilter;
import tr.biznet.bizzy.service.scan.domain.VirtualHost;
import tr.biznet.bizzy.service.server.enums.ServerType;
import tr.biznet.bizzy.service.vulnerability.dao.VulnerabilityDao;
import tr.biznet.bizzy.util.BizzyUtil;
import tr.biznet.bizzy.util.EscapeUtil;
import tr.biznet.bizzy.util.HttpUtil;
import tr.biznet.bizzy.util.IpOperationsUtil;
import tr.biznet.bizzy.util.datatables.Column;
import tr.biznet.bizzy.util.datatables.DataTablesRequest;
import tr.biznet.bizzy.util.datatables.Order;
import tr.biznet.bizzy.util.log.LogLevel;
import tr.biznet.bizzy.util.log.LoggerFactory;

/**
 *
 * @author adem.dilbaz
 */
@Repository
public class PentestDao extends BaseScanDao {

    @Autowired
    VulnerabilityDao vulnerabilityDao;

    @Autowired
    CustomerDao customerDao;

    @Autowired
    KBService kbService;

    private static final tr.biznet.bizzy.util.log.Logger logger = LoggerFactory.getLogger(PentestDao.class);
    private final ScanColumnNameMapper scanColumnNameMapper = new ScanColumnNameMapper();
    private final ScanResultColumnNameMapper scanResultColumnNameMapper = new ScanResultColumnNameMapper();
    private final HostScanColumnNameMapper hostScanColumnNameMapper = new HostScanColumnNameMapper();
    private final AssetDiscoveryResultColumnNameMapper AssetDiscoveryResultColumnNameMapper = new AssetDiscoveryResultColumnNameMapper();
    private final ScheduledScanColumnNameMapper scheduledScanColumnNameMapper = new ScheduledScanColumnNameMapper();
    private final LabelColumnNameMapper labelColumnNameMapper = new LabelColumnNameMapper();
    private final ScanAssetDiscoveryResultColumnNameMapper ScanAssetDiscoveryResultColumnNameMapper = new ScanAssetDiscoveryResultColumnNameMapper();
    private final AssetVulnerabilityColumnNameMapper assetVulnerabilityColumnNameMapper = new AssetVulnerabilityColumnNameMapper();

    public int getScansCount(DataTablesRequest dataTablesRequest, String customerId, Boolean isArchived, String source, boolean isSsl, String scanCreatedBy) {
        Map params = new HashMap();
        params.put("customerId", customerId);
        String sql = "SELECT count(*) as count "
                + "FROM scan s "
                + "LEFT JOIN pentest_policy p "
                + "     ON (s.policy_id = p.id AND s.server_id = p.server_id) "
                + "WHERE customer_id= :customerId AND s.status NOT IN ( :status1 , :status2 , :status3 , :status4 ) ";
        if (isArchived != null) {
            if (isArchived) {
                sql += " AND s.archived = true ";
            } else {
                sql += " AND s.archived = false ";
            }
        }
        if (scanCreatedBy != null) {
            sql += " AND s.requested_by = :scanCreatedBy ";
            params.put("scanCreatedBy", scanCreatedBy);
        }
        if (!source.equals("all")) {
            sql += " AND s.source = :sourceFilter ";
            params.put("sourceFilter", source);
        }
        if(isSsl){
            sql += " AND s.ssl_scan = true ";
        } else {
            sql += " AND s.ssl_scan = false ";
        }
        sql += createSearch(scanColumnNameMapper, dataTablesRequest, params);

        params.put("status1", ScanStatus.RUNNING.getValue());
        params.put("status2", ScanStatus.QUEUED.getValue());
        params.put("status3", ScanStatus.PAUSED.getValue());
        params.put("status4", ScanStatus.IMPORTING.getValue());
        Integer count = jdbcTemplate.queryForObject(sql, params, Integer.class);
        return count;
    }

    public int getAllScansForLimitCheck(DataTablesRequest dataTablesRequest, String customerId) {
        Map params = new HashMap();
        params.put("customerId", customerId);
        params.put("source", Source.PENTEST.toString());
        String sql = "SELECT count(*) as count "
                + "FROM scan s "
                + "LEFT JOIN pentest_policy p "
                + "     ON (s.policy_id = p.id AND s.server_id = p.server_id) "
                + "WHERE customer_id= :customerId AND source != :source"
                + createSearch(scanColumnNameMapper, dataTablesRequest, params);
        Integer count = jdbcTemplate.queryForObject(sql, params, Integer.class);
        return count;
    }

    public boolean addVulnerabilityLabel(Label label) {
        Map params = new HashMap();
        params.put("customerId", label.getCustomerId());
        String sqlCheck = "SELECT * FROM vulnerability_label WHERE (customer_id = :customerId OR customer_id IS NULL)";
        List<Label> labels = jdbcTemplate.query(sqlCheck, params, new LabelRowMapper());

        for (Label lbl : labels) {

            if (lbl.getName().equals(label.getName())) {
                return false;
            }
        }

        String sql = "INSERT INTO vulnerability_label (label_id,label,creator,create_date,customer_id)"
                + "VALUES (:labelId, :name,  :creator , :createDate, :customerId) ";

        int rows = jdbcTemplate.update(sql, new CustomParameterSource(label));
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }

        return true;
    }

    public boolean removeVulnerabilityLabel(String labelId) {

        Map params = new HashMap();
        String sqls = "DELETE FROM vulnerability_label where label_id = :labelId";

        params.put("labelId", labelId);
        int rows = jdbcTemplate.update(sqls, params);
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
        return true;
    }

    public int getVulnerabilityLabelCount(DataTablesRequest dtr, String searchedLabel, String customerId) {

        Map params = new HashMap();
        params.put("customerId", customerId);
        String sql = "SELECT count (*) as count FROM vulnerability_label vl \n"
                + " WHERE (vl.customer_id = :customerId OR vl.customer_id IS NULL) ";
        if (searchedLabel != null && !searchedLabel.equals("")) {
            sql += " AND label ilike :label ";
            params.put("label", searchedLabel);
        }

        Integer count = jdbcTemplate.queryForObject(sql, params, Integer.class);
        return count;
    }

    public List<Label> getVulnerabilityLabels(DataTablesRequest dtr, String searchedLabel, String customerId) {
        Map params = new HashMap();
        params.put("customerId", customerId);
        String sql = "select vl.*, count(distinct svv.scan_vulnerability_id) as allCount, count(case when svv.status NOT IN ('CLOSED', 'FALSE_POSITIVE') then 1 else null end) as openCount from vulnerability_label vl "
                + "LEFT JOIN vulnerability_label_relations vlr ON vlr.label = vl.label "
                + "LEFT JOIN scan_vulnerability_view svv ON vlr.scan_vulnerability_id = svv.scan_vulnerability_id "
                + "LEFT JOIN scan_asset sa ON sa.scan_asset_id = svv.scan_asset_id "
                + "LEFT JOIN asset a ON a.asset_id = sa.asset_id "
                + "WHERE (vl.customer_id = :customerId OR vl.customer_id IS NULL) ";
        if (searchedLabel != null && !searchedLabel.equals("")) {
            sql += " AND vl.label ilike :label ";
            params.put("label", searchedLabel);
        }
        sql += " GROUP BY vl.label, vl.creator, vl.create_date, vl.customer_id, vl.label_id "
                + createOrderBy(labelColumnNameMapper, dtr)
                + createLimit(dtr, params);
        return jdbcTemplate.query(sql, params, new LabelRowMapper());
    }

    public int getAssetGroupCountByScanVulnerabilityId(String scanVulnerabilityId) {
        String SQL = "select count(*) from asset_group  sv"
                + " inner join asset_group_relations agr"
                + " on sv.group_id = agr.group_id"
                + " inner join scan_asset asset"
                + " on agr.asset_id = asset.asset_id"
                + " inner join scan_vulnerability svv"
                + " on svv.scan_asset_id = asset.scan_asset_id"
                + " where scan_vulnerability_id  = :scanVulnerabilityId";
        Map params = new HashMap();
        params.put("scanVulnerabilityId", scanVulnerabilityId);
        Integer count = jdbcTemplate.queryForObject(SQL, params, Integer.class);
        return count;
    }

    public List<String> getAssetGroupNameListByScanVulnerabilityId(String scanVulnerabilityId) {
        String SQL = "select sv.name from asset_group  sv"
                + " inner join asset_group_relations agr"
                + " on sv.group_id = agr.group_id"
                + " inner join scan_asset asset"
                + " on agr.asset_id = asset.asset_id"
                + " inner join scan_vulnerability svv"
                + " on svv.scan_asset_id = asset.scan_asset_id"
                + " where scan_vulnerability_id  = :scanVulnerabilityId";
        Map params = new HashMap();
        params.put("scanVulnerabilityId", scanVulnerabilityId);
        List<String> values = jdbcTemplate.query(SQL, params, new RowMapper<String>() {
            public String mapRow(ResultSet rs, int rowNum)
                    throws SQLException {
                return rs.getString(1);
            }
        });
        return values;
    }

    class LabelRowMapper implements RowMapper<Label> {

        public Label mapRow(ResultSet rs, int rowNum) throws SQLException {

            Label label = new Label();
            label.setLabelId(rs.getString("label_id"));
            label.setName(rs.getString("label"));
            label.setCreator(rs.getString("creator"));
            label.setCreateDate(rs.getTimestamp("create_date"));
            label.setCustomerId(rs.getString("customer_id"));

            try {
                label.setVulnerabilityCount(rs.getInt("allCount"));
                label.setOpenVulnerabilityCount(rs.getInt("openCount"));
            } catch (Exception ex) {
                //nothing to do
            }

            return label;
        }
    }

    public List<PentestScan> getScans(DataTablesRequest dataTablesRequest, String customerId, Boolean isArchived, String source, boolean isSsl, String scanCreatedBy) {
        Map params = new HashMap();
        params.put("customerId", customerId);
        String sql = "SELECT s.*, p.name as policy, se.domain "
                + "FROM scan s "
                + "LEFT JOIN pentest_policy p "
                + "     ON (s.policy_id = p.id AND s.server_id = p.server_id) "
                + "LEFT JOIN server se "
                + "     ON se.setting_id=s.server_id "
                + "INNER JOIN ("
                + "SELECT DISTINCT s.scan_id, s.scan_date, s.source, s.name, s.completion_date, s.request_date, s.status, p.name as policy  "
                + "FROM scan s "
                + "LEFT JOIN pentest_policy p "
                + "     ON (s.policy_id = p.id AND s.server_id = p.server_id) "
                + " WHERE s.customer_id= :customerId AND ( s.status != :status1 AND s.status != :status2 AND s.status != :status3 AND s.status != :status4 ) ";
        if (!source.equals("all")) {
            sql += " AND s.source = :sourceFilter ";
            params.put("sourceFilter", source);
        }
        if (scanCreatedBy != null) {
            sql += " AND s.requested_by = :scanCreatedBy ";
            params.put("scanCreatedBy", scanCreatedBy);
        }
        if (isArchived != null) {
            if (isArchived) {
                sql += " AND s.archived = true ";
            } else {
                sql += " AND s.archived = false ";
            }
        }
        if(isSsl){
            sql += " AND s.ssl_scan = true ";
        } else {
            sql += " AND s.ssl_scan = false ";
        }
        if (dataTablesRequest != null) {
            sql += createOrderBy(scanColumnNameMapper, dataTablesRequest)
                    + createLimit(dataTablesRequest, params);
        }

        sql += ") ij "
                + "			ON ij.scan_id=s.scan_id  "
                + "WHERE s.customer_id= :customerId AND ( s.status != :status1 AND s.status != :status2 AND s.status != :status3 AND s.status != :status4 ) ";
        if (!source.equals("all")) {
            sql += " AND s.source = :sourceFilter ";
            params.put("sourceFilter", source);
        }
        if (scanCreatedBy != null) {
            sql += " AND s.requested_by = :scanCreatedBy ";
            params.put("scanCreatedBy", scanCreatedBy);
        }
        if (isArchived != null) {
            if (isArchived) {
                sql += " AND s.archived = true ";
            } else {
                sql += " AND s.archived = false ";
            }
        }
        if(isSsl){
            sql += " AND s.ssl_scan = true ";
        } else {
            sql += " AND s.ssl_scan = false ";
        }
        
        if (dataTablesRequest != null) {
            sql += createSearch(scanColumnNameMapper, dataTablesRequest, params);
            sql += createOrderBy(scanColumnNameMapper, dataTablesRequest);
        }
        params.put("status1", ScanStatus.RUNNING.getValue());
        params.put("status2", ScanStatus.QUEUED.getValue());
        params.put("status3", ScanStatus.PAUSED.getValue());
        params.put("status4", ScanStatus.IMPORTING.getValue());

        return jdbcTemplate.query(sql, params, new ScanResultSetExtractor(false));
    }

    public List<ScanDiff> getScanDiff(DataTablesRequest dataTablesRequest, String customerId, String scan1Id, String scan2Id) {

        Map params = new HashMap();
        String formula = getVulnerabilityFormulaSqlByCustomerId(customerId);
        params.put("firstScan", scan1Id);
        params.put("secondScan", scan2Id);
        params.put("customerId", customerId);
        String sql = "SELECT "
                + "           (CASE WHEN innerTable.firstname = innerTable.secondname "
                + "		   THEN innerTable.firstname WHEN innerTable.firstname IS NULL "
                + "		   THEN innerTable.secondname WHEN innerTable.secondname IS NULL "
                + "                 THEN innerTable.firstname END) AS name, "
                + "           (CASE WHEN innerTable.firstRiskLevel = innerTable.secondRiskLevel "
                + "		   THEN innerTable.firstRiskLevel WHEN innerTable.firstriskscore IS NULL "
                + "		   THEN innerTable.secondRiskLevel WHEN innerTable.secondRiskLevel IS NULL "
                + "                 THEN innerTable.firstRiskLevel END) riskLevels, "
                + "           string_agg(CASE WHEN innerTable.firstriskscore = innerTable.secondriskscore "
                + "                THEN ROUND(innerTable.firstRiskscore,0)::text WHEN innerTable.firstRiskscore IS NULL "
                + "                THEN ROUND(innerTable.secondRiskscore,0)::text WHEN innerTable.secondRiskscore IS NULL "
                + "                 THEN ROUND(innerTable.firstRiskscore,0)::text END, ',' ORDER BY innerTable.firstIp) AS riskScores, " 
                + "           string_agg(CASE WHEN innerTable.firstIp = innerTable.secondIp "
                + "		   THEN innerTable.firstIp WHEN innerTable.firstIp IS NULL "
                + "		   THEN innerTable.secondIp WHEN innerTable.secondIp IS NULL "
                + "                 THEN innerTable.firstIp END, ',' ORDER BY innerTable.firstIp) AS ips, "
                + "           (CASE WHEN innerTable.firstScan IS NULL "
                + "		   THEN innerTable.secondScan WHEN innerTable.secondScan IS NULL "
                + "                 THEN innerTable.firstScan ELSE 'SAME' END) AS scanids, "
                + "           string_agg(CASE WHEN innerTable.firstPort = innerTable.secondPort "
                + "		   THEN innerTable.firstPort WHEN innerTable.firstPort IS NULL"
                + "		   THEN innerTable.secondPort WHEN innerTable.secondPort IS NULL "
                + "                 THEN innerTable.firstPort END, ',' ORDER BY innerTable.firstIp) AS ports, "
                + "           string_agg(CASE WHEN innerTable.firstProtocol = innerTable.secondProtocol "
                + "		   THEN innerTable.firstProtocol WHEN innerTable.firstProtocol IS NULL "
                + "		   THEN innerTable.secondProtocol WHEN innerTable.secondProtocol IS NULL "
                + "                 THEN innerTable.firstProtocol END, ',' ORDER BY innerTable.firstIp) AS protocols, "
                + "           string_agg(CASE WHEN innerTable.firstStatus IS NULL THEN innerTable.secondStatus "
                + "                 WHEN innerTable.secondStatus IS NULL THEN innerTable.firstStatus "
                + "		   ELSE (innerTable.firstStatus||','||innerTable.secondStatus) END,',' ORDER BY innerTable.firstIp) AS statuses "
                + "           FROM (SELECT * FROM "
                + "           (SELECT " + formula + " AS firstRiskscore, "
                + "           v.name AS firstName, v.risk_level AS firstRiskLevel, s.scan_id AS firstScan, a.ip firstIp, "
                + "           a.asset_id firstAsset, (CASE when ts.name IS NULL THEN 'passive' ELSE ts.name END) as firstStatus, "
                + "           (CASE when p.port_number IS NULL THEN '-' ELSE p.port_number::text END) AS firstPort, "
                + "           (CASE when p.protocol IS NULL THEN '-' ELSE p.protocol END) AS firstProtocol, s.scan_date AS firstDate "
                + "           FROM scan_vulnerability sv "
                + "           LEFT JOIN vulnerability v ON sv.vulnerability_id = v.vulnerability_id "
                + "           LEFT JOIN scan_asset asset ON asset.scan_asset_id = sv.scan_asset_id "
                + "           LEFT JOIN asset a ON a.asset_id = asset.asset_id "
                + "           LEFT JOIN port p ON p.port_id = sv.port_id "
                + "           LEFT JOIN scan s ON s.scan_id = asset.scan_id "
                + "           LEFT JOIN ticket_link tl ON sv.scan_vulnerability_id = tl.link_value"
                + "           LEFT JOIN ticket t ON (t.ticket_id = tl.ticket_id OR t.ticket_id is null) "
                + "           LEFT JOIN ticket_status ts ON (ts.ticket_status_id = t.status_id OR ts.ticket_status_id is null) "
                + "           WHERE a.customer_id = :customerId AND s.scan_id = :firstScan ORDER BY v.name) A "
                + "           FULL JOIN "
                + "           (SELECT " + formula + " AS secondRiskscore, "
                + "           v.name AS secondName, v.risk_level AS secondRiskLevel, s.scan_id AS secondScan, a.ip secondIp, "
                + "           a.asset_id secondAsset, (CASE when ts.name IS NULL THEN 'passive' ELSE ts.name END) as secondStatus, "
                + "           (CASE when p.port_number IS NULL THEN '-' ELSE p.port_number::text END) AS secondPort, "
                + "           (CASE when p.protocol IS NULL THEN '-' ELSE p.protocol END) AS secondProtocol, s.scan_date AS secondDate "
                + "           FROM scan_vulnerability sv "
                + "           LEFT JOIN vulnerability v ON sv.vulnerability_id = v.vulnerability_id "
                + "           LEFT JOIN scan_asset asset ON asset.scan_asset_id = sv.scan_asset_id "
                + "           LEFT JOIN asset a ON a.asset_id = asset.asset_id "
                + "           LEFT JOIN port p ON p.port_id = sv.port_id "
                + "           LEFT JOIN scan s ON s.scan_id = asset.scan_id "
                + "           LEFT JOIN ticket_link tl ON sv.scan_vulnerability_id = tl.link_value"
                + "           LEFT JOIN ticket t ON (t.ticket_id = tl.ticket_id OR t.ticket_id is null) "
                + "           LEFT JOIN ticket_status ts ON (ts.ticket_status_id = t.status_id OR ts.ticket_status_id is null) "
                + "           WHERE a.customer_id = :customerId AND s.scan_id = :secondScan ORDER BY v.name) B "
                + "           ON A.firstName = B.secondName AND A.firstRiskLevel = B.secondRiskLevel AND A.firstIp = B.secondIp "
                + "           AND A.firstPort = B.secondPort AND A.firstProtocol = B.secondProtocol)innerTable "
                + "           GROUP BY name, riskLevels, scanids ORDER BY riskLevels DESC ";
        sql+= createLimit(dataTablesRequest, params);
        return jdbcTemplate.query(sql, params, new ScanDiffResultSetExtractor(false));

    }
    
    public int getScanDiffCount(String customerId, String scan1Id, String scan2Id, boolean onlyDiff) {
        Map params = new HashMap();
        String formula = getVulnerabilityFormulaSqlByCustomerId(customerId);
        params.put("firstScan", scan1Id);
        params.put("secondScan", scan2Id);
        params.put("customerId", customerId);
        String sql = "SELECT COUNT (*) FROM (SELECT "
                + "           (CASE WHEN innerTable.firstname = innerTable.secondname "
                + "		   THEN innerTable.firstname WHEN innerTable.firstname IS NULL "
                + "		   THEN innerTable.secondname WHEN innerTable.secondname IS NULL "
                + "                 THEN innerTable.firstname END) AS name, "
                + "           (CASE WHEN innerTable.firstRiskLevel = innerTable.secondRiskLevel "
                + "		   THEN innerTable.firstRiskLevel WHEN innerTable.firstriskscore IS NULL "
                + "		   THEN innerTable.secondRiskLevel WHEN innerTable.secondRiskLevel IS NULL "
                + "                 THEN innerTable.firstRiskLevel END) riskLevels, "
                + "           string_agg(CASE WHEN innerTable.firstriskscore = innerTable.secondriskscore "
                + "                THEN ROUND(innerTable.firstRiskscore,0)::text WHEN innerTable.firstRiskscore IS NULL "
                + "                THEN ROUND(innerTable.secondRiskscore,0)::text WHEN innerTable.secondRiskscore IS NULL "
                + "                 THEN ROUND(innerTable.firstRiskscore,0)::text END, ',' ORDER BY innerTable.firstIp) AS riskScores, " 
                + "           string_agg(CASE WHEN innerTable.firstIp = innerTable.secondIp "
                + "		   THEN innerTable.firstIp WHEN innerTable.firstIp IS NULL "
                + "		   THEN innerTable.secondIp WHEN innerTable.secondIp IS NULL "
                + "                 THEN innerTable.firstIp END, ',' ORDER BY innerTable.firstIp) AS ips, "
                + "           (CASE WHEN innerTable.firstScan IS NULL "
                + "		   THEN innerTable.secondScan WHEN innerTable.secondScan IS NULL "
                + "                 THEN innerTable.firstScan ELSE 'SAME' END) AS scanids, "
                + "           string_agg(CASE WHEN innerTable.firstPort = innerTable.secondPort "
                + "		   THEN innerTable.firstPort WHEN innerTable.firstPort IS NULL"
                + "		   THEN innerTable.secondPort WHEN innerTable.secondPort IS NULL "
                + "                 THEN innerTable.firstPort END, ',' ORDER BY innerTable.firstIp) AS ports, "
                + "           string_agg(CASE WHEN innerTable.firstProtocol = innerTable.secondProtocol "
                + "		   THEN innerTable.firstProtocol WHEN innerTable.firstProtocol IS NULL "
                + "		   THEN innerTable.secondProtocol WHEN innerTable.secondProtocol IS NULL "
                + "                 THEN innerTable.firstProtocol END, ',' ORDER BY innerTable.firstIp) AS protocols, "
                + "           string_agg(CASE WHEN innerTable.firstStatus IS NULL THEN innerTable.secondStatus "
                + "                 WHEN innerTable.secondStatus IS NULL THEN innerTable.firstStatus "
                + "		   ELSE (innerTable.firstStatus||','||innerTable.secondStatus) END,',' ORDER BY innerTable.firstIp) AS statuses "
                + "           FROM (SELECT * FROM "
                + "           (SELECT " + formula + " AS firstRiskscore, "
                + "           v.name AS firstName, v.risk_level AS firstRiskLevel, s.scan_id AS firstScan, a.ip firstIp, "
                + "           a.asset_id firstAsset, (CASE when ts.name IS NULL THEN 'passive' ELSE ts.name END) as firstStatus, "
                + "           (CASE when p.port_number IS NULL THEN '-' ELSE p.port_number::text END) AS firstPort, "
                + "           (CASE when p.protocol IS NULL THEN '-' ELSE p.protocol END) AS firstProtocol, s.scan_date AS firstDate "
                + "           FROM scan_vulnerability sv "
                + "           LEFT JOIN vulnerability v ON sv.vulnerability_id = v.vulnerability_id "
                + "           LEFT JOIN scan_asset asset ON asset.scan_asset_id = sv.scan_asset_id "
                + "           LEFT JOIN asset a ON a.asset_id = asset.asset_id "
                + "           LEFT JOIN port p ON p.port_id = sv.port_id "
                + "           LEFT JOIN scan s ON s.scan_id = asset.scan_id "
                + "           LEFT JOIN ticket_link tl ON sv.scan_vulnerability_id = tl.link_value"
                + "           LEFT JOIN ticket t ON (t.ticket_id = tl.ticket_id OR t.ticket_id is null) "
                + "           LEFT JOIN ticket_status ts ON (ts.ticket_status_id = t.status_id OR ts.ticket_status_id is null) "
                + "           WHERE a.customer_id = :customerId AND s.scan_id = :firstScan ORDER BY v.name) A "
                + "           FULL JOIN "
                + "           (SELECT " + formula + " AS secondRiskscore, "
                + "           v.name AS secondName, v.risk_level AS secondRiskLevel, s.scan_id AS secondScan, a.ip secondIp, "
                + "           a.asset_id secondAsset, (CASE when ts.name IS NULL THEN 'passive' ELSE ts.name END) as secondStatus, "
                + "           (CASE when p.port_number IS NULL THEN '-' ELSE p.port_number::text END) AS secondPort, "
                + "           (CASE when p.protocol IS NULL THEN '-' ELSE p.protocol END) AS secondProtocol, s.scan_date AS secondDate "
                + "           FROM scan_vulnerability sv "
                + "           LEFT JOIN vulnerability v ON sv.vulnerability_id = v.vulnerability_id "
                + "           LEFT JOIN scan_asset asset ON asset.scan_asset_id = sv.scan_asset_id "
                + "           LEFT JOIN asset a ON a.asset_id = asset.asset_id "
                + "           LEFT JOIN port p ON p.port_id = sv.port_id "
                + "           LEFT JOIN scan s ON s.scan_id = asset.scan_id "
                + "           LEFT JOIN ticket_link tl ON sv.scan_vulnerability_id = tl.link_value"
                + "           LEFT JOIN ticket t ON (t.ticket_id = tl.ticket_id OR t.ticket_id is null) "
                + "           LEFT JOIN ticket_status ts ON (ts.ticket_status_id = t.status_id OR ts.ticket_status_id is null) "
                + "           WHERE a.customer_id = :customerId AND s.scan_id = :secondScan ORDER BY v.name) B "
                + "           ON A.firstName = B.secondName AND A.firstRiskLevel = B.secondRiskLevel AND A.firstIp = B.secondIp "
                + "           AND A.firstPort = B.secondPort AND A.firstProtocol = B.secondProtocol)innerTable ";
                if(onlyDiff){
                    sql+= " WHERE (CASE WHEN innerTable.firstScan IS NULL "
                + "		   THEN innerTable.secondScan WHEN innerTable.secondScan IS NULL "
                + "                 THEN innerTable.firstScan ELSE 'SAME' END) != 'SAME' ";
                }
                sql+= " GROUP BY name, riskLevels, scanids)allResult ";
        return (int) jdbcTemplate.queryForObject(sql, params, int.class);
    }

    public List<PentestScan> getRunningScans(DataTablesRequest dataTablesRequest, String customerId, String source, boolean isSsl) {
        Map params = new HashMap();
        params.put("customerId", customerId);
        params.put("source", Source.PENTEST.toString());
        String sql = "SELECT s.*, p.name as policy, se.domain   "
                + "FROM scan s "
                + "LEFT JOIN pentest_policy p "
                + "     ON (s.policy_id = p.id AND s.server_id = p.server_id) "
                + "LEFT JOIN server se "
                + "     ON se.setting_id=s.server_id "
                + "INNER JOIN ("
                + "SELECT DISTINCT s.scan_id, s.scan_date, s.source, s.name, s.completion_date, s.request_date, s.status, p.name as policy   "
                + "FROM scan s "
                + "LEFT JOIN pentest_policy p "
                + "     ON (s.policy_id = p.id AND s.server_id = p.server_id) "
                + " WHERE ";
        if (customerId != null) {
            sql += "s.customer_id= :customerId AND ";
        }
        sql += " s.source != :source AND ( s.status = :status1 OR s.status = :status2 OR s.status = :status3 OR s.status = :status4 ) ";
        if (!source.equals("all")) {
            sql += " AND s.source = :sourceFilter ";
            params.put("sourceFilter", source);
        }
        if(isSsl){
            sql += " AND s.ssl_scan = true ";
        } else {
            sql += " AND s.ssl_scan = false ";
        }
        sql += createOrderBy(scanColumnNameMapper, dataTablesRequest)
                + createLimit(dataTablesRequest, params)
                + ") ij "
                + "			ON ij.scan_id=s.scan_id  WHERE ";
        if (customerId != null) {
            sql += "s.customer_id= :customerId AND ";
        }
        sql += "s.source != :source AND ( s.status = :status1 OR s.status = :status2 OR s.status = :status3 OR s.status = :status4 ) ";
        if (!source.equals("all")) {
            sql += " AND s.source = :sourceFilter ";
            params.put("sourceFilter", source);
        }
        if(isSsl){
            sql += " AND s.ssl_scan = true ";
        } else {
            sql += " AND s.ssl_scan = false ";
        }
        sql += createSearch(scanColumnNameMapper, dataTablesRequest, params)
                + createOrderBy(scanColumnNameMapper, dataTablesRequest);

        params.put("status1", ScanStatus.RUNNING.getValue());
        params.put("status2", ScanStatus.QUEUED.getValue());
        params.put("status3", ScanStatus.PAUSED.getValue());
        params.put("status4", ScanStatus.IMPORTING.getValue());

        return jdbcTemplate.query(sql, params, new ScanResultSetExtractor(false));
    }

    public int getScheduledScansCount(DataTablesRequest dataTablesRequest, String customerId, String source, boolean isSsl) {
        Map params = new HashMap();
        params.put("customerId", customerId);
        params.put("source", Source.PENTEST.toString());
        String sql = "SELECT count(*) as count "
                + "FROM scheduled_scan s "
                + "LEFT JOIN pentest_policy p "
                + "     ON (s.policy_id = p.id AND s.server_id = p.server_id) "
                + "WHERE customer_id= :customerId AND s.source != :source ";
        if (!source.equals("all")) {
            sql += " AND s.source = :sourceFilter ";
            params.put("sourceFilter", source);
        }
        if(isSsl){
            sql += " AND s.ssl_scan = true ";
        } else {
            sql += " AND s.ssl_scan = false ";
        }
        sql += " AND ((s.recurrence != -1 AND s.recurrence-s.completed_scan_count != '0') or s.recurrence = -1) "
                + "  AND (s.occurrence!='ON_DEMAND' OR (s.occurrence='ON_DEMAND' AND completed_scan_count!=1))  "
                + createSearch(scheduledScanColumnNameMapper, dataTablesRequest, params);

        Integer count = jdbcTemplate.queryForObject(sql, params, Integer.class);
        return count;
    }

    public List<ScheduledPentestScan> getScheduledScans(DataTablesRequest dataTablesRequest, String customerId, String source, boolean isSsl) {
        Map params = new HashMap();
        params.put("customerId", customerId);
        params.put("source", Source.PENTEST.toString());
        String sql = "SELECT s.*, p.name as policy, spd.* "
                + "FROM scheduled_scan s "
                + "LEFT JOIN pentest_policy p "
                + "     ON (s.policy_id = p.id AND s.server_id = p.server_id) "
                + "LEFT JOIN scan_project_details spd "
                + " ON spd.scan_id = s.scheduled_scan_id "
                + "WHERE source != :source ";
        if (customerId != null) {
            sql += " AND customer_id= :customerId AND ((s.recurrence != -1 AND s.recurrence-s.completed_scan_count != '0') or s.recurrence = -1) "
                    + "  AND (s.occurrence!='ON_DEMAND' OR (s.occurrence='ON_DEMAND' AND completed_scan_count!=1)) ";
        }
        if (!source.equals("all")) {
            sql += " AND s.source = :sourceFilter ";
            params.put("sourceFilter", source);
        }
        if(isSsl){
            sql += " AND s.ssl_scan = true ";
        } else {
            sql += " AND s.ssl_scan = false ";
        }
        if (dataTablesRequest != null) {
            sql += createSearch(scheduledScanColumnNameMapper, dataTablesRequest, params)
                    + createOrderBy(scheduledScanColumnNameMapper, dataTablesRequest)
                    + createLimit(dataTablesRequest, params);
        }

        return jdbcTemplate.query(sql, params, new ScheduledScanResultSetExtractor(false));
    }

    public PentestScan getScanByName(String name) {
        String sql = "SELECT s.*, asset.scanned_ip as scanned_ip, p.name as policy, se.domain as domain  "
                + " FROM scan s "
                + "LEFT JOIN scan_asset asset "
                + "ON s.scan_id = asset.scan_id "
                + "LEFT JOIN pentest_policy p "
                + "     ON (s.policy_id = p.id AND s.server_id = p.server_id) "
                + "LEFT JOIN server se "
                + "     ON se.setting_id=s.server_id "
                + "WHERE s.name= :name ";
        Map params = new HashMap();
        params.put("name", name);
        List<PentestScan> result = jdbcTemplate.query(sql, params, new ScanResultSetExtractor(false));
        if (result.isEmpty()) {
            return null;
        } else {
            return result.get(0);
        }
    }

    public String getScanByName(String name, String customerId) {
        String sql = "SELECT s.name "
                + " FROM scan s "
                + "WHERE s.name= :name AND s.customer_id =:customerId LIMIT 1 ";
        Map params = new HashMap();
        params.put("name", name);
        params.put("customerId", customerId);
        try {
            String result = jdbcTemplate.queryForObject(sql, params, String.class);
            return result;
        } catch (Exception ex) {
            return null;
        }
    }

    public List<PentestScan> getScanByType(String type) {
        String sql = "SELECT s.*, asset.scanned_ip as scanned_ip, p.name as policy, a.ip, se.domain, count(*) over ( partition by asset.scan_id ) as asset_count   "
                + "FROM scan s "
                + "LEFT JOIN scan_asset asset "
                + "ON s.scan_id = asset.scan_id "
                + "LEFT JOIN pentest_policy p "
                + "     ON (s.policy_id = p.id AND s.server_id = p.server_id) "
                + "LEFT JOIN asset a "
                + "     ON asset.asset_id=a.asset_id "
                + "LEFT JOIN server se "
                + "     ON se.setting_id=s.server_id "
                + "WHERE s.name= :type AND s.hidden = true";
        Map params = new HashMap();
        params.put("type", type);
        List<PentestScan> result = jdbcTemplate.query(sql, params, new ScanDetailsResultSetExtractor(false));
        return result;
    }

    public ScheduledPentestScan getScheduledScanById(String scanId) {
        String sql = "SELECT s.*, p.name as policy, spd.* "
                + "FROM scheduled_scan s "
                + "LEFT JOIN pentest_policy p "
                + "     ON (s.policy_id = p.id AND s.server_id = p.server_id) "
                + "LEFT JOIN scan_project_details spd "
                + " ON spd.scan_id = s.scheduled_scan_id "
                + "WHERE s.scheduled_scan_id= :scanId ";
        Map params = new HashMap();
        params.put("scanId", scanId);
        List<ScheduledPentestScan> result = jdbcTemplate.query(sql, params, new ScheduledScanResultSetExtractor(false));
        if (result.isEmpty()) {
            return null;
        } else {
            return result.get(0);
        }
    }

    public void saveScheduledScan(PentestScan scan) {
        if (scan.getScanner() == null) {
            PentestScanner scanner = new PentestScanner();
            scan.setScanner(scanner);
        }
        if (scan.getPolicy() == null) {
            PentestPolicy policy = new PentestPolicy();
            scan.setPolicy(policy);
        }
        if (scan.getServer() == null) {
            Server server = new Server();
            scan.setServer(server);
        }
        if (scan.getTimezone() == null) {
            PentestTimezone timezone = new PentestTimezone();
            scan.setTimezone(timezone);
        }
        scan.setCount(0);

        String sql = "INSERT INTO scheduled_scan "
                + "(scheduled_scan_id, name, description, requested_by, request_date, scan_date, status, customer_id, scan_ref, report_id, policy_id, timezone, min_risk_level, "
                + "include_ips, exclude_ips, occurrence, recurrence, is_scheduled, scanner_id, server_id, source, results_saved, completed_scan_count, active, customized_scan, "
                + "scan_proscriptive_time_start, scan_proscriptive_time_end, mail , asset_group_id, update_operating_system, auto_close, sync_scan, ssl_scan, ssl_scan_ports, produce_ssl_certificate_results, scan_aggregation, is_scan_weekend ) "
                + "VALUES "
                + "(:scanId, :name, :description, :requestedBy, :requestDate, :scanDate, :status, :customer.customerId, :scanRef, :reportId, :policy.id, :timezone.value, :minRiskLevel, "
                + ":includedIps, :excludeIps, :occurrence, :recurrence, :scheduled, :scanner.id, :server.settingId, :source, :resultsSaved, :count, :active, :customizedScan, "
                + ":scanProscriptiveTimeStart, :scanProscriptiveTimeEnd, :mail ,:assetGroupId, :updateOperatingSystem, :autoClose, :syncScan, :sslScan, :sslScanPorts, :produceSslCertificateResults, :scanAggregation, :scanWeekend ) ";

        int rows = jdbcTemplate.update(sql, new CustomParameterSource(scan));
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
        if (scan.getProjectDetails() != null) {
            Map params = new HashMap();
            params.put("scanId", scan.getScanId());
            params.put("repository", scan.getProjectDetails().getRepository());
            params.put("pluginId", scan.getProjectDetails().getPluginId());
            params.put("projectName", scan.getProjectDetails().getProjectName());
            params.put("language", scan.getProjectDetails().getLanguageType());
            params.put("buildTool", scan.getProjectDetails().getBuildTool());
            params.put("command", scan.getProjectDetails().getCommand());
            params.put("vcsId", scan.getProjectDetails().getVcsId());
            params.put("vcsPath", scan.getProjectDetails().getVcsPath());
            String vcsSql = "INSERT INTO scan_project_details "
                    + "(scan_id, project_name, language, build_tool, command, vcs_id, vcs_path, repository, plugin_id) "
                    + "VALUES "
                    + "(:scanId, :projectName, :language, :buildTool, :command, :vcsId, :vcsPath, :repository, :pluginId) ";

            int rows2 = jdbcTemplate.update(vcsSql, params);
            if (rows2 != 1) {
                throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
                };
            }
        }
    }

    public void updateScheduledScanById(String scanId, String customerId, Integer count) {

        String sql = "UPDATE scheduled_scan "
                + "SET completed_scan_count= :count "
                + "WHERE customer_id= :customerId AND scheduled_scan_id= :scanId ";

        Map params = new HashMap();
        params.put("scanId", scanId);
        params.put("customerId", customerId);
        params.put("count", count);
        int rows = jdbcTemplate.update(sql, params);
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
    }

    public void updateScan(String scanId) {

        String sql = "UPDATE scan "
                + "SET scheduled_scan_id = NULL "
                + "WHERE scan_id= :scanId ";

        Map params = new HashMap();
        params.put("scanId", scanId);
        int rows = jdbcTemplate.update(sql, params);
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
    }

    public void updateAssetDiscovery(String scanId) {

        String sql = "UPDATE passive_asset_scan "
                + "SET scheduled_passive_asset_scan_id = NULL "
                + "WHERE id= :scanId ";

        Map params = new HashMap();
        params.put("scanId", scanId);
        int rows = jdbcTemplate.update(sql, params);
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
    }

    public void updateScheduledScan(ScheduledPentestScan scan) {
        if (scan.getTimezone() == null) {
            scan.setTimezone(new PentestTimezone());
        }
        if (scan.getPolicy()== null) {
            scan.setPolicy(new PentestPolicy());
        }        
        if (scan.getScanner()== null) {
            scan.setScanner(new PentestScanner());
        }        
        String sql = "UPDATE scheduled_scan "
                + "SET name= :name, description= :description, requested_by= :requestedBy, request_date= :requestDate, scan_date= :scanDate, status= :status, customer_id= :customer.customerId"
                + ", scan_ref= :scanRef, report_id= :reportId, policy_id= :policy.id, timezone= :timezone.value, min_risk_level= :minRiskLevel, include_ips= :includedIps"
                + ", exclude_ips= :excludeIps, occurrence= :occurrence, recurrence= :recurrence, is_scheduled= :scheduled, scanner_id= :scanner.id, server_id= :server.settingId, source= :source, results_saved= :resultsSaved"
                + ", completed_scan_count= :completedScanCount, active= :active, scan_proscriptive_time_start= :scanProscriptiveTimeStart, scan_proscriptive_time_end= :scanProscriptiveTimeEnd, update_operating_system = :updateOperatingSystem "
                + "WHERE scheduled_scan_id= :uuid ";

        CustomParameterSource paramSource = new CustomParameterSource(scan);
        int rows = jdbcTemplate.update(sql, paramSource);
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
    }

    public void changeScheduledScanStatus(String scanId, boolean status) {
        String sql = "UPDATE scheduled_scan "
                + "SET active= :status "
                + "WHERE scheduled_scan_id= :scanId ";
        Map params = new HashMap();
        params.put("scanId", scanId);
        params.put("status", status);
        int rows = jdbcTemplate.update(sql, params);
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
    }

    public void updateScheduledHostScan(ScheduledAssetDiscovery scan) {
        String sql = "UPDATE scheduled_passive_asset_scan "
                + "SET name= :name, description= :description, requested_by= :requestedBy, request_date= :requestDate, scan_date= :scanDate, status= :status, customer_id= :customer.customerId"
                + ", policy_id= :policyId, timezone= :timezone.value, min_risk_level= :minRiskLevel, target= :target, params= :params, ports= :ports, mail= :mail, exclude_ips= :excludeIps"
                + ", recurrence= :recurrence, launch= :launch, scanner_id= :scanner.id, server_id= :server.settingId, source= :source "
                + ", completed_scan_count= :completedScanCount, result_action= :resultAction, asset_group_id = :assetGroupId, alarm_level= :alarmLevel, "
                + " policy_id_for_scan = :policyIdForScan, server_id_for_scan = :serverIdForScan, scanner_id_for_scan = :scannerIdForScan, timezone_for_scan = :timezoneForScan, auto_close_for_scan = :autoCloseForScan, active= :active  "
                + "WHERE id= :id ";

        if (scan.getScanner() == null) {
            scan.setScanner(new PentestScanner());
        }
        if (scan.getServer() == null) {
            scan.setServer(new Server());
        }
        if (scan.getTimezone() == null) {
            scan.setTimezone(new PentestTimezone());
        }

        CustomParameterSource paramSource = new CustomParameterSource(scan);
        int rows = jdbcTemplate.update(sql, paramSource);
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
    }

    public void changeScheduledHostStatus(String id, boolean status) {
        String sql = "UPDATE scheduled_passive_asset_scan "
                + "SET active= :status "
                + "WHERE id= :id ";
        Map params = new HashMap();
        params.put("id", id);
        params.put("status", status);
        int rows = jdbcTemplate.update(sql, params);
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
    }

    public int getHostScansCount(DataTablesRequest dataTablesRequest, String customerId) {
        Map params = new HashMap();
        params.put("customerId", customerId);
        String sql = "SELECT count(*) as count "
                + "FROM passive_asset_scan s "
                + "WHERE s.customer_id= :customerId"
                + createSearch(hostScanColumnNameMapper, dataTablesRequest, params);

        Integer count = jdbcTemplate.queryForObject(sql, params, Integer.class);
        return count;
    }

    public int getRunningHostScansCount(DataTablesRequest dataTablesRequest, String customerId) {
        Map params = new HashMap();
        params.put("customerId", customerId);
        String sql = "SELECT count(*) as count "
                + "FROM passive_asset_scan s "
                + "WHERE s.customer_id= :customerId AND (s.status = 'QUEUED' OR s.status = 'RUNNING' OR s.status = 'PAUSED') "
                + createSearch(hostScanColumnNameMapper, dataTablesRequest, params);

        Integer count = jdbcTemplate.queryForObject(sql, params, Integer.class);
        return count;
    }

    public int getCompletedHostScansCount(DataTablesRequest dataTablesRequest, String customerId) {
        Map params = new HashMap();
        params.put("customerId", customerId);
        String sql = "SELECT count(*) as count "
                + "FROM passive_asset_scan s "
                + "WHERE s.customer_id= :customerId AND (s.status != 'QUEUED' AND s.status != 'RUNNING') "
                + createSearch(hostScanColumnNameMapper, dataTablesRequest, params);

        Integer count = jdbcTemplate.queryForObject(sql, params, Integer.class);
        return count;
    }

    public List<AssetDiscovery> getHostScans(DataTablesRequest dataTablesRequest, String customerId) {
        Map params = new HashMap();
        params.put("customerId", customerId);
        String sql = "SELECT s.* , a.domain "
                + "FROM passive_asset_scan s "
                + "LEFT JOIN server a ON a.setting_id = s.server_id "
                + "WHERE s.customer_id= :customerId "
                + createSearch(hostScanColumnNameMapper, dataTablesRequest, params)
                + createOrderBy(hostScanColumnNameMapper, dataTablesRequest)
                + createLimit(dataTablesRequest, params);

        return jdbcTemplate.query(sql, params, new HostScanResultSetExtractor(false));
    }

    public List<AssetDiscovery> getRunningHostScans(DataTablesRequest dataTablesRequest, String customerId) {
        Map params = new HashMap();
        params.put("customerId", customerId);
        String sql = "SELECT s.* , a.domain "
                + "FROM passive_asset_scan s "
                + "LEFT JOIN server a ON a.setting_id = s.server_id "
                + "WHERE s.customer_id= :customerId AND (s.status = 'QUEUED' OR s.status = 'RUNNING' OR s.status = 'PAUSED') "
                + createSearch(hostScanColumnNameMapper, dataTablesRequest, params)
                + createOrderBy(hostScanColumnNameMapper, dataTablesRequest)
                + createLimit(dataTablesRequest, params);

        return jdbcTemplate.query(sql, params, new HostScanResultSetExtractor(false));
    }

    public List<AssetDiscovery> getCompletedHostScans(DataTablesRequest dataTablesRequest, String customerId) {
        Map params = new HashMap();
        params.put("customerId", customerId);
        String sql = "SELECT s.* , a.domain , last_scan.id AS last_scan_id "
                + "FROM passive_asset_scan s "
                + "LEFT JOIN server a ON a.setting_id = s.server_id "
                + "LEFT JOIN LATERAL ( " 
                + "SELECT id, scheduled_passive_asset_scan_id " 
                + "FROM passive_asset_scan " 
                + "WHERE scheduled_passive_asset_scan_id= s.scheduled_passive_asset_scan_id " 
                + "AND id != s.id AND status= 'COMPLETED' " 
                + "AND completion_date < s.scan_date " 
                + "ORDER BY scan_date DESC LIMIT 1 " 
                + ") last_scan ON s.scheduled_passive_asset_scan_id = last_scan.scheduled_passive_asset_scan_id "
                + "WHERE s.customer_id= :customerId AND (s.status != 'QUEUED' AND s.status != 'RUNNING' AND s.status != 'PAUSED') "
                + createSearch(hostScanColumnNameMapper, dataTablesRequest, params)
                + createOrderBy(hostScanColumnNameMapper, dataTablesRequest)
                + createLimit(dataTablesRequest, params);

        return jdbcTemplate.query(sql, params, new HostScanResultSetExtractor(false));
    }
    
    public AssetDiscovery setActiveAndNewHostCounts(AssetDiscovery assetDiscovery) {
        Map params = new HashMap();
        params.put("scanId", assetDiscovery.getId());
        params.put("lastScanId", assetDiscovery.getLastScanId());
        String sql = "SELECT new_scan.scan_id, COUNT(*) AS active_host_count, " 
                + "CASE WHEN (:lastScanId)::TEXT IS NULL THEN null "
                + "ELSE COUNT(CASE WHEN last_scan.id IS NULL THEN 1 ELSE null END) END AS new_host_count " 
                + "FROM	(SELECT pasr.* " 
                + "FROM passive_asset_scan_result pasr " 
                + "WHERE pasr.scan_id= :scanId) new_scan " 
                + "LEFT JOIN (SELECT pasr.* " 
                + "FROM passive_asset_scan_result pasr " 
                + "WHERE pasr.scan_id= :lastScanId) last_scan ON new_scan.ip = last_scan.ip " 
                + "GROUP BY new_scan.scan_id";
        
        List<AssetDiscovery> list = jdbcTemplate.query(sql, params, new HostCountsResultSetExtractor(false));
        if(list.isEmpty()) {
            return assetDiscovery;
        } else {
            assetDiscovery.setActiveHostsCount(list.get(0).getActiveHostsCount());
            if(assetDiscovery.getScheduledAssetDiscovery() == null) {
                assetDiscovery.setNewHostsCount(-1);
            } else {
                assetDiscovery.setNewHostsCount(list.get(0).getNewHostsCount());
            }
            return assetDiscovery;
        }
    }

    public int getScheduledHostScansCount(DataTablesRequest dataTablesRequest, String customerId) {
        Map params = new HashMap();
        params.put("customerId", customerId);
        String sql = "SELECT count(*) as count "
                + "FROM scheduled_passive_asset_scan s "
                + "WHERE s.customer_id= :customerId AND ((s.recurrence != '-1' AND NULLIF(s.recurrence, '')::int - s.completed_scan_count != 0) or s.recurrence = '-1')\n"
                + "AND (s.launch!='ON_DEMAND' OR (s.launch='ON_DEMAND' AND completed_scan_count!='1')) "
                + createSearch(hostScanColumnNameMapper, dataTablesRequest, params);

        Integer count = jdbcTemplate.queryForObject(sql, params, Integer.class);
        return count;
    }

    public List<ScheduledAssetDiscovery> getScheduledHostScans(DataTablesRequest dataTablesRequest, String customerId) {
        Map params = new HashMap();
        params.put("customerId", customerId);
        String sql = "SELECT s.* "
                + "FROM scheduled_passive_asset_scan s ";
        if (customerId != null) {
            sql += " WHERE s.customer_id= :customerId AND ((s.recurrence != '-1' AND NULLIF(s.recurrence, '')::int - s.completed_scan_count != 0) or s.recurrence = '-1')\n"
                    + "AND (s.launch!='ON_DEMAND' OR (s.launch='ON_DEMAND' AND completed_scan_count!='1')) ";
        }
        if (dataTablesRequest != null) {
            sql += createSearch(hostScanColumnNameMapper, dataTablesRequest, params)
                    + createOrderBy(hostScanColumnNameMapper, dataTablesRequest)
                    + createLimit(dataTablesRequest, params);
        }

        return jdbcTemplate.query(sql, params, new ScheduledHostScanResultSetExtractor(false));
    }

    public PentestScan getScanById(String scanId) {
        String sql = "SELECT s.*, spd.*, asset.scanned_ip as scanned_ip, p.name as policy, a.ip, se.domain, count(*) over ( partition by asset.scan_id ) as asset_count   "
                + "FROM scan s "
                + "LEFT JOIN scan_asset asset "
                + "ON s.scan_id = asset.scan_id "
                + "LEFT JOIN pentest_policy p "
                + "     ON (s.policy_id = p.id AND s.server_id = p.server_id) "
                + "LEFT JOIN asset a "
                + "     ON asset.asset_id=a.asset_id "
                + "LEFT JOIN server se "
                + "     ON se.setting_id=s.server_id "
                + "LEFT JOIN scan_project_details spd "
                + "     ON spd.scan_id = s.scan_id "
                + "WHERE s.scan_id= :scanId ";
        Map params = new HashMap();
        params.put("scanId", scanId);
        List<PentestScan> result = jdbcTemplate.query(sql, params, new ScanDetailsResultSetExtractor(false));
        if (result.isEmpty()) {
            return null;
        } else {
            return result.get(0);
        }
    }

    public PentestScan getScanDetailsWithoutAssets(String scanId) {
        String sql = "SELECT *   "
                + "FROM scan "
                + "WHERE scan_id= :scanId ";
        Map params = new HashMap();
        params.put("scanId", scanId);
        try {
            return jdbcTemplate.queryForObject(sql, params, new ScanDetailsRowMapper());
        } catch (EmptyResultDataAccessException e) {
            return null;
        }
    }

    public String getScanIdByScanAssetId(String scanAssetId) {
        String sql = "SELECT scan_id FROM scan_asset "
                + "WHERE scan_asset_id= :scanAssetId ";
        Map params = new HashMap();
        params.put("scanAssetId", scanAssetId);
        String result = jdbcTemplate.queryForObject(sql, params, String.class);
        return result;
    }

    public String getScanNameByScanId(String scanId) {
        String sql = "SELECT name FROM scan "
                + "WHERE scan_id= :scanId ";
        Map params = new HashMap();
        params.put("scanId", scanId);
        String result = jdbcTemplate.queryForObject(sql, params, String.class);
        return result;
    }

    public LinkedHashMap<String, String> getScanNames(String customerId) {
        String sql = "SELECT name, scan_id FROM scan "
                + "WHERE customer_id = :customerId AND results_saved='true'"
                +"ORDER BY scan_date desc";
        Map params = new HashMap();
        params.put("customerId", customerId);

        return jdbcTemplate.query(sql, params, new ScanNamesResultSetExtractor(false));
    }

    public void saveHostScan(AssetDiscovery scan) {
        if (scan.getScanner() == null) {
            PentestScanner scanner = new PentestScanner();
            scan.setScanner(scanner);
        }
        if (scan.getServer() == null) {
            Server server = new Server();
            scan.setServer(server);
        }
        if (scan.getTimezone() == null) {
            PentestTimezone timezone = new PentestTimezone();
            scan.setTimezone(timezone);
        }
        if (scan.getScheduledAssetDiscovery() == null) {
            ScheduledAssetDiscovery scheduledAssetDiscovery = new ScheduledAssetDiscovery();
            scan.setScheduledAssetDiscovery(scheduledAssetDiscovery);
        }
        String sql = "INSERT INTO passive_asset_scan "
                + "(id, name, description, requested_by, request_date, scan_date, status, customer_id, timezone, "
                + "target, launch, recurrence, scheduled, scanner_id, server_id, source, results_saved, scheduled_passive_asset_scan_id, result_action, policy_id, policy_id_for_scan, "
                + "mail, asset_group_id, min_risk_level, server_id_for_scan, scanner_id_for_scan, timezone_for_scan, auto_close_for_scan, ports, params, alarm_level, scan_proscriptive_time_start, "
                + "scan_proscriptive_time_end, exclude_ips, tool_scan_id, auto_grouping)"
                + "VALUES "
                + "(:id, :name, :description, :requestedBy, :requestDate, :scanDate, :status, :customer.customerId, :timezone.value, "
                + ":target, :launch, :recurrence, :scheduled, :scanner.id, :server.settingId, :source, :resultsSaved, :scheduledAssetDiscovery.id, :resultAction, :policyId, :policyIdForScan,"
                + ":mail, :assetGroupId, :minRiskLevel, :serverIdForScan, :scannerIdForScan, :timezoneForScan, :autoCloseForScan, :ports, :params , :alarmLevel, :scanProscriptiveTimeStart, "
                + ":scanProscriptiveTimeEnd, :excludeIps, :toolScanId, :autoGroupAssign) ";

        int rows = jdbcTemplate.update(sql, new CustomParameterSource(scan));
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
    }

    public void saveScheduledHostScan(AssetDiscovery scan) throws ClassNotFoundException {
        if (scan.getScanner() == null) {
            PentestScanner scanner = new PentestScanner();
            scan.setScanner(scanner);
        }
        if (scan.getServer() == null) {
            Server server = new Server();
            scan.setServer(server);
        }
        if (scan.getTimezone() == null) {
            PentestTimezone timezone = new PentestTimezone();
            scan.setTimezone(timezone);
        }
        scan.setCount(0);

        String sql = "INSERT INTO scheduled_passive_asset_scan "
                + "(id, name, description, requested_by, request_date, scan_date, status, customer_id, timezone, params, ports, "
                + "target, launch, recurrence, scheduled, scanner_id, server_id, source, results_saved, completed_scan_count, result_action, policy_id, policy_id_for_scan,"
                + "mail, asset_group_id, min_risk_level, server_id_for_scan, scanner_id_for_scan, timezone_for_scan, auto_close_for_scan, active, alarm_level, scan_proscriptive_time_start, "
                + "scan_proscriptive_time_end, exclude_ips, auto_grouping) "
                + "VALUES "
                + "(:id, :name, :description, :requestedBy, :requestDate, :scanDate, :status, :customer.customerId, :timezone.value, :params, :ports, "
                + ":target, :launch, :recurrence, :scheduled, :scanner.id, :server.settingId, :source, :resultsSaved , :count, :resultAction, :policyId, :policyIdForScan,"
                + ":mail, :assetGroupId, :minRiskLevel, :serverIdForScan, :scannerIdForScan, :timezoneForScan, :autoCloseForScan, :active, :alarmLevel, :scanProscriptiveTimeStart, "
                + ":scanProscriptiveTimeEnd, :excludeIps, :autoGroupAssign) ";

        int rows = jdbcTemplate.update(sql, new CustomParameterSource(scan));
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
    }

    /**
     * Tarama bilgisini ve taranan ip bilgisini kaydeder.
     *
     * @param scan
     */
    @Transactional
    public void saveScan(PentestScan scan) {
        if (scan.getScanner() == null) {
            PentestScanner scanner = new PentestScanner();
            scan.setScanner(scanner);
        }
        if (scan.getPolicy() == null) {
            PentestPolicy policy = new PentestPolicy();
            scan.setPolicy(policy);
        }
        if (scan.getServer() == null) {
            Server server = new Server();
            scan.setServer(server);
        }
        if (scan.getTimezone() == null) {
            PentestTimezone timezone = new PentestTimezone();
            scan.setTimezone(timezone);
        }
        if (scan.getScheduledPentestScan() == null) {
            ScheduledPentestScan scheduledPentestScan = new ScheduledPentestScan();
            scan.setScheduledPentestScan(scheduledPentestScan);
        }

        String sql = "INSERT INTO scan "
                + "(scan_id, name, description, requested_by, request_date, scan_date, status, customer_id, scan_ref, report_id, policy_id, timezone, min_risk_level, "
                + "include_ips, exclude_ips, occurrence, recurrence, is_scheduled, scanner_id, server_id, source, results_saved, scheduled_scan_id, hidden, tool_scan_id, "
                + "scan_proscriptive_time_start, scan_proscriptive_time_end, mail, close_vulnerabilities_under_min_level, asset_group_id, update_operating_system, auto_close, sync_scan, ssl_scan, ssl_scan_ports, customized_scan, produce_ssl_certificate_results, scan_aggregation) "
                + "VALUES "
                + "(:scanId, :name, :description, :requestedBy, :requestDate, :scanDate, :status, :customer.customerId, :scanRef, :reportId, :policy.id, :timezone.value, :minRiskLevel, "
                + ":targets, :excludeIps, :occurrence, :recurrence, :scheduled, :scanner.id, :server.settingId, :source, :resultsSaved, :scheduledPentestScan.uuid, :hidden, :toolScanId, "
                + ":scanProscriptiveTimeStart, :scanProscriptiveTimeEnd, :mail, :useDefaultMinRiskLevelAction, :assetGroupId, :updateOperatingSystem, :autoClose, :syncScan, :sslScan, :sslScanPorts, :customizedScan, :produceSslCertificateResults, :scanAggregation) ";

        int rows = jdbcTemplate.update(sql, new CustomParameterSource(scan));
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
        //VCS ile balantl bir tarama balatlmsa
        if (scan.getProjectDetails() != null) {
            Map params = new HashMap();
            params.put("scanId", scan.getScanId());
            String vcsSql;
            if(scan.getServer().getType().equals(ServerType.SECURITY_CENTER.toString())) {
                params.put("repository", scan.getProjectDetails().getRepository());
                params.put("pluginId", scan.getProjectDetails().getPluginId());
                vcsSql = "INSERT INTO scan_project_details "
                        + "(scan_id, repository, plugin_id) "
                        + "VALUES "
                        + "(:scanId, :repository, :pluginId) ";
            } else {
                params.put("projectName", scan.getProjectDetails().getProjectName());
                params.put("language", scan.getProjectDetails().getLanguageType());
                params.put("buildTool", scan.getProjectDetails().getBuildTool());
                params.put("command", scan.getProjectDetails().getCommand());
                params.put("revision", scan.getProjectDetails().getRevision());
                params.put("vcsId", scan.getProjectDetails().getVcsId());
                params.put("vcsPath", scan.getProjectDetails().getVcsPath());
                vcsSql = "INSERT INTO scan_project_details "
                        + "(scan_id, project_name, language, build_tool, command, vcs_id, vcs_path, revision) "
                        + "VALUES "
                        + "(:scanId, :projectName, :language, :buildTool, :command, :vcsId, :vcsPath, :revision) ";
            }
            int rows2 = jdbcTemplate.update(vcsSql, params);
            if (rows2 != 1) {
                throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
                };
            } 
            
        }
        
        if(scan.getLabels() != null && !"".equals(scan.getLabels())) {
            String [] datas = scan.getLabels().split(",");
            for(String labelId : datas) {
                Map params = new HashMap();
                ScanLabel scanLabel = new ScanLabel();
                String scanLabelId = scanLabel.getScanLabelId();
                scanLabel.setScanLabelId(BizzyUtil.generateGUID());
                
                params.put("scanLabelId", scanLabel.getScanLabelId());
                params.put("scanId", scan.getScanId());
                params.put("labelId", labelId);
                String labelSql;
                labelSql = "INSERT INTO scan_label "
                            + " (scan_label_id,label_id,scan_id) "
                            + " VALUES "
                            + "(:scanLabelId, :labelId, :scanId) ";
                int rowLabel = jdbcTemplate.update(labelSql, params);
                
                if (rowLabel != 1) {
                    throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
                    };
                }
            }
        }
    }

    public String saveScanAssets(List<ScanAsset> scanAssets, String scanId) {
        String scanAssetSql = "INSERT INTO scan_asset "
                + "(scan_asset_id, scan_id, asset_id, scanned_ip, scanned_name) "
                + "SELECT "
                + ":scanAssetId, :scanId, :assetId, :scannedIp, :scannedName "
                + "WHERE NOT EXISTS (SELECT scanned_ip FROM scan_asset WHERE scan_id = :scanId AND asset_id = :assetId) ";
        BeanPropertySqlParameterSource[] parameterSources = new BeanPropertySqlParameterSource[scanAssets.size()];
        int index = 0;
        for (ScanAsset asset : scanAssets) {
            asset.setScanAssetId(BizzyUtil.generateGUID());
            asset.setScanId(scanId);
            parameterSources[index] = new CustomParameterSource(asset);
            index++;
        }
        jdbcTemplate.batchUpdate(scanAssetSql, parameterSources);

        return scanId;
    }
    
    public String getScannerPolicyIdByScanVulnerabilityId(String svId) {
        Map params = new HashMap();
        String sql = "SELECT policy_id from scan s "
                + "LEFT JOIN scan_asset sa ON sa.scan_id = s.scan_id "
                + "LEFT JOIN scan_vulnerability sv ON sv.scan_asset_id = sa.scan_asset_id "
                + "WHERE sv.scan_vulnerability_id = :svId";
        params.put("svId", svId);
        String policyId = jdbcTemplate.queryForObject(sql, params, String.class);
        return policyId;
    }

    public void savePentestScanner(List<PentestScanner> scannerList) {
        if (scannerList.size() > 0) {
            String sql = "INSERT INTO pentest_scanner "
                    + "(id, name, activation_code, type, platform, status, expiration_date, server_id) "
                    + "VALUES "
                    + "(:id, :name, :activationCode, :type, :platform, :status, :expirationDate, :serverId)";
            BeanPropertySqlParameterSource[] parameterSources = new BeanPropertySqlParameterSource[scannerList.size()];
            int index = 0;

            for (PentestScanner s : scannerList) {
                parameterSources[index] = new CustomParameterSource(s);
                index++;
            }

            int[] rows = jdbcTemplate.batchUpdate(sql, parameterSources);

            for (int i = 0; i < rows.length; i++) {
                if (rows[i] != 1) {
                    throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows[i]) {
                    };
                }
            }
        }

    }

    public void savePentestPolicies(List<PentestPolicy> policyList) {
        if (policyList.size() > 0) {
            String sql = "INSERT INTO pentest_policy "
                    + "(id, name, server_id) "
                    + "VALUES "
                    + "(:id, :name, :serverId) ";

            BeanPropertySqlParameterSource[] parameterSources = new BeanPropertySqlParameterSource[policyList.size()];
            int index = 0;

            for (PentestPolicy p : policyList) {
                parameterSources[index] = new CustomParameterSource(p);
                index++;
            }

            int[] rows = jdbcTemplate.batchUpdate(sql, parameterSources);

            for (int i = 0; i < rows.length; i++) {
                if (rows[i] != 1) {
                    throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows[i]) {
                    };
                }
            }
        }
    }

    public ArrayList<String> getOldScanIds() {

        ArrayList<String> scanIds = new ArrayList<>();
        String sql = "SELECT report_id FROM scan";
        scanIds = jdbcTemplate.query(sql, new ScanIdResultExtractor());

        return scanIds;

    }

    public PentestScanner getScannerById(String id, String serverId) {
        Map params = new HashMap();
        String sql = "SELECT * "
                + "FROM pentest_scanner "
                + "WHERE id = :id "
                + "AND server_id= :serverId ";
        params.put("id", id);
        params.put("serverId", serverId);
        List<PentestScanner> result = jdbcTemplate.query(sql, params, new PentestScannerResultSetExtractor(false));

        if (result.isEmpty()) {
            return null;
        } else {
            return result.get(0);
        }
    }

    
    public PentestPolicy getPolicyById(String id, String serverId) {
        Map params = new HashMap();
        String sql = "SELECT * "
                + "FROM pentest_policy "
                + "WHERE id = :id "
                + "AND server_id= :serverId ";
        params.put("id", id);
        params.put("serverId", serverId);
        List<PentestPolicy> result = jdbcTemplate.query(sql, params, new PentestPolicyResultSetExtractor(false));

        if (result.isEmpty()) {
            return null;
        } else {
            return result.get(0);
        }
    }
    
    public List<PentestPolicy> getPolicyListByServerId(String serverId) {
        Map params = new HashMap();
        String sql = "SELECT * "
                + "FROM pentest_policy "
                + "WHERE server_id= :serverId ";
        params.put("serverId", serverId);
        List<PentestPolicy> result = jdbcTemplate.query(sql, params, new PentestPolicyResultSetExtractor(false));
        return result;
    }
    
    public boolean updatePolicyNameById(String id, String policyName) {
        
        Map params = new HashMap();
        params.put("policyName", policyName);
        params.put("id", id);

        String sql = "UPDATE pentest_policy SET name = :policyName "
                + "where id= :id ";

        int rows = jdbcTemplate.update(sql, params);
        
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
        
        return true;
    }
    /**
     * Scheduled taramalarda id ve reference bilgisi API istei iletildikten
     * sonra kaydedilir.
     *
     * @param scan
     * @param newScanId
     */
    public void updateScanInfo(PentestScan scan, String newScanId) {
        String sql = "UPDATE scan "
                + "SET scan_id= :newScanId, status= :status, is_scheduled= :scheduled "
                + "WHERE scan_id= :scanId ";

        Map params = new HashMap();
        params.put("scanId", scan.getScanId());
        params.put("status", scan.getStatus().toString());
        params.put("newScanId", newScanId);
        params.put("scheduled", false);
        int rows = jdbcTemplate.update(sql, params);
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
    }

    public void updateScanName(String name, String scanId) {
        String sql = "UPDATE scan "
                + "SET name= :name "
                + "WHERE scan_id= :scanId ";

        Map params = new HashMap();
        params.put("scanId", scanId);
        params.put("name", name);
        int rows = jdbcTemplate.update(sql, params);
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
    }

    //Zafiyetlerin aktifliini gnceller.
    public List<ScanVulnerability> updateVulnerabilitiesActiveness(List<ScanVulnerability> svList, boolean active) {
        String sql = "UPDATE scan_vulnerability "
                + "SET active= :active "
                + "WHERE scan_vulnerability_id= :svId ";

        Map[] paramsArr = new Map[svList.size()];

        int index = 0;
        for (ScanVulnerability sv : svList) {
            sv.setActive(active);
            Map param = new HashMap();
            param.put("active", sv.isActive());
            param.put("svId", sv.getScanVulnerabilityId());
            paramsArr[index] = param;

            index++;
        }

        jdbcTemplate.batchUpdate(sql, paramsArr);
        return svList;
    }

    /**
     * Tarama kopyalama ileminde bu metod kullanlr.
     *
     * @param scan
     * @throws Exception
     */
    @Transactional
    public List<String> saveCopyScanResults(PentestScan scan) throws Exception {
        List<String> scanVulIdList = new ArrayList<>();
        User user = HttpUtil.getUser();
        // Tarama tarihini zafiyet tarihi olarak veriyoruz hangi taramadan geldiini belirlemek iin.
        Date createDate = scan.getScanDate();

        for (ScanAsset asset : scan.getScanAssets()) {
            String scanAssetId = asset.getScanAssetId();
            String assetId = getAssetIdByScanAsset(scanAssetId);

            for (ScanVulnerability sv : asset.getScanVulnerabilityList()) {
                Vulnerability vuln = sv.getVulnerability();
                String portId = "";

                String vulnId = "";
                if (!BizzyUtil.isEmpty(vuln.getVulnNumber())) { //Zafiyet no'su varsa gidip kontrol et.
                    vulnId = isVulnerabilitySaved(vuln.getVulnNumber(), Source.valueOf(sv.getSource().toString()));
                }

                Port port = vuln.getPort();
                if (port != null) {
                    if (port.getPortNumber() == null) {
                        portId = null;
                    } else {
                        portId = isPortSaved(port.getPortNumber(), port.getProtocol(), assetId);
                    }
                }

                // Kaytl deil ise zafiyeti kaydeder. Burada otomatik aratan gelen zafiyetler kontrol ediliyor.
                if (BizzyUtil.isEmpty(vulnId)) {
                    vulnId = BizzyUtil.generateGUID();
                    vuln.setVulnerabilityId(vulnId);
                    vuln.setCreateDate(createDate);
                    vuln.setCreatedBy(user.getUsername());//Kopyalama yapan kullanc
                    if (vuln.getCvssTemporalScore() == null) {
                        vuln.setCvssTemporalScore(vuln.getCvssBaseScore());
                    }
                    vulnerabilityDao.saveVulnerability(vuln);
                }

                ScanVulnerability scanVulnerability = new ScanVulnerability();
                scanVulnerability.setVulnerabilityId(vulnId);
                scanVulnerability.setScanAssetId(scanAssetId);
                scanVulnerability.setResult(sv.getResult());
                scanVulnerability.setSourceValue(sv.getSource().toString());
                scanVulnerability.setCreateDate(sv.getCreateDate());
                scanVulnerability.setCreatedBy(sv.getCreatedBy());
                scanVulnerability.setUpdatedBy(user.getUsername());
                scanVulnerability.setPortId(portId);
                scanVulnerability.setPluginLevel(sv.getPluginLevel());
                scanVulnerability.setHasRootPrivilege(sv.isHasRootPrivilege());
                scanVulnerability.setLikelihood(sv.getLikelihood());
                scanVulnerability.setSocialImpact(sv.getSocialImpact());
                String scanVulId = vulnerabilityDao.saveScanVulnerability(scanVulnerability);
                scanVulIdList.add(scanVulId);
            }
        }

        return scanVulIdList;
    }

    public int getAssetVulnerabilitiesCount(ScanResultsFilter filter) {
        Map params = new HashMap();
        String sql = "SELECT count(DISTINCT sv.vulnerability_id) as count "
                + "FROM scan_vulnerability sv "
                + "	LEFT JOIN vulnerability v "
                + "         ON sv.vulnerability_id = v.vulnerability_id "
                + "	LEFT JOIN vulnerability_category vc "
                + "         ON vc.vulnerability_category_id = v.vulnerability_category_id "
                + "	LEFT JOIN scan_asset asset "
                + "         ON sv.scan_asset_id = asset.scan_asset_id "
                + "     LEFT JOIN virtual_host vh "
                + "         ON sv.host_id = vh.host_id "
                + "     LEFT JOIN port p "
                + "         ON sv.port_id = p.port_id "
                + "     LEFT JOIN asset a "
                + "         ON asset.asset_id = a.asset_id "
                + "     LEFT JOIN vulnerability_label_relations vlr "
                + "          ON vlr.scan_vulnerability_id = sv.scan_vulnerability_id ";
        if (filter.getLabels() != null && filter.getLabels().length > 0) {
            if (filter.getLabelsChecked() == null) {
                for (int i = 1; i <= filter.getLabels().length - 1; i++) {
                    sql += "    LEFT JOIN vulnerability_label_relations vlr" + i
                            + "             ON vlr" + i + ".scan_vulnerability_id = sv.scan_vulnerability_id ";
                }
            }
        }
        sql += "        LEFT JOIN ticket_link tl   ON sv.scan_vulnerability_id = tl.link_value "
                + "     LEFT JOIN ticket t         ON tl.ticket_id = t.ticket_id "
                + "     LEFT JOIN ticket_status ts ON t.status_id = ts.ticket_status_id"
                + " WHERE ";
        sql += makeFilterSQL(filter);
        params = makeFilterMap(filter);
        Integer count = jdbcTemplate.queryForObject(sql, params, Integer.class);
        return count;
    }

    public int getScanResultCount(ScanResultsFilter filter) {
        Map params = new HashMap();
        String sql = "SELECT count ( ";
        if (filter.getLabels() != null && filter.getLabels().length > 0) {
            sql += " DISTINCT ";
        }
        sql += " sv.scan_vulnerability_id) as count "
                + "FROM scan_vulnerability sv "
                + "	LEFT JOIN vulnerability v "
                + "         ON sv.vulnerability_id = v.vulnerability_id "
                + "	LEFT JOIN vulnerability_category vc "
                + "         ON vc.vulnerability_category_id = v.vulnerability_category_id "
                + "	LEFT JOIN scan_asset asset "
                + "         ON sv.scan_asset_id = asset.scan_asset_id "
                + "     LEFT JOIN virtual_host vh "
                + "         ON sv.host_id = vh.host_id "
                + "     LEFT JOIN port p "
                + "         ON sv.port_id = p.port_id "
                + "     LEFT JOIN asset a "
                + "         ON asset.asset_id = a.asset_id ";
        if (filter.getLabels() != null && filter.getLabels().length > 0) {
            sql += "     LEFT JOIN vulnerability_label_relations vlr "
                    + "          ON vlr.scan_vulnerability_id = sv.scan_vulnerability_id ";
        }
        if (filter.getLabels() != null && filter.getLabels().length > 0) {
            if (filter.getLabelsChecked() == null) {
                for (int i = 1; i <= filter.getLabels().length - 1; i++) {
                    sql += "    LEFT JOIN vulnerability_label_relations vlr" + i
                            + "             ON vlr" + i + ".scan_vulnerability_id = sv.scan_vulnerability_id ";
                }
            }
        }
        sql += "        LEFT JOIN ticket_link tl   ON sv.scan_vulnerability_id = tl.link_value "
                + "     LEFT JOIN ticket t         ON tl.ticket_id = t.ticket_id "
                + "     LEFT JOIN ticket_status ts ON t.status_id = ts.ticket_status_id"
                + " WHERE ";
        sql += makeFilterSQL(filter);
        params = makeFilterMap(filter);
        Integer count = jdbcTemplate.queryForObject(sql, params, Integer.class);
        return count;
    }
    
    public int getVulnerabilityCountForScan(String scanId) {
        Map params = new HashMap();
        String sql = "SELECT count(sv.scan_vulnerability_id) as count "
                + "FROM scan_vulnerability sv "
                + "	LEFT JOIN scan_asset asset "
                + "         ON sv.scan_asset_id = asset.scan_asset_id "
                + "WHERE asset.scan_id = :scanId";
        params.put("scanId", scanId);
        Integer count = jdbcTemplate.queryForObject(sql, params, Integer.class);
        return count;
    }

    public List<ScanAsset> getScanAssets(DataTablesRequest dataTablesRequest, String scanId) {
        Map params = new HashMap();
        String sql = "SELECT asset.*, a.hostname host, a.operating_system as os, a.ip, a.ip_decimal, a.type, a.other_ips, COUNT(v.*) count "
                + "FROM scan_asset asset "
                + "LEFT JOIN scan_vulnerability sv "
                + "     ON asset.scan_asset_id = sv.scan_asset_id "
                + "LEFT JOIN vulnerability v "
                + "     ON sv.vulnerability_id = v.vulnerability_id "
                + "LEFT JOIN asset a "
                + "     ON asset.asset_id = a.asset_id "
                + "WHERE asset.scan_id= :scanId "
                + "AND a.deleted = false "
                + "group by asset.scan_asset_id, a.hostname, a.operating_system, a.ip, a.ip_decimal, a.type, a.other_ips "
                + createOrderBy(ScanAssetDiscoveryResultColumnNameMapper, dataTablesRequest)
                + createLimit(dataTablesRequest, params);
        params.put("scanId", scanId);
        return jdbcTemplate.query(sql, params, new ScanAssetResultSetExtractor(false));
    }

    public int getMaxVulnCountByScanAssets(String scanId) {
        Map params = new HashMap();
        String sql = "SELECT MAX(t1.count) FROM ( "
                + "SELECT asset.*, a.hostname host, a.operating_system as os, a.ip, COUNT(v.*) count "
                + "FROM scan_asset asset "
                + "LEFT JOIN scan_vulnerability sv "
                + "     ON asset.scan_asset_id = sv.scan_asset_id "
                + "LEFT JOIN vulnerability v "
                + "     ON sv.vulnerability_id = v.vulnerability_id "
                + "LEFT JOIN asset a "
                + "     ON asset.asset_id = a.asset_id "
                + "WHERE asset.scan_id= :scanId "
                + "AND a.deleted = false "
                + "group by asset.scan_asset_id, a.hostname, a.operating_system, a.ip ) t1";
        params.put("scanId", scanId);
        Integer count = jdbcTemplate.queryForObject(sql, params, Integer.class);

        return count;
    }

    public List<ScanAsset> getRiskDistributionOfScanAssets(List<ScanAsset> scanAssets, int maxVulnCount) {
        Map<Integer, Integer> risks = new HashMap<>();
        String sql = "SELECT v.risk_level, count(v.risk_level) "
                + "FROM vulnerability v "
                + "LEFT JOIN scan_vulnerability sv "
                + "ON sv.vulnerability_id = v.vulnerability_id "
                + "LEFT JOIN scan_asset asset "
                + "ON asset.scan_asset_id = sv.scan_asset_id "
                + "WHERE asset.asset_id= :assetId "
                + "AND asset.scan_id= :scanId "
                + "GROUP BY v.risk_level";

        for (ScanAsset asset : scanAssets) {
            Map params = new HashMap();
            params.put("assetId", asset.getAssetId());
            params.put("scanId", asset.getScanId());
            risks = jdbcTemplate.query(sql, params, new RiskDistributionResultSetExtractor(false));
            asset.setRiskDistribution(risks);
            asset.setMaxVulnCount(maxVulnCount);
        }
        return scanAssets;
    }

    public int getAssetDiscoveryResultCount(String scanId,String lastScanId, AssetFilter filter) {
        Map params = new HashMap();
        String sql = "";
        if(filter != null && filter.getPortNumber() != null && filter.getPortNumber().length > 0) {
                sql += "SELECT count(DISTINCT pasr.id) as count ";
        } else {
                sql += "SELECT count(pasr.id) as count ";
        }
                sql += "FROM passive_asset_scan_result pasr "
                + "LEFT JOIN passive_asset_scan_result last_scan_asset " 
                + "ON last_scan_asset.scan_id = :lastScanId AND pasr.ip = last_scan_asset.ip ";
        if(filter != null && filter.getPortNumber() != null && filter.getPortNumber().length > 0) {
                sql += "LEFT JOIN passive_asset_scan_port_result paspr ON paspr.result_id = pasr.id ";
        }
                sql += "WHERE pasr.scan_id= :scanId ";
        if(filter != null) {
            if (filter.getAssetValue() != null && !BizzyUtil.isEmpty(filter.getAssetValue())) {
                sql += " AND pasr.ip ILIKE :asset ";
                params.put("asset", "%" + filter.getAssetValue() + "%");
            }
            if (filter.getOsName() != null && !BizzyUtil.isEmpty(filter.getOsName())) {
                sql += " AND pasr.operating_system ILIKE :os ";
                params.put("os", "%" + filter.getOsName() + "%");
            }
            
            if(filter.getNewAsset()!= null && filter.getNewAsset()== true) {
                if (BizzyUtil.isEmpty(lastScanId)) {
                    sql += " AND last_scan_asset.id = :lastScanId ";
                } else {
                    sql += " AND last_scan_asset.id IS NULL ";
                }
            }
            int[] ports = filter.getPortNumber();
            if (ports != null && ports.length > 0) {
                sql += "AND ( paspr.port_number = :port[" + 0 + "] ";
                for (int i = 1; i <= ports.length - 1; i++) {
                    sql += "OR paspr.port_number = :port[" + i + "] ";
                    params.put("port[" + i + "]", ports[i]);
                }

                sql += " ) ";
                params.put("port[0]", ports[0]);
            }
        }
        params.put("scanId", scanId);
        params.put("lastScanId", lastScanId);
        Integer count = jdbcTemplate.queryForObject(sql, params, Integer.class);
        return count;
    }

    public void deleteAssetDiscovery(String scanId) {
        String sql = "DELETE FROM passive_asset_scan "
                + "WHERE id= :scanId ";
        Map params = new HashMap();
        params.put("scanId", scanId);
        int rows = jdbcTemplate.update(sql, params);
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
    }

    public void deleteScheduledAssetDiscovery(String scanId) {
        String sql = "DELETE FROM scheduled_passive_asset_scan "
                + "WHERE id= :scanId ";
        Map params = new HashMap();
        params.put("scanId", scanId);
        int rows = jdbcTemplate.update(sql, params);
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
    }

    public void archiveScan(String scanId) {
        Map params = new HashMap();
        params.put("scanId", scanId);
        String sql = "UPDATE scan SET archived = true WHERE scan_id=:scanId ";
        jdbcTemplate.update(sql, params);
    }

    public void unarchiveScan(String scanId) {
        Map params = new HashMap();
        params.put("scanId", scanId);
        String sql = "UPDATE scan SET archived = false WHERE scan_id=:scanId ";
        jdbcTemplate.update(sql, params);
    }

    public List<AssetDiscoveryResult> getAssetDiscoveryResults(DataTablesRequest dataTablesRequest, String scanId) {
        Map params = new HashMap();
        String sql = "SELECT pasr.*, paspr.port_id AS portId, paspr.port_number AS portNumber, paspr.protocol, paspr.banner, paspr.service "
                + "FROM passive_asset_scan_result pasr "
                + "LEFT JOIN passive_asset_scan_port_result paspr ON paspr.result_id = pasr.id "
                + "WHERE pasr.id IN ("
                + "SELECT pasr.id FROM passive_asset_scan_result pasr where pasr.scan_id= :scanId "
                + createOrderBy(AssetDiscoveryResultColumnNameMapper, dataTablesRequest)
                + createLimit(dataTablesRequest, params)
                + ") "
                + createOrderBy(AssetDiscoveryResultColumnNameMapper, dataTablesRequest);

        params.put("scanId", scanId);

        return jdbcTemplate.query(sql, params, new AssetDiscoveryResultListResultSetExtractor(false));
    }

    public List<AssetDiscoveryResult> getAssetDiscoveryResultsFiltered(AssetFilter filter, DataTablesRequest dataTablesRequest, String scanId, String lastScanId, boolean limit) {
        Map params = new HashMap();
        String sql = "SELECT DISTINCT pasr.*, paspr.port_id AS portId, paspr.port_number AS portNumber, paspr.protocol, paspr.banner, paspr.service, "
                + " CASE WHEN (:lastScanId)::TEXT IS NULL THEN null "
                + " ELSE (CASE WHEN innerTable.last_scan_ip IS NULL THEN true ELSE false END) END AS new_host, "
                + " CASE WHEN (:lastScanId)::TEXT IS NULL THEN null "
                + " ELSE (CASE WHEN last_scan_port.port_number IS NULL THEN true ELSE false END) END AS new_port "
                + " FROM passive_asset_scan_result pasr "
                + " INNER JOIN "
                + " ( "
                + "SELECT pasr.id, last_scan_asset.id AS last_scan_id, last_scan_asset.ip AS last_scan_ip "
                + "FROM passive_asset_scan_result pasr "
                + "LEFT JOIN passive_asset_scan_result last_scan_asset " 
                + "ON last_scan_asset.scan_id = :lastScanId AND pasr.ip = last_scan_asset.ip "
                + "LEFT JOIN passive_asset_scan_port_result paspr ON paspr.result_id = pasr.id "
                + "WHERE 1=1 ";
        if (filter.getAssetValue() != null && !BizzyUtil.isEmpty(filter.getAssetValue())) {
            sql += " AND pasr.ip ILIKE :asset ";
            params.put("asset", "%" + filter.getAssetValue() + "%");
        }
        if (filter.getOsName() != null && !BizzyUtil.isEmpty(filter.getOsName())) {
            sql += " AND pasr.operating_system ILIKE :os ";
            params.put("os", "%" + filter.getOsName() + "%");
        }
        if (filter.getNewAsset() != null && filter.getNewAsset()== true) {
            if (BizzyUtil.isEmpty(lastScanId)) {
                sql += " AND last_scan_asset.id = :lastScanId ";
            } else {
                sql += " AND last_scan_asset.id IS NULL ";
            }
        }
        int[] ports = filter.getPortNumber();
        if (ports != null && ports.length > 0) {
            sql += "AND ( paspr.port_number = :port[" + 0 + "] ";
            for (int i = 1; i <= ports.length - 1; i++) {
                sql += "OR paspr.port_number = :port[" + i + "] ";
                params.put("port[" + i + "]", ports[i]);
            }

            sql += " ) ";
            params.put("port[0]", ports[0]);
        }
        sql += " AND pasr.id IN ("
                + "SELECT pasr.id FROM passive_asset_scan_result pasr where pasr.scan_id= :scanId ";
        if(dataTablesRequest != null) {
            sql += createOrderBy(AssetDiscoveryResultColumnNameMapper, dataTablesRequest);
            if(limit) {
            sql += createLimit(dataTablesRequest, params);
            }
        }
            sql += ") ";
        if(dataTablesRequest != null) {    
            sql += createOrderBy(AssetDiscoveryResultColumnNameMapper, dataTablesRequest);
        }            
            sql += " ) innerTable ON innerTable.id = pasr.id "
                + "LEFT JOIN passive_asset_scan_port_result paspr ON paspr.result_id = pasr.id "
                + "LEFT JOIN passive_asset_scan_port_result last_scan_port " 
                + "ON last_scan_port.result_id = innerTable.last_scan_id AND paspr.port_number = last_scan_port.port_number "
                + "WHERE 1=1 ";
        sql += " AND pasr.id IN ("
                + "SELECT pasr.id FROM passive_asset_scan_result pasr where pasr.scan_id= :scanId ";
        if(dataTablesRequest != null) {
            sql += createOrderBy(AssetDiscoveryResultColumnNameMapper, dataTablesRequest);
            if(limit) {
            sql += createLimit(dataTablesRequest, params);
            }
        }
            sql += ") ";
        if(dataTablesRequest != null) {    
            sql += createOrderBy(AssetDiscoveryResultColumnNameMapper, dataTablesRequest);
        } 

        params.put("scanId", scanId);
        params.put("lastScanId", lastScanId);

        return jdbcTemplate.query(sql, params, new AssetDiscoveryResultListResultSetExtractor(false));
    }

    public AssetDiscoveryResult getAssetDiscoveryResult(String id) {
        Map params = new HashMap();
        String sql = "SELECT pasr.*, paspr.port_id AS portId, paspr.port_number AS portNumber, paspr.protocol, paspr.banner, paspr.service "
                + "FROM passive_asset_scan_result pasr "
                + "LEFT JOIN passive_asset_scan_port_result paspr ON paspr.result_id = pasr.id "
                + "WHERE id= :id ";
        params.put("id", id);
        List<AssetDiscoveryResult> result = jdbcTemplate.query(sql, params, new AssetDiscoveryResultListResultSetExtractor(false));
        if (result.isEmpty()) {
            return null;
        } else {
            return result.get(0);
        }
    }

    public AssetDiscovery getAssetDiscoveryById(String scanId, String customerId) {
        Map params = new HashMap();

        String sql = "SELECT * , a.domain , last_scan.id AS last_scan_id "
                + "FROM passive_asset_scan s "
                + "LEFT JOIN server a ON a.setting_id = s.server_id "
                + "LEFT JOIN LATERAL ( " 
                + "SELECT id, scheduled_passive_asset_scan_id " 
                + "FROM passive_asset_scan " 
                + "WHERE scheduled_passive_asset_scan_id= s.scheduled_passive_asset_scan_id " 
                + "AND id != s.id AND status= 'COMPLETED' " 
                + "AND completion_date < s.scan_date " 
                + "ORDER BY scan_date DESC LIMIT 1 " 
                + ") last_scan ON s.scheduled_passive_asset_scan_id = last_scan.scheduled_passive_asset_scan_id "
                + "WHERE s.id= :scanId ";

        if (!BizzyUtil.isEmpty(customerId)) {
            sql += "AND s.customer_id= :customerId ";
            params.put("customerId", customerId);
        }
        params.put("scanId", scanId);

        List<AssetDiscovery> result = jdbcTemplate.query(sql, params, new HostScanResultSetExtractor(false));
        if (result.isEmpty()) {
            return null;
        } else {
            return result.get(0);
        }
    }
    
     public AssetDiscovery getPassiveAssetScanById(String scanId, String customerId) {
        Map params = new HashMap();

        String sql = "SELECT * , a.domain "
                + "FROM passive_asset_scan s "
                + "LEFT JOIN server a ON a.setting_id = s.server_id "
                + "WHERE s.id= :scanId ";

        if (!BizzyUtil.isEmpty(customerId)) {
            sql += "AND s.customer_id= :customerId ";
            params.put("customerId", customerId);
        }
        params.put("scanId", scanId);

        List<AssetDiscovery> result = jdbcTemplate.query(sql, params, new HostScanResultSetPassiveAssetScanExtractor(false));
        if (result.isEmpty()) {
            return null;
        } else {
            return result.get(0);
        }
    }

    public AssetDiscovery getLastHostScanByScheduledHostScanId(String scheduledHostScanId, AssetDiscovery scan) {
        String sql = "SELECT * , a.domain "
                + "FROM passive_asset_scan s "
                + "LEFT JOIN server a ON a.setting_id = s.server_id "
                + "WHERE s.scheduled_passive_asset_scan_id= :scheduledHostScanId "
                + "AND s.id != :scanId AND s.status= :status AND s.completion_date < :scanDate "
                + "ORDER BY s.scan_date DESC LIMIT 1";
        Map params = new HashMap();
        params.put("scheduledHostScanId", scheduledHostScanId);
        params.put("scanId", scan.getId());
        params.put("scanDate", scan.getScanDate());
        params.put("status", ScanStatus.COMPLETED.toString());
        List<AssetDiscovery> result = jdbcTemplate.query(sql, params, new HostScanResultSetExtractor(false));
        if (result.isEmpty()) {
            return null;
        } else {
            return result.get(0);
        }
    }

    public ScheduledAssetDiscovery getScheduledAssetDiscoveryById(String scanId, String customerId) {

        String sql = "SELECT * "
                + "FROM scheduled_passive_asset_scan "
                + "WHERE customer_id= :customerId AND id= :scanId ";
        Map params = new HashMap();
        params.put("scanId", scanId);
        params.put("customerId", customerId);
        List<ScheduledAssetDiscovery> result = jdbcTemplate.query(sql, params, new ScheduledHostScanResultSetExtractor(false));
        if (result.isEmpty()) {
            return null;
        } else {
            return result.get(0);
        }
    }

    public void updateScheduledAssetDiscoveryById(String scanId, String customerId, Integer count) {

        String sql = "UPDATE scheduled_passive_asset_scan "
                + "SET completed_scan_count= :count "
                + "WHERE customer_id= :customerId AND id= :scanId ";

        Map params = new HashMap();
        params.put("scanId", scanId);
        params.put("customerId", customerId);
        params.put("count", count);
        int rows = jdbcTemplate.update(sql, params);
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
    }
// heree

    public List<ScanVulnerability> getScanResults(DataTablesRequest dataTablesRequest, ScanResultsFilter filter) {
        Map params = new HashMap();
        String sql = "SELECT v.*, sv.status as svStatus, a.ip as ip, a.ip_decimal as decimal, "
                + "p.port_number as portNumber, p.protocol as protocol, vc.name as categoryName, sv.source as svSource, "
                + "sv.scan_vulnerability_id, vlr.label as label_name, sv.active, vh.name as host_name, svd.* "
                + "FROM scan_vulnerability sv "
                + "	LEFT JOIN vulnerability v "
                + "         ON sv.vulnerability_id = v.vulnerability_id "
                + "	LEFT JOIN vulnerability_category vc "
                + "         ON vc.vulnerability_category_id = v.vulnerability_category_id "
                + "	LEFT JOIN scan_asset asset "
                + "         ON sv.scan_asset_id = asset.scan_asset_id "
                + "     LEFT JOIN virtual_host vh "
                + "         ON sv.host_id = vh.host_id "
                + "     LEFT JOIN port p "
                + "         ON sv.port_id = p.port_id "
                + "     LEFT JOIN asset a "
                + "         ON asset.asset_id = a.asset_id "
                + "     LEFT JOIN vulnerability_label_relations vlr "
                + "         ON vlr.scan_vulnerability_id = sv.scan_vulnerability_id "
                + "     LEFT JOIN ticket_link tl   ON sv.scan_vulnerability_id = tl.link_value     "
                + "     LEFT JOIN ticket t         ON tl.ticket_id = t.ticket_id     "
                + "     LEFT JOIN ticket_status ts ON t.status_id = ts.ticket_status_id "
                + "     LEFT JOIN scan_vulnerability_details svd"
                + "         ON sv.scan_vulnerability_id = svd.scan_vulnerability_id "
                + "		INNER JOIN ( "
                + "					SELECT ";
        if (filter.getLabels() != null && filter.getLabels().length > 0) {  //Bu maliyetli bir sorgu, sadece labelde onetomany var o yzden bunu filtreye gre distinct yaptk.
            sql += "DISTINCT ";
        }
        sql += "sv.scan_vulnerability_id, a.ip, a.ip_decimal, v.risk_level, v.name, kbc.name, sv.create_date, sv.source, p.port_number, p.protocol, vh.name, svd.path, svd.line_number  "
                + "					FROM scan_vulnerability sv "
                + "						LEFT JOIN vulnerability v  "
                + "							ON sv.vulnerability_id = v.vulnerability_id ";
        if (filter.getLabels() != null && filter.getLabels().length > 0) {
            sql += "						LEFT JOIN vulnerability_label_relations vlr "
                    + "							ON vlr.scan_vulnerability_id = sv.scan_vulnerability_id ";
            if (filter.getLabelsChecked() == null) {
                for (int i = 1; i <= filter.getLabels().length - 1; i++) {
                    sql += "                                    LEFT JOIN vulnerability_label_relations vlr" + i
                            + "                                                 ON vlr" + i + ".scan_vulnerability_id = sv.scan_vulnerability_id ";
                }
            }
        }
        sql += "                                                LEFT JOIN ticket_link tl   ON sv.scan_vulnerability_id = tl.link_value     "
                + "                                             LEFT JOIN ticket t         ON tl.ticket_id = t.ticket_id     "
                + "                                             LEFT JOIN ticket_status ts ON t.status_id = ts.ticket_status_id "
                + "						LEFT JOIN scan_asset asset "
                + "							ON sv.scan_asset_id = asset.scan_asset_id "
                + "						LEFT JOIN asset a "
                + "							ON asset.asset_id = a.asset_id "
                + "						LEFT JOIN port p "
                + "							ON sv.port_id = p.port_id "
                + "                                             LEFT JOIN virtual_host vh "
                + "                                                 ON sv.host_id = vh.host_id "
                + "                                             LEFT JOIN knowledge_base kb "
                + "                                                     ON v.kb_id = kb.id "
                + "                                             LEFT JOIN knowledge_base_category kbc "
                + "                                                     ON kb.category_id = kbc.id "
                + "                                             LEFT JOIN scan_vulnerability_details svd "
                + "                                                     ON sv.scan_vulnerability_id = svd.scan_vulnerability_id "
                + "WHERE ";

        sql += makeFilterSQL(filter);
        sql += createOrderBy(scanResultColumnNameMapper, dataTablesRequest);
        sql += createLimit(dataTablesRequest, params);
        sql += "		) ij	ON ij.scan_vulnerability_id=sv.scan_vulnerability_id  ";

        params.putAll(makeFilterMap(filter));
        sql += createOrderBy(scanResultColumnNameMapper, dataTablesRequest);
// sql
        return jdbcTemplate.query(sql, params, new ScanResultListResultSetExtractor(false));
    }
    
    public List<AssetVulnerability> getAssetVulnerabilities(DataTablesRequest dataTablesRequest, ScanResultsFilter filter) {
        Map params = new HashMap();
        String sql = "SELECT v.vulnerability_id, v.name, v.risk_level, v.effect, v.root_cause, v.problem_area, "
                + "sv.source as svSource,"
                + "sv.scan_vulnerability_id, sv.active, vlr.label as label_name, vh.name as host_name  "
                + "FROM scan_vulnerability sv "
                + "	LEFT JOIN vulnerability v "
                + "         ON sv.vulnerability_id = v.vulnerability_id "
                + "	LEFT JOIN scan_asset asset "
                + "         ON sv.scan_asset_id = asset.scan_asset_id "
                + "     LEFT JOIN asset a "
                + "         ON asset.asset_id = a.asset_id "
                + "     LEFT JOIN virtual_host vh "
                + "         ON sv.host_id = vh.host_id "
                + "     LEFT JOIN vulnerability_label_relations vlr "
                + "          ON vlr.scan_vulnerability_id = sv.scan_vulnerability_id "
                + "		INNER JOIN ( "
                + "					SELECT DISTINCT sv.scan_vulnerability_id, a.ip, v.risk_level, v.name, sv.create_date, sv.source, p.port_number, p.protocol  "
                + "					FROM scan_vulnerability sv "
                + "						LEFT JOIN vulnerability v  "
                + "							ON sv.vulnerability_id = v.vulnerability_id "
                + "						LEFT JOIN vulnerability_label_relations vlr "
                + "							ON vlr.scan_vulnerability_id = sv.scan_vulnerability_id ";
        if (filter.getLabels() != null && filter.getLabels().length > 0) {
            if (filter.getLabelsChecked() == null) {
                for (int i = 1; i <= filter.getLabels().length - 1; i++) {
                    sql += "                                    LEFT JOIN vulnerability_label_relations vlr" + i
                            + "                                                 ON vlr" + i + ".scan_vulnerability_id = sv.scan_vulnerability_id ";
                }
            }
        }
          sql += "           LEFT JOIN ticket_link tl ON sv.scan_vulnerability_id = tl.link_value"
                + "          LEFT JOIN ticket t ON t.ticket_id = tl.ticket_id "
                + "          LEFT JOIN ticket_status ts ON ts.ticket_status_id = t.status_id "
                + "						LEFT JOIN scan_asset asset "
                + "							ON sv.scan_asset_id = asset.scan_asset_id "
                + "						LEFT JOIN asset a "
                + "							ON asset.asset_id = a.asset_id "
                + "						LEFT JOIN port p "
                + "							ON sv.port_id = p.port_id "
                + "						LEFT JOIN asset_group_relations agr "
                + "							ON agr.asset_id=a.asset_id "
                + "						LEFT JOIN asset_group ag "
                + "							ON ag.group_id = agr.group_id "
                + "                                             LEFT JOIN virtual_host vh "
                + "                                                     ON sv.host_id = vh.host_id "
                + "WHERE ";

        sql += makeFilterSQL(filter);
        sql += createOrderBy(assetVulnerabilityColumnNameMapper, dataTablesRequest);
        sql += "		) ij	ON ij.scan_vulnerability_id=sv.scan_vulnerability_id  ";

        params.putAll(makeFilterMap(filter));
        sql += createOrderBy(assetVulnerabilityColumnNameMapper, dataTablesRequest);
// sql
        List<AssetVulnerability> assetVulnerabilities = jdbcTemplate.query(sql, params, new AssetVulnerabilityListResultSetExtractor(false));

        assetVulnerabilities = createOrderForVulnerabilityCount(assetVulnerabilities, dataTablesRequest);

        return createLimitForAssetVulnerabilities(assetVulnerabilities, dataTablesRequest);
    }
   
    protected List<AssetVulnerability> createOrderForVulnerabilityCount(List<AssetVulnerability> assetVulnerabilities, DataTablesRequest dataTablesRequest) {
        if (dataTablesRequest != null) {
            List<Order> orders = dataTablesRequest.getOrders();
            List<Column> columns = dataTablesRequest.getColumns();
            for (Order order : orders) {
                Integer index = order.getColumn();
                Column column = columns.get(index);
                if (column.getData().equals("vulnerabilityCount")) {
                    if (!column.isOrderable()) {
                        continue;
                    }
                    if (order.getDir().toUpperCase(Locale.ENGLISH).equals("ASC")) {
                        Collections.sort(assetVulnerabilities, new Comparator<AssetVulnerability>() {
                            @Override
                            public int compare(AssetVulnerability a1, AssetVulnerability a2) {
                                if (a1.getVulnerabilityCount() > a2.getVulnerabilityCount()) {
                                    return -1;
                                } else if (a1.getVulnerabilityCount() < a2.getVulnerabilityCount()) {
                                    return 1;
                                } else {
                                    return 0;
                                }
                            }
                        });
                    } else {
                        Collections.sort(assetVulnerabilities, new Comparator<AssetVulnerability>() {
                            @Override
                            public int compare(AssetVulnerability a1, AssetVulnerability a2) {
                                if (a1.getVulnerabilityCount() < a2.getVulnerabilityCount()) {
                                    return -1;
                                } else if (a1.getVulnerabilityCount() > a2.getVulnerabilityCount()) {
                                    return 1;
                                } else {
                                    return 0;
                                }
                            }
                        });
                    }

                }
            }
        }
        return assetVulnerabilities;
    }

    protected List<AssetVulnerability> createLimitForAssetVulnerabilities(List<AssetVulnerability> assetVulnerabilities, DataTablesRequest dataTablesRequest) {
        if (dataTablesRequest != null) {
            List<AssetVulnerability> limitedAssetVulnerabilities = new LinkedList<>();
            int start = dataTablesRequest.getStart();
            int count;
            if (dataTablesRequest.getLength() > 250) {
                count = 250;
            } else {
                count = dataTablesRequest.getLength();
            }
            for (int i = start; i < start + count; i++) {
                if (i < assetVulnerabilities.size()) {
                    limitedAssetVulnerabilities.add(assetVulnerabilities.get(i));
                }
            }
            return limitedAssetVulnerabilities;
        }
        return assetVulnerabilities;
    }

    /**
     * Scan result uygulanacak olan filterin map tarafnn olusturulmasi
     *
     * @param filter doldurulmus olan filtre
     * @return map
     */
    private Map makeFilterMap(ScanResultsFilter filter) {
        Map params = new HashMap();

        if (filter.getScanId() != null && !filter.getScanId().equals("")) {
            params.put("scan_id", filter.getScanId());
        }
        if (filter.getAssetId() != null && !filter.getAssetId().equals("")) {
            params.put("asset_id", filter.getAssetId());
        }
        if (filter.getIpAddress() != null && !filter.getIpAddress().equals("")) {
            params.put("ip", "%" + filter.getIpAddress() + "%");
        }
        if (!BizzyUtil.isEmpty(filter.getFqdn())) {
            params.put("hostname", "%" + filter.getFqdn() + "%");
        }
        if (filter.getActive() != null && !filter.getActive().equals("")) {
            params.put("active", "%" + filter.getActive() + "%");
        }
        if (filter.getPort() != null && !filter.getPort().equals("")) {
            params.put("port_number", filter.getPort());
        }
        if (filter.getVirtualHost() != null && !filter.getVirtualHost().equals("")) {
            params.put("host_name", "%" + filter.getVirtualHost() + "%");
        }
        if (filter.getVulnName() != null && !filter.getVulnName().equals("")) {
            params.put("vuln_name", "%" + filter.getVulnName() + "%");
        }
        if (filter.getDateRangeMap() != null && filter.getDateRangeMap().size() > 0) {
            if (filter.getDateRangeMap().size() == 1) {
                params.put("date", filter.getDateRangeMap().get("date"));
            } else if (filter.getDateRangeMap().size() == 2) {
                params.put("start_date", filter.getDateRangeMap().get("start_date"));
                params.put("end_date", filter.getDateRangeMap().get("end_date"));
            }
        }

        if (filter.getRiskLevels() != null && filter.getRiskLevels().length > 0) {
            for (int i = 0; i < filter.getRiskLevels().length; i++) {
                params.put("riskLevel[" + i + "]", filter.getRiskLevels()[i]);
            }
        }

        if (filter.getStatuses() != null && filter.getStatuses().length > 0) {
            for (int i = 0; i < filter.getStatuses().length; i++) {
                params.put("status[" + i + "]", filter.getStatuses()[i]);
            }
        }

        if (filter.getSource() != null && filter.getSource().length > 0) {
            for (int i = 0; i < filter.getSource().length; i++) {
                params.put("source[" + i + "]", filter.getSource()[i]);
            }
        }
        if (filter.getOtherIps() != null && filter.getOtherIps().length > 0) {
            for (int i = 0; i < filter.getOtherIps().length; i++) {
                params.put("otherIps[" + i + "]", filter.getOtherIps()[i]);
            }
        }

        if (filter.getLabels() != null && filter.getLabels().length > 0) {
            for (int i = 0; i < filter.getLabels().length; i++) {
                params.put("labels[" + i + "]", filter.getLabels()[i]);
            }
        }
        if (filter.getFilterAssigneeId() != null && filter.getFilterAssigneeId().length > 0) {
            for (int i = 0; i < filter.getFilterAssigneeId().length; i++) {
                String assignee = filter.getFilterAssigneeId()[i];
                if (assignee.split("#")[0] != "NULL") {
                    params.put("assignees[" + i + "]", assignee.split("#")[0]);
                }
            }
        }
        return params;
    }

    private String makeFilterSQL(ScanResultsFilter filter) {
        StringBuilder sb = new StringBuilder();
        sb.append("1=1 ");

        if (filter.getScanId() != null && !filter.getScanId().trim().equals("")) {
            sb.append("and asset.scan_id = :scan_id ");
        }
        
        if (filter.getActive() != null && !filter.getActive()) {
            sb.append(" AND sv.active = true ");
        } else if ((filter.getActive() != null && filter.getActive())) {
            sb.append(" AND sv.active = false ");
        }
        
        if (filter.getAssetId() != null && !filter.getAssetId().trim().equals("")) {
            sb.append("and asset.asset_id = :asset_id ");
        }
        if (filter.getIpAddress() != null && !filter.getIpAddress().trim().equals("")) {
            sb.append("and (UPPER(TRANSLATE(a.ip,'i','I')) ilike UPPER(TRANSLATE(:ip,'i','I')) or UPPER(TRANSLATE(a.other_ips,'i','I')) ilike UPPER(TRANSLATE(:ip,'i','I'))) ");
        }
        if (!BizzyUtil.isEmpty(filter.getFqdn())) {
            if (filter.getFqdnChecked() != null) {
                sb.append("AND (UPPER(TRANSLATE(a.hostname,'i','I')) not ilike UPPER(TRANSLATE(:hostname,'i','I')) OR a.hostname is NULL) ");
            } else {
                sb.append("and UPPER(TRANSLATE(a.hostname,'i','I')) ilike UPPER(TRANSLATE(:hostname,'i','I')) ");
            }
        }
        if (filter.getPort() != null) {
            if (filter.getPortChecked() != null) {
                sb.append("and p.port_number <> :port_number ");
            } else {
                sb.append("and p.port_number = :port_number ");
            }
        }
        if (filter.getVirtualHost() != null && !filter.getVirtualHost().equals("")) {
            sb.append("and UPPER(TRANSLATE(vh.name,'i','I')) ilike UPPER(TRANSLATE(:host_name,'i','I')) ");
        }
        if (filter.getVulnName() != null && !filter.getVulnName().equals("")) {
            if (filter.getVNameChecked() != null) {
                sb.append("and UPPER(TRANSLATE(v.name,'i','I')) not ilike UPPER(TRANSLATE(:vuln_name,'i','I')) ");
            } else {
                sb.append("and UPPER(TRANSLATE(v.name,'i','I')) ilike UPPER(TRANSLATE(:vuln_name,'i','I')) ");
            }
        }
        if (filter.getDateRangeMap() != null && filter.getDateRangeMap().size() > 0) {
            if (filter.getDateRangeMap().size() == 1) {
                sb.append("and sv.create_date = :date ");
            } else if (filter.getDateRangeMap().size() == 2) {
                sb.append("and sv.create_date between :start_date and :end_date ");
            }
        }
        if (filter.getRiskLevels() != null && filter.getRiskLevels().length > 0) {
            sb.append("and v.risk_level in ( ");
            for (int i = 0; i < filter.getRiskLevels().length; i++) {
                sb.append(" :riskLevel[" + i + "],");
            }
            sb.deleteCharAt(sb.length() - 1);
            sb.append(") ");
        }

        if (filter.getStatuses() != null && filter.getStatuses().length > 0) {
            sb.append("and ts.status in ( ");
            for (int i = 0; i < filter.getStatuses().length; i++) {
                sb.append(" :status[" + i + "],");
            }
            sb.deleteCharAt(sb.length() - 1);
            sb.append(") ");
        }

        if (filter.getSource() != null && filter.getSource().length > 0) {
            sb.append("and sv.source in ( ");
            for (int i = 0; i < filter.getSource().length; i++) {
                sb.append(" :source[" + i + "],");
            }
            sb.deleteCharAt(sb.length() - 1);
            sb.append(") ");
        }

        //Dier IP bilgileri
        String[] otherIps = filter.getOtherIps();
        if (otherIps != null && otherIps.length > 0) {
            if (otherIps[0].equals("NULL")) {
                sb.append("AND ( a.other_ips = '' ");
            } else {
                sb.append("AND ( a.other_ips LIKE :otherIps[" + 0 + "]");
            }
            for (int i = 1; i <= otherIps.length - 1; i++) {
                sb.append(" OR a.other_ips LIKE :otherIps[" + i + "]");
            }
            sb.append(" )");
        }

        if (filter.getLabels() != null && filter.getLabels().length > 0) {
            if (filter.getLabelsChecked() != null) {
                sb.append(" AND NOT EXISTS ( "
                        + "  SELECT DISTINCT sv1.scan_vulnerability_id FROM  scan_vulnerability sv1 "
                        + "  LEFT JOIN vulnerability_label_relations vvlr  "
                        + "      ON sv1.scan_vulnerability_id = vvlr.scan_vulnerability_id ");
                for (int i = 1; i <= filter.getLabels().length - 1; i++) {
                    sb.append("  LEFT JOIN vulnerability_label_relations vvlr" + i
                            + "          ON sv1.scan_vulnerability_id = vvlr" + i + ".scan_vulnerability_id ");
                }
                sb.append(" WHERE sv1.scan_vulnerability_id = sv.scan_vulnerability_id ");
                if (filter.getLabels()[0].equals("NULL")) {
                    sb.append(" AND ( vvlr.label IS NULL");
                } else {
                    sb.append(" AND ( vvlr.label= :labels[0]");
                }
                for (int i = 1; i <= filter.getLabels().length - 1; i++) {
                    sb.append("    AND vvlr" + i + ".label = :labels[" + i + "]");
                }
                sb.append(") )");
            } else {
                if (filter.getLabels()[0].equals("NULL")) {
                    sb.append(" AND ( vlr.label IS NULL");
                } else {
                    sb.append(" AND ( vlr.label= :labels[0]");
                }
                for (int i = 1; i <= filter.getLabels().length - 1; i++) {
                    sb.append(" AND vlr" + i + ".label= :labels[" + i + "]");
                }

                sb.append(")");
            }
        }
        if (filter.getFilterAssigneeId() != null && filter.getFilterAssigneeId().length > 0) {
            boolean isThereNullSearch = false;
            int counter = 0;
            for (int i = 0; i < filter.getFilterAssigneeId().length; i++) {
                String assignee = filter.getFilterAssigneeId()[i];
                if ("NULL".equals(assignee.split("#")[0])) {
                    isThereNullSearch = true;
                    counter += 1;
                }
            }
            if (counter == filter.getFilterAssigneeId().length) {
                sb.append(" and (t.assignee_id is null) ");
            } else {
                sb.append(" and ( t.assignee_id in ( ");
                for (int i = 0; i < filter.getFilterAssigneeId().length; i++) {
                    if (!filter.getFilterAssigneeId()[i].contains("NULL")) {
                        sb.append(" :assignees[" + i + "],");
                    }
                }
                sb.deleteCharAt(sb.length() - 1);
                sb.append(" ) ");

                if (isThereNullSearch == true) {
                    sb.append(" or t.assignee_id is null ");
                }
                sb.append(" ) ");
            }

        }
        return sb.toString();
    }

    public List<PentestScan> getScheduledScans(Date now, Source source) {
        Map params = new HashMap();
        String sql = "SELECT s.*, p.name as policy, a.ip, se.domain , count(*) over ( partition by asset.scan_id ) as asset_count  "
                + "FROM scan s "
                + "LEFT JOIN pentest_policy p "
                + "     ON (s.policy_id = p.id AND s.server_id = p.server_id) "
                + "LEFT JOIN scan_asset asset "
                + "     ON asset.scan_id = s.scan_id "
                + "LEFT JOIN asset a "
                + "     ON asset.asset_id=a.asset_id "
                + "LEFT JOIN server se "
                + "     ON se.setting_id=s.server_id "
                + "WHERE scan_date <= :dateNow "
                + "AND is_scheduled= true "
                + "AND source= :source ";
        params.put("dateNow", now);
        params.put("source", source.toString());
        return jdbcTemplate.query(sql, params, new ScanDetailsResultSetExtractor(false));
    }
    
    public int getCustomizedScheduledScansPerHour(String hour, Source source) {
        Map params = new HashMap();
        String sql = "SELECT COUNT(*) FROM scheduled_scan "
                + "WHERE is_scheduled= true "
                + "AND customized_scan = true "
                + "AND to_char(scan_date,'HH24')= :hour "
                + "AND source= :source ";
        if(hour.length() == 1) {
            hour = "0" + hour;
        }
        params.put("hour", hour);
        params.put("source", source.toString());
        Integer count = jdbcTemplate.queryForObject(sql, params, Integer.class);
        return count;
    }
    //todo
    public List<PentestScan> getScansToRestate(Source source) {
        Map params = new HashMap();

        String sql = "SELECT s.*, spd.*, p.name as policy, a.ip, se.domain , count(*) over ( partition by asset.scan_id ) as asset_count  "
                + "FROM scan s "
                + "LEFT JOIN pentest_policy p "
                + "     ON (s.policy_id = p.id AND s.server_id = p.server_id) "
                + "LEFT JOIN scan_asset asset "
                + "     ON asset.scan_id = s.scan_id "
                + "LEFT JOIN asset a "
                + "     ON asset.asset_id=a.asset_id "
                + "LEFT JOIN server se "
                + "     ON se.setting_id=s.server_id "
                + "LEFT JOIN scan_project_details spd "
                + " ON spd.scan_id = s.scan_id "
                + "WHERE 1=1 ";
        if (source != null) {
            switch (source) {
                case FORTIFY:
                case NETSPARKERENT:
                case NETSPARKER:
                    sql += "AND status NOT IN (:stError, :stCompleted, :stProcessing ) ";
                    params.put("stError", ScanStatus.ERROR.toString());
                    params.put("stCompleted", ScanStatus.COMPLETED.toString());
                    params.put("stProcessing", ScanStatus.PROCESSING.toString());
                    break;
                case ACUNETIX:
                    sql += "AND status NOT IN (:stCompleted, :stAborted, :stError, :stPaused, :stPausing ) ";

                    params.put("stAborted", ScanStatus.ABORTED.toString());
                    params.put("stPaused", ScanStatus.PAUSED.toString());
                    params.put("stPausing", ScanStatus.PAUSING.toString());
                    params.put("stError", ScanStatus.ERROR.toString());
                    params.put("stCompleted", ScanStatus.COMPLETED.toString());
                    break;
                case ARACHNI:
                    sql += "AND status NOT IN (:stCompleted, :stAborted, :stError, :stPaused, :stPausing ) ";

                    params.put("stAborted", ScanStatus.ABORTED.toString());
                    params.put("stPaused", ScanStatus.PAUSED.toString());
                    params.put("stPausing", ScanStatus.PAUSING.toString());
                    params.put("stError", ScanStatus.ERROR.toString());
                    params.put("stCompleted", ScanStatus.COMPLETED.toString());
                    break;
                case SECURITY_CENTER:
                case NESSUS:
                    sql += "AND status NOT IN (:stCompleted, :stAborted, :StCancelled, :stEmpty, :stError, :stProcessing ) AND sync_scan = false ";

                    params.put("stAborted", ScanStatus.ABORTED.toString());
                    params.put("StCancelled", ScanStatus.CANCELED.toString());
                    params.put("stEmpty", ScanStatus.EMPTY.toString());
                    params.put("stError", ScanStatus.ERROR.toString());
                    params.put("stCompleted", NessusScanStatus.COMPLETED.toString());
                    params.put("stProcessing", ScanStatus.PROCESSING.toString());
                    break;
                case CHECKMARX:
                    sql += "AND status NOT IN (:stCanceled, :stError, :stFinished, :stImporting)";

                    params.put("stCanceled", ScanStatus.CANCELED.toString());
                    params.put("stError", ScanStatus.ERROR.toString());
                    params.put("stFinished", ScanStatus.COMPLETED.toString());
                    params.put("stImporting", ScanStatus.IMPORTING.toString());
                    break;
                case QUALYS:
                    sql += "AND status NOT IN (:stCanceled, :stError, :stFinished, :stScheduled)";

                    params.put("stCanceled", ScanStatus.CANCELED.toString());
                    params.put("stError", ScanStatus.ERROR.toString());
                    params.put("stFinished", ScanStatus.FINISHED.toString());
                    params.put("stScheduled", ScanStatus.SCHEDULED.toString());
                    break;
                case NEXPOSE:
                    sql += "AND status NOT IN (:stCompleted, :stError) ";

                    params.put("stError", ScanStatus.ERROR.toString());
                    params.put("stCompleted", ScanStatus.COMPLETED.toString());
                    break;
                case OPENVAS:
                    sql += "AND status NOT IN (:stCompleted, :stError) ";

                    params.put("stError", ScanStatus.ERROR.toString());
                    params.put("stCompleted", ScanStatus.COMPLETED.toString());
                    break;
            }
            sql += "AND source= :source AND results_saved= :saved ";
            params.put("source", source.toString());
            params.put("saved", false);

        }

        return jdbcTemplate.query(sql, params, new ScanDetailsResultSetExtractor(false));
    }

    //Sadece Nessus
    public List<AssetDiscovery> getHostScansToRestate() {
        Map params = new HashMap();

        String sql = "SELECT s.* , a.domain "
                + "FROM passive_asset_scan s "
                + "LEFT JOIN server a ON a.setting_id = s.server_id "
                + "WHERE s.status NOT IN (:stCompleted, :stCancelled, :stAborted, :stEmpty, :stError ) "
                + "AND s.scheduled= false AND s.source = :source ";

        params.put("stAborted", ScanStatus.ABORTED.toString());
        params.put("stEmpty", ScanStatus.EMPTY.toString());
        params.put("stError", ScanStatus.ERROR.toString());
        params.put("stCancelled", ScanStatus.CANCELED.toString());
        params.put("stCompleted", NessusScanStatus.COMPLETED.toString());
        params.put("source", Source.NESSUS.toString());

        return jdbcTemplate.query(sql, params, new HostScanResultSetExtractor(false));
    }

    public class ScanColumnNameMapper implements ColumnNameMapper {

        @Override
        public String getColumnName(String data) {
            String result;
            switch (data) {
                case "name":
                    result = "s.name ";
                    break;
                case "scanId":
                    result = "s.scan_id ";
                    break;
                case "description":
                    result = "s.description ";
                    break;
                case "requestDate":
                    result = "s.request_date ";
                    break;
                case "completionDate":
                    result = "s.completion_date ";
                    break;
                case "scanDate":
                    result = "s.scan_date ";
                    break;
                case "source":
                    result = "s.source ";
                    break;
                case "status.name":
                    result = "s.status ";
                    break;
                case "targets":
                    result = "s.include_ips ";
                    break;
                case "requestedBy":
                    result = "s.requested_by ";
                    break;
                case "policy.name":
                    result = "p.name";
                    break;
                case "assetCount":
                    result = "asset_count ";
                    break;
                default:
                    throw new IllegalArgumentException(data + " is not a valid column name.");
            }
            return result;
        }

        @Override
        public boolean isDefault(String data) {
            return data.equals("name");
        }

        @Override
        public String getDefault() {
            return "s.name ASC ";
        }
    }

    class HostScanColumnNameMapper implements ColumnNameMapper {

        @Override
        public String getColumnName(String data) {
            String result;
            switch (data) {
                case "name":
                    result = "s.name ";
                    break;
                case "id":
                    result = "s.id ";
                    break;
                case "description":
                    result = "s.description ";
                    break;
                case "requestDate":
                    result = "s.request_date ";
                    break;
                case "completionDate":
                    result = "s.completion_date ";
                    break;
                case "scanDate":
                    result = "s.scan_date ";
                    break;
                case "source":
                    result = "s.source ";
                    break;
                case "status.name":
                    result = "s.status ";
                    break;
                case "target":
                    result = "s.target ";
                    break;
                case "requestedBy":
                    result = "s.requested_by ";
                    break;
                case "recurrence":
                    result = "s.recurrence ";
                    break;
                case "launch":
                    result = "s.launch ";
                    break;
                default:
                    throw new IllegalArgumentException(data + " is not a valid column name.");
            }
            return result;
        }

        @Override
        public boolean isDefault(String data) {
            return data.equals("name");
        }

        @Override
        public String getDefault() {
            return "s.request_date ASC ";
        }
    }

    class ScheduledScanColumnNameMapper implements ColumnNameMapper {

        @Override
        public String getColumnName(String data) {
            String result;
            switch (data) {
                case "name":
                    result = "s.name ";
                    break;
                case "scanId":
                    result = "s.scan_id ";
                    break;
                case "description":
                    result = "s.description ";
                    break;
                case "requestDate":
                    result = "s.request_date ";
                    break;
                case "scanDate":
                    result = "s.scan_date ";
                    break;
                case "source":
                    result = "s.source ";
                    break;
                case "status.name":
                    result = "s.status ";
                    break;
                case "targets":
                    result = "s.include_ips ";
                    break;
                case "requestedBy":
                    result = "s.requested_by ";
                    break;
                case "policy.name":
                    result = "p.name";
                    break;
                case "completedScanCount":
                    result = "s.completed_scan_count";
                    break;
                case "active":
                    result = "s.active";
                    break;
                default:
                    throw new IllegalArgumentException(data + " is not a valid column name.");
            }
            return result;
        }

        @Override
        public boolean isDefault(String data) {
            return data.equals("name");
        }

        @Override
        public String getDefault() {
            return "s.name ASC ";
        }
    }

    class ScanResultColumnNameMapper implements ColumnNameMapper {

        @Override
        public String getColumnName(String data) {
            String result;
            switch (data) {
                case "vulnerability.ip":
                    result = "a.ip ";
                    break;
                case "vulnerability.ipDecimal":
                    result = "a.ip_decimal";
                    break;
                case "vulnerability.name":
                    result = "v.name ";
                    break;
                case "vulnerability.vulnerabilityId":
                    result = "v.vulnerability_id ";
                    break;
                case "vulnerability.cvssBaseScore":
                    result = "v.cvss_base_score ";
                    break;
                case "vulnerability.cvssTemporalScore":
                    result = "v.cvss_temporal_score ";
                    break;
                case "vulnerability.riskLevel":
                    result = "v.risk_level ";
                    break;
                case "port.portNumber":
                    result = "p.port_number ";
                    break;
                case "port.protocol":
                    result = "p.protocol ";
                    break;
                case "lastUpdate":
                    result = "v.last_update ";
                    break;
                case "scanVulnerabilityId":
                    result = "sv.scan_vulnerability_id ";
                    break;
                case "source":
                    result = "sv.source ";
                    break;
                case "host":
                    result = "vh.name ";
                    break;
                case "svDetails.path":
                    result = "svd.path ";
                    break;
                case "svDetails.lineNumber":
                    result = "svd.line_number ";
                    break;    
                default:
                    throw new IllegalArgumentException(data + " is not a valid column name.");
            }
            return result;
        }

        @Override
        public boolean isDefault(String data) {
            return data.equals("name");
        }

        @Override
        public String getDefault() {
            return "a.ip ASC ";
        }
    }

    class AssetVulnerabilityColumnNameMapper implements ColumnNameMapper {

        @Override
        public String getColumnName(String data) {
            String result;
            switch (data) {
                case "vulnerability.ip":
                    result = "a.ip ";
                    break;
                case "vulnerability.name":
                    result = "v.name ";
                    break;
                case "vulnerabilityId":
                    result = "vulnerability_id ";
                    break;
                case "vulnerability.cvssBaseScore":
                    result = "v.cvss_base_score ";
                    break;
                case "vulnerability.cvssTemporalScore":
                    result = "v.cvss_temporal_score ";
                    break;
                case "vulnerability.riskLevel":
                    result = "v.risk_level ";
                    break;
                case "lastUpdate":
                    result = "v.last_update ";
                    break;
                case "vulnerability.source":
                    result = "v.source ";
                    break;
                //zafiyet saysn sql'den sort etmediimiz iin burada default sort deeri ileme alnyor.
                case "vulnerabilityCount":
                    result = "a.ip ";
                    break;
                default:
                    throw new IllegalArgumentException(data + " is not a valid column name.");
            }
            return result;
        }

        @Override
        public boolean isDefault(String data) {
            return data.equals("vulnerability.riskLevel");
        }

        @Override
        public String getDefault() {
            return "v.risk_level DESC ";
        }
    }

    class LabelColumnNameMapper implements ColumnNameMapper {

        @Override
        public String getColumnName(String data) {
            String result;
            switch (data) {
                case "name":
                    result = "vl.label ";
                    break;
                case "vulnerabilityCount":
                    result = "allCount ";
                    break;
                case "openVulnerabilityCount":
                    result = "openCount ";
                    break;
                case "createDate":
                    result = "create_date ";
                    break;
                default:
                    throw new IllegalArgumentException(data + " is not a valid column name.");
            }
            return result;
        }

        @Override
        public boolean isDefault(String data) {
            return data.equals("allCount");
        }

        @Override
        public String getDefault() {
            return "allCount DESC ";
        }
    }

    class AssetDiscoveryResultColumnNameMapper implements ColumnNameMapper {

        @Override
        public String getColumnName(String data) {
            String result;
            switch (data) {
                case "ip":
                    result = "pasr.ip ";
                    break;
                case "operatingSystem":
                    result = "operating_system ";
                    break;
                case "netbios":
                    result = "netbios ";
                    break;
                case "mac":
                    result = "mac ";
                    break;
                default:
                    throw new IllegalArgumentException(data + " is not a valid column name.");
            }
            return result;
        }

        @Override
        public boolean isDefault(String data) {
            return data.equals("ip");
        }

        @Override
        public String getDefault() {
            return "pasr.ip ASC ";
        }
    }

    class ScanAssetDiscoveryResultColumnNameMapper implements ColumnNameMapper {

        @Override
        public String getColumnName(String data) {
            String result;
            switch (data) {
                case "scannedIp":
                    result = "ip ";
                    break;
                case "scannedIpDecimal":
                    result = "ip_decimal";
                    break;
                case "vulnCount":
                    result = "count ";
                    break;
                default:
                    throw new IllegalArgumentException(data + " is not a valid column name.");
            }
            return result;
        }

        @Override
        public boolean isDefault(String data) {
            return data.equals("scannedIp");
        }

        @Override
        public String getDefault() {
            return "ip ASC ";
        }
    }

    class ScanIdResultExtractor implements ResultSetExtractor<ArrayList<String>> {

        @Override
        public ArrayList<String> extractData(ResultSet rs) throws SQLException, DataAccessException {
            ArrayList<String> results = new ArrayList<>();
            while (rs.next()) {
                results.add(rs.getString("report_id"));

            }

            return results;
        }

    }

    class ScanResultResultSetExtractor implements ResultSetExtractor<List<ScanVulnerability>> {

        ScanResultResultSetExtractor(boolean b) {

        }

        @Override
        public List<ScanVulnerability> extractData(ResultSet rs) throws SQLException, DataAccessException {
            List<ScanVulnerability> scanVulnerabilityList = new LinkedList<>();

            Map<String, ScanVulnerability> svsMap = new HashMap<>();
            while (rs.next()) {
                String svId = rs.getString("scan_vulnerability_id");
                ScanVulnerability sVuln = svsMap.get(svId);
                if (sVuln == null) {

                    sVuln = new ScanVulnerability();
                    sVuln.setScanVulnerabilityId(rs.getString("scan_vulnerability_id"));
                    sVuln.setResult(rs.getString("result"));

                    Vulnerability vulnerability = new Vulnerability();
                    vulnerability.setVulnerabilityId(rs.getString("vulnerability_id"));
                    vulnerability.setName(rs.getString("name"));
                    vulnerability.setCvssBaseScore(rs.getFloat("cvss_base_score"));
                    vulnerability.setCvssTemporalScore(rs.getFloat("cvss_temporal_score"));
                    vulnerability.setConsequence(rs.getString("consequence"));
                    vulnerability.setDiagnosis(rs.getString("diagnosis"));
                    vulnerability.setRiskLevel(rs.getInt("risk_level"));
                    vulnerability.setVulnNumber(rs.getString("vuln_number"));
                    vulnerability.setLastUpdate(rs.getDate("last_update"));
                    vulnerability.setIp(rs.getString("ip"));
                    vulnerability.setDescription(rs.getString("description"));
                    vulnerability.setSolution(rs.getString("solution"));
                    vulnerability.setSource(rs.getString("source"));
                    //vulnerability.setType(VulnerabilityType.valueOf(rs.getString("type")));

                    Category cat = new Category();
                    cat.setName(rs.getString("categoryName"));
                    vulnerability.setCategory(cat);

//                    if (!BizzyUtil.isEmpty(rs.getString("assignee_id"))) {
//                        Assignee assignee = new Assignee();
//                        assignee.setAssigneeId(rs.getString("assignee_id"));
//                        assignee.setType(AssigneeTypeEnum.valueOf(rs.getString("assigneeType")));
//                        if (!BizzyUtil.isEmpty(rs.getString("username"))) {
//                            assignee.setName(rs.getString("username"));
//                        } else {
//                            assignee.setName(rs.getString("groupName"));
//                        }
//                    }
                    Port port = new Port();
                    //port.setPortId(rs.getString("port_id"));
                    Integer portNum = rs.getInt("portNumber");
                    if (rs.wasNull()) {
                        port.setPortNumber(null);
                    } else {
                        port.setPortNumber(portNum);
                    }
                    port.setProtocol(rs.getString("protocol"));
                    sVuln.setPort(port);

                    sVuln.setVulnerability(vulnerability);

                    scanVulnerabilityList.add(sVuln);
                    svsMap.put(svId, sVuln);
                }
            }
            return scanVulnerabilityList;
        }
    }

    class ScheduledScanResultSetExtractor implements ResultSetExtractor<List<ScheduledPentestScan>> {

        ScheduledScanResultSetExtractor(boolean b) {

        }

        @Override
        public List<ScheduledPentestScan> extractData(ResultSet rs) throws SQLException, DataAccessException {
            Map<String, ScheduledPentestScan> scansMap = new HashMap<>();
            List<ScheduledPentestScan> scans = new LinkedList<>();
            while (rs.next()) {

                String scanId = rs.getString("scheduled_scan_id");
                ScheduledPentestScan scan = scansMap.get(scanId);

                if (scan == null) {
                    scan = new ScheduledPentestScan();
                    scan.setScanId(scanId);
                    scan.setName(rs.getString("name"));
                    scan.setDescription(rs.getString("description"));
                    scan.setRequestedBy(rs.getString("requested_by"));
                    scan.setRequestDate(rs.getTimestamp("request_date"));
                    scan.setScanDate(rs.getTimestamp("scan_date"));
                    scan.setTargets(rs.getString("include_ips"));
                    scan.setExcludeIps(rs.getString("exclude_ips"));
                    scan.setResultsSaved(rs.getBoolean("results_saved"));
                    scan.setScanRef(rs.getString("scan_ref"));
                    scan.setReportId(rs.getString("report_id"));
                    scan.setScheduled(rs.getBoolean("is_scheduled"));
                    scan.setSyncScan(rs.getBoolean("sync_scan"));
                    scan.setCustomizedScan(rs.getBoolean("customized_scan"));
                    scan.setAutoClose(rs.getBoolean("auto_close"));
                    scan.setScanWeekend(rs.getBoolean("is_scan_weekend"));
                    scan.setSslScan(rs.getBoolean("ssl_scan"));
                    scan.setSslScanPorts(rs.getString("ssl_scan_ports"));
                    scan.setRecurrence(rs.getInt("recurrence"));
                    scan.setCompletedScanCount(rs.getInt("completed_scan_count"));
                    scan.setMinRiskLevel(rs.getInt("min_risk_level"));
                    scan.setActive(rs.getBoolean("active"));
                    scan.setProduceSslCertificateResults(rs.getBoolean("produce_ssl_certificate_results"));
                    scan.setAssetGroupId(rs.getString("asset_group_id"));
                    scan.setScanAggregation(rs.getBoolean("scan_aggregation"));
                    scan.setScanProscriptiveTimeStart(rs.getString("scan_proscriptive_time_start"));
                    scan.setScanProscriptiveTimeEnd(rs.getString("scan_proscriptive_time_end"));
                    scan.setMail(rs.getString("mail"));
                    scan.setUpdateOperatingSystem(rs.getBoolean("update_operating_system"));

                    if (!BizzyUtil.isEmpty(rs.getString("status"))) {
                        scan.setStatus(ScanStatus.valueOf(rs.getString("status")));
                    }

                    if (!BizzyUtil.isEmpty(rs.getString("timezone"))) {
                        PentestTimezone timezone = new PentestTimezone();
                        timezone.setValue(rs.getString("timezone"));
                        scan.setTimezone(timezone);
                    }

                    PentestScanner scanner = new PentestScanner();
                    scanner.setId(rs.getString("scanner_id"));
                    scan.setScanner(scanner);

                    try {
                        PentestPolicy policy = new PentestPolicy();
                        policy.setName(rs.getString("policy"));
                        policy.setId(rs.getString("policy_id"));
                        scan.setPolicy(policy);
                    } catch (Exception ex) {
                        //Nothing todo
                    }

                    Server server = new Server();
                    server.setSettingId(rs.getString("server_id"));
                    scan.setServer(server);

                    if (!BizzyUtil.isEmpty(rs.getString("source"))) {
                        scan.setSource(Source.valueOf(rs.getString("source")));
                        try {
                            if(scan.getSource().equals(Source.FORTIFY) || scan.getSource().equals(Source.CHECKMARX)) {
                                ProjectDetails projectDetails = new ProjectDetails();
                                projectDetails.setBuildTool(rs.getString("build_tool"));
                                projectDetails.setProjectName(rs.getString("project_name"));
                                projectDetails.setLanguageType(rs.getString("language"));
                                projectDetails.setCommand(rs.getString("command"));
                                projectDetails.setVcsId(rs.getString("vcs_id"));
                                projectDetails.setRevision(rs.getString("revision"));
                                projectDetails.setVcsPath(rs.getString("vcs_path"));
                                scan.setProjectDetails(projectDetails);
                            } else if (scan.getSource().equals(Source.SECURITY_CENTER)) {
                                ProjectDetails projectDetails = new ProjectDetails();
                                projectDetails.setRepository(rs.getString("repository"));
                                projectDetails.setPluginId(rs.getString("plugin_id"));
                                scan.setProjectDetails(projectDetails);
                            }
                        } catch (SQLException ex) {
                        }
                    }

                    if (!BizzyUtil.isEmpty(rs.getString("occurrence"))) {
                        scan.setOccurrence(OccurrenceType.valueOf(rs.getString("occurrence")));
                    }

                    Customer customer = new Customer();
                    customer.setCustomerId(rs.getString("customer_id"));

                    scan.setCustomer(customer);

                    scansMap.put(scan.getScanId(), scan);
                    scans.add(scan);
                }
            }
            return scans;
        }
    }

    class AssetDiscoveryResultListResultSetExtractor implements ResultSetExtractor<List<AssetDiscoveryResult>> {

        AssetDiscoveryResultListResultSetExtractor(boolean b) {

        }

        @Override
        public List<AssetDiscoveryResult> extractData(ResultSet rs) throws SQLException, DataAccessException {
            List<AssetDiscoveryResult> assetDiscoveryResultList = new LinkedList<>();

            Map<String, AssetDiscoveryResult> pasrMap = new HashMap<>();
            while (rs.next()) {
                String id = rs.getString("id");
                AssetDiscoveryResult pasr = pasrMap.get(id);
                Port port = new Port();

                if (pasr == null) {
                    pasr = new AssetDiscoveryResult();
                    List<Port> ports = new LinkedList<>();
                    pasr.setId(rs.getString("id"));
                    pasr.setIp(rs.getString("ip"));
                    pasr.setNetbios(rs.getString("netbios"));
                    pasr.setMac(rs.getString("mac"));
                    pasr.setOperatingSystem(rs.getString("operating_system"));
                    pasr.setOsCPE(rs.getString("cpe"));
                    try {
                        pasr.setNewAsset(rs.getBoolean("new_host"));
                    } catch (Exception ex) {
                        //Bo gelme durumu
                    }
                    port.setPortId(rs.getString("portId"));
                    Integer portNum = rs.getInt("portNumber");
                    if (rs.wasNull()) {
                        port.setPortNumber(null);
                    } else {
                        port.setPortNumber(portNum);
                    }
                    port.setProtocol(rs.getString("protocol"));
                    port.setService(rs.getString("service"));
                    port.setBanner(rs.getString("banner"));
                    try {
                        port.setTotal(rs.getInt("portNumber"));
                    } catch (Exception ex) {
                        //Bo gelme durumu
                    }
                    try {
                        port.setNewPort(rs.getBoolean("new_port"));
                    } catch (Exception ex) {
                        //Bo gelme durumu
                    }

                    ports.add(port);
                    pasr.setPorts(ports);

                    assetDiscoveryResultList.add(pasr);
                    pasrMap.put(id, pasr);
                } else {
                    port.setPortId(rs.getString("portId"));
                    Integer portNum = rs.getInt("portNumber");
                    if (rs.wasNull()) {
                        port.setPortNumber(null);
                    } else {
                        port.setPortNumber(portNum);
                    }
                    port.setProtocol(rs.getString("protocol"));
                    port.setService(rs.getString("service"));
                    port.setBanner(rs.getString("banner"));

                    try {
                        port.setTotal(rs.getInt("portNumber"));
                    } catch (Exception ex) {
                        //Bo gelme durumu
                    }
                    try {
                        port.setNewPort(rs.getBoolean("new_port"));
                    } catch (Exception ex) {
                        //Bo gelme durumu
                    }

                    pasr.getPorts().add(port);
                }
            }
            return assetDiscoveryResultList;
        }
    }

    class ScanResultListResultSetExtractor implements ResultSetExtractor<List<ScanVulnerability>> {

        ScanResultListResultSetExtractor(boolean b) {

        }

        @Override
        public List<ScanVulnerability> extractData(ResultSet rs) throws SQLException, DataAccessException {

            List<ScanVulnerability> scanVulnerabilityList = new LinkedList<>();

            Map<String, ScanVulnerability> svsMap = new HashMap<>();
            while (rs.next()) {
                List<Label> labelList = new LinkedList<>();
                String svId = rs.getString("scan_vulnerability_id");
                ScanVulnerability sVuln = svsMap.get(svId);
                Vulnerability vulnerability = null;

                if (sVuln != null) {
                    vulnerability = sVuln.getVulnerability();
                    labelList = vulnerability.getLabels();
                    if (labelList == null) {
                        labelList = new ArrayList<>();
                        vulnerability.setLabels(labelList);
                    }
                }
                Label label = new Label();

                if (sVuln == null) {

                    sVuln = new ScanVulnerability();
                    sVuln.setScanVulnerabilityId(rs.getString("scan_vulnerability_id"));

                    vulnerability = new Vulnerability();
                    vulnerability.setVulnerabilityId(rs.getString("vulnerability_id"));
                    vulnerability.setName(rs.getString("name"));
                    vulnerability.setRiskLevel(rs.getInt("risk_level"));
                    vulnerability.setIp(rs.getString("ip"));
                    vulnerability.setIpDecimal(rs.getLong("decimal"));
                    vulnerability.setVulnNumber(rs.getString("vuln_number"));
                    //vulnerability.setSource("ABC");
                    if (!BizzyUtil.isEmpty(rs.getString("svSource"))) {
                        sVuln.setSource(rs.getString("svSource"));
                    }
                    vulnerability.setSource(rs.getString("svSource"));

                    Category cat = new Category();
                    cat.setName(rs.getString("categoryName"));
                    vulnerability.setCategory(cat);

//                    if (!BizzyUtil.isEmpty(rs.getString("assignee_id"))) {
//                        Assignee assignee = new Assignee();
//                        assignee.setAssigneeId(rs.getString("assignee_id"));
//                        assignee.setType(AssigneeTypeEnum.valueOf(rs.getString("assigneeType")));
//                        if (!BizzyUtil.isEmpty(rs.getString("username"))) {
//                            assignee.setName(rs.getString("username"));
//                        } else {
//                            assignee.setName(rs.getString("groupName"));
//                        }
//                    }
                    label.setName(rs.getString("label_name"));
                    if (label.getName() != null) {
                        labelList.add(label);
                    }
                    vulnerability.setLabels(labelList);

                    Port port = new Port();
                    Integer portNum = rs.getInt("portNumber");
                    if (rs.wasNull()) {
                        port.setPortNumber(null);
                    } else {
                        port.setPortNumber(portNum);
                    }
                    port.setProtocol(rs.getString("protocol"));
                    sVuln.setPort(port);
                    sVuln.setActive(rs.getBoolean("active"));

                    VirtualHost host = new VirtualHost();
                    String hostName = rs.getString("host_name");
                    if (hostName == null) {
                        host.setName(null);
                    } else {
                        host.setName(hostName);
                    }
                    sVuln.setHost(host);

                    sVuln.setVulnerability(vulnerability);
                    ScanVulnerabilityDetails details = new ScanVulnerabilityDetails();
                    details.setLineNumber(rs.getInt("line_number"));
                    details.setPath(rs.getString("path"));
                    sVuln.setSvDetails(details);
                    scanVulnerabilityList.add(sVuln);
                    svsMap.put(svId, sVuln);
                } else {
                    label.setName(rs.getString("label_name"));
                    labelList.add(label);
                    vulnerability.setLabels(labelList);
                }
            }
            return scanVulnerabilityList;
        }
    }

    class AssetVulnerabilityListResultSetExtractor implements ResultSetExtractor<List<AssetVulnerability>> {

        AssetVulnerabilityListResultSetExtractor(boolean b) {

        }

        @Override
        public List<AssetVulnerability> extractData(ResultSet rs) throws SQLException, DataAccessException {

            List<ScanVulnerability> scanVulnerabilityList = new LinkedList<>();

            Map<String, ScanVulnerability> svsMap = new HashMap<>();
            while (rs.next()) {
                List<Label> labelList = new LinkedList<>();
                String svId = rs.getString("scan_vulnerability_id");
                ScanVulnerability sVuln = svsMap.get(svId);
                Vulnerability vulnerability = null;

                if (sVuln != null) {
                    vulnerability = sVuln.getVulnerability();
                    labelList = vulnerability.getLabels();
                    if (labelList == null) {
                        labelList = new ArrayList<>();
                        vulnerability.setLabels(labelList);
                    }
                }
                Label label = new Label();

                if (sVuln == null) {

                    sVuln = new ScanVulnerability();
                    sVuln.setScanVulnerabilityId(rs.getString("scan_vulnerability_id"));
                    sVuln.setActive(rs.getBoolean("active"));

                    vulnerability = new Vulnerability();
                    vulnerability.setVulnerabilityId(rs.getString("vulnerability_id"));
                    vulnerability.setName(rs.getString("name"));
                    vulnerability.setRiskLevel(rs.getInt("risk_level"));
                    vulnerability.setEffect(rs.getString("effect"));
                    vulnerability.setRootCause(rs.getString("root_cause"));
                    vulnerability.setProblemArea(rs.getString("problem_area"));
                    //vulnerability.setIp(rs.getString("ip"));
                    //vulnerability.setSource("ABC");
                    if (!BizzyUtil.isEmpty(rs.getString("svSource"))) {
                        sVuln.setSource(rs.getString("svSource"));
                    }
                    vulnerability.setSource(rs.getString("svSource"));

                    /*Category cat = new Category();
                    cat.setName(rs.getString("categoryName"));
                    vulnerability.setCategory(cat);*/
//                    if (!BizzyUtil.isEmpty(rs.getString("assignee_id"))) {
//                        Assignee assignee = new Assignee();
//                        assignee.setAssigneeId(rs.getString("assignee_id"));
//                        assignee.setType(AssigneeTypeEnum.valueOf(rs.getString("assigneeType")));
//                        if (!BizzyUtil.isEmpty(rs.getString("username"))) {
//                            assignee.setName(rs.getString("username"));
//                        } else {
//                            assignee.setName(rs.getString("groupName"));
//                        }
//                    }
                    label.setName(rs.getString("label_name"));
                    if (label.getName() != null) {
                        labelList.add(label);
                    }
                    vulnerability.setLabels(labelList);

                    VirtualHost host = new VirtualHost();
                    String hostName = rs.getString("host_name");
                    if (hostName == null) {
                        host.setName(null);
                    } else {
                        host.setName(hostName);
                    }
                    sVuln.setHost(host);

                    /*Port port = new Port();
                    port.setPortNumber(rs.getInt("portNumber"));
                    port.setProtocol(rs.getString("protocol"));
                    sVuln.setPort(port);
                    sVuln.setActive(rs.getBoolean("active"));*/
                    sVuln.setVulnerability(vulnerability);

                    scanVulnerabilityList.add(sVuln);
                    svsMap.put(svId, sVuln);
                } else {
                    label.setName(rs.getString("label_name"));
                    labelList.add(label);
                    vulnerability.setLabels(labelList);
                }
            }
            Map<String, AssetVulnerability> vsMap = new LinkedHashMap<>();
            List<AssetVulnerability> assetVulnerabilityList = new LinkedList<>();
            for (ScanVulnerability scanVulnerability : scanVulnerabilityList) {
                String vulnerabilityId = scanVulnerability.getVulnerability().getVulnerabilityId();
                if (vsMap.containsKey(vulnerabilityId)) {
                    vsMap.get(vulnerabilityId).setVulnerabilityCount(vsMap.get(vulnerabilityId).getVulnerabilityCount() + 1);
                    if (scanVulnerability.getHost().getName() != null) {
                        vsMap.get(vulnerabilityId).getHost().setName(vsMap.get(vulnerabilityId).getHost().getName() + ", " + scanVulnerability.getHost().getName());
                    }
                } else {
                    AssetVulnerability assetVulnerability = new AssetVulnerability();
                    assetVulnerability.setVulnerabilityId(vulnerabilityId);
                    assetVulnerability.setVulnerability(scanVulnerability.getVulnerability());
                    assetVulnerability.setVulnerabilityCount(1);
                    assetVulnerability.setSvId(scanVulnerability.getScanVulnerabilityId());
                    assetVulnerability.setSvActive(scanVulnerability.isActive());
                    assetVulnerability.setHost(scanVulnerability.getHost());
                    vsMap.put(vulnerabilityId, assetVulnerability);
                }
            }
            assetVulnerabilityList = new ArrayList<AssetVulnerability>(vsMap.values());
            return assetVulnerabilityList;
        }
    }

    class ScanResultSetExtractor implements ResultSetExtractor<List<PentestScan>> {

        ScanResultSetExtractor(boolean b) {

        }

        @Override
        public List<PentestScan> extractData(ResultSet rs) throws SQLException, DataAccessException {
            Map<String, PentestScan> scansMap = new HashMap<>();
            List<PentestScan> scans = new LinkedList<>();
            while (rs.next()) {

                String scanId = rs.getString("scan_id");
                PentestScan scan = scansMap.get(scanId);

                if (scan == null) {
                    scan = new PentestScan();
                    scan.setScanId(scanId);
                    scan.setName(rs.getString("name"));
                    scan.setToolScanId(rs.getString("tool_scan_id"));
                    scan.setDescription(rs.getString("description"));
                    scan.setRequestedBy(rs.getString("requested_by"));
                    scan.setRequestDate(rs.getTimestamp("request_date"));
                    scan.setScanDate(rs.getTimestamp("scan_date"));
                    scan.setTargets(rs.getString("include_ips"));
                    scan.setExcludeIps(rs.getString("exclude_ips"));
                    scan.setResultsSaved(rs.getBoolean("results_saved"));
                    scan.setScanRef(rs.getString("scan_ref"));
                    scan.setReportId(rs.getString("report_id"));
                    scan.setProgress(rs.getInt("progress"));
                    scan.setScheduled(rs.getBoolean("is_scheduled"));
                    scan.setMinRiskLevel(rs.getInt("min_risk_level"));
                    scan.setCompletionDate(rs.getTimestamp("completion_date"));
                    scan.setSyncScan(rs.getBoolean("sync_scan"));
                    scan.setCustomizedScan(rs.getBoolean("customized_scan"));                    
                    if (!BizzyUtil.isEmpty(rs.getString("status"))) {
                        scan.setStatus(ScanStatus.valueOf(rs.getString("status")));
                    }

                    if (!BizzyUtil.isEmpty(rs.getString("timezone"))) {
                        PentestTimezone timezone = new PentestTimezone();
                        timezone.setValue(rs.getString("timezone"));
                        scan.setTimezone(timezone);
                    }

                    PentestScanner scanner = new PentestScanner();
                    scanner.setId(rs.getString("scanner_id"));
                    scan.setScanner(scanner);

                    try {
                        PentestPolicy policy = new PentestPolicy();
                        policy.setName(rs.getString("policy"));
                        policy.setId(rs.getString("policy_id"));
                        scan.setPolicy(policy);
                    } catch (Exception ex) {
                        //Nothing todo
                    }

                    Server server = new Server();
                    server.setSettingId(rs.getString("server_id"));
                    server.setDomain(rs.getString("domain"));
                    scan.setServer(server);

                    if (!BizzyUtil.isEmpty(rs.getString("source"))) {
                        scan.setSource(Source.valueOf(rs.getString("source")));
                    }
                    if (!BizzyUtil.isEmpty(rs.getString("scheduled_scan_id"))) {
                        ScheduledPentestScan scheduled = new ScheduledPentestScan();
                        scheduled.setUuid(rs.getString("scheduled_scan_id"));
                        scan.setScheduledPentestScan(scheduled);
                    }

                    Customer customer = new Customer();
                    customer.setCustomerId(rs.getString("customer_id"));

                    scan.setCustomer(customer);
                    //scan.setAssetCount(rs.getInt("asset_count"));

                    scan.setScanProscriptiveTimeStart(rs.getString("scan_proscriptive_time_start"));
                    scan.setScanProscriptiveTimeEnd(rs.getString("scan_proscriptive_time_end"));

                    scansMap.put(scan.getScanId(), scan);
                    scans.add(scan);
                }
            }
            return scans;
        }
    }

    class ScanDetailsResultSetExtractor implements ResultSetExtractor<List<PentestScan>> {

        ScanDetailsResultSetExtractor(boolean b) {

        }

        @Override
        public List<PentestScan> extractData(ResultSet rs) throws SQLException, DataAccessException {
            Map<String, PentestScan> scansMap = new HashMap<>();
            List<PentestScan> scans = new LinkedList<>();
            while (rs.next()) {

                String scanId = rs.getString("scan_id");
                PentestScan scan = scansMap.get(scanId);

                if (scan == null) {
                    scan = new PentestScan();
                    scan.setScanId(scanId);
                    scan.setName(rs.getString("name"));
                    scan.setToolScanId(rs.getString("tool_scan_id"));
                    scan.setOccurrence((OccurrenceType.valueOf(rs.getString("occurrence"))));
                    scan.setDescription(rs.getString("description"));
                    scan.setRequestedBy(rs.getString("requested_by"));
                    scan.setRequestDate(rs.getTimestamp("request_date"));
                    scan.setScanDate(rs.getTimestamp("scan_date"));
                    scan.setAssetGroupId(rs.getString("asset_group_id"));
                    if (rs.getString("ip") == null) {
                        scan.setTargets(rs.getString("include_ips"));
                    } else {
                        scan.setTargets(rs.getString("ip"));
                    }

                    scan.setExcludeIps(rs.getString("exclude_ips"));
                    scan.setResultsSaved(rs.getBoolean("results_saved"));
                    scan.setScanRef(rs.getString("scan_ref"));
                    scan.setReportId(rs.getString("report_id"));
                    scan.setScheduled(rs.getBoolean("is_scheduled"));
                    scan.setMinRiskLevel(rs.getInt("min_risk_level"));
                    scan.setCompletionDate(rs.getTimestamp("completion_date"));
                    scan.setMail(rs.getString("mail"));
                    scan.setUpdateOperatingSystem(rs.getBoolean("update_operating_system"));
                    
                    scan.setSslScan(rs.getBoolean("ssl_scan"));
                    scan.setSslScanPorts(rs.getString("ssl_scan_ports"));
                    if (!BizzyUtil.isEmpty(rs.getString("status"))) {
                        scan.setStatus(ScanStatus.valueOf(rs.getString("status")));
                    }

                    if (!BizzyUtil.isEmpty(rs.getString("timezone"))) {
                        PentestTimezone timezone = new PentestTimezone();
                        timezone.setValue(rs.getString("timezone"));
                        scan.setTimezone(timezone);
                    }

                    PentestScanner scanner = new PentestScanner();
                    scanner.setId(rs.getString("scanner_id"));
                    scan.setScanner(scanner);

                    try {
                        PentestPolicy policy = new PentestPolicy();
                        policy.setName(rs.getString("policy"));
                        policy.setId(rs.getString("policy_id"));
                        scan.setPolicy(policy);
                    } catch (Exception ex) {
                        //Nothing todo
                    }

                    Server server = new Server();
                    server.setSettingId(rs.getString("server_id"));
                    server.setDomain(rs.getString("domain"));
                    scan.setServer(server);
                    scan.setProduceSslCertificateResults(rs.getBoolean("produce_ssl_certificate_results"));
                    scan.setScanAggregation(rs.getBoolean("scan_aggregation"));

                    if (!BizzyUtil.isEmpty(rs.getString("source"))) {
                        scan.setSource(Source.valueOf(rs.getString("source")));
                        try {
                            ProjectDetails projectDetails = null;
                            switch (scan.getSource()) {
                                case FORTIFY:
                                    projectDetails = new ProjectDetails();
                                    projectDetails.setBuildTool(rs.getString("build_tool"));
                                    projectDetails.setProjectName(rs.getString("project_name"));
                                    projectDetails.setLanguageType(rs.getString("language"));
                                    projectDetails.setCommand(rs.getString("command"));
                                    projectDetails.setVcsId(rs.getString("vcs_id"));
                                    projectDetails.setRevision(rs.getString("revision"));
                                    projectDetails.setVcsPath(rs.getString("vcs_path"));
                                    break;
                                case CHECKMARX:
                                    projectDetails = new ProjectDetails();
                                    projectDetails.setProjectName(rs.getString("project_name"));
                                    projectDetails.setVcsId(rs.getString("vcs_id"));
                                    projectDetails.setRevision(rs.getString("revision"));
                                    projectDetails.setVcsPath(rs.getString("vcs_path"));
                                    break;
                                case SECURITY_CENTER:
                                    projectDetails = new ProjectDetails();
                                    projectDetails.setRepository(rs.getString("repository"));
                                    projectDetails.setPluginId(rs.getString("plugin_id"));
                                    break;
                                default:
                                    break;
                            }
                            scan.setProjectDetails(projectDetails);
                        } catch (SQLException ex) {
                        }
                    }
                    if (!BizzyUtil.isEmpty(rs.getString("scheduled_scan_id"))) {
                        ScheduledPentestScan scheduled = new ScheduledPentestScan();
                        scheduled.setUuid(rs.getString("scheduled_scan_id"));
                        scan.setScheduledPentestScan(scheduled);
                    }

                    Customer customer = new Customer();
                    customer.setCustomerId(rs.getString("customer_id"));

                    scan.setCustomer(customer);
                    scan.setAssetCount(rs.getInt("asset_count"));

                    scan.setScanProscriptiveTimeStart(rs.getString("scan_proscriptive_time_start"));
                    scan.setScanProscriptiveTimeEnd(rs.getString("scan_proscriptive_time_end"));
                    scan.setAutoClose(rs.getBoolean("auto_close"));
                    scan.setSyncScan(rs.getBoolean("sync_scan"));
                    scan.setCustomizedScan(rs.getBoolean("customized_scan"));                    
                    
                    scansMap.put(scan.getScanId(), scan);
                    scans.add(scan);
                } else {
                    String target = scan.getTargets();
                    target += ", " + rs.getString("ip");
                    scan.setTargets(target);
                }
            }
            return scans;
        }
    }
    
    class HostCountsResultSetExtractor implements ResultSetExtractor<List<AssetDiscovery>> {

        HostCountsResultSetExtractor(boolean b) {

        }

        @Override
        public List<AssetDiscovery> extractData(ResultSet rs) throws SQLException, DataAccessException {
            List<AssetDiscovery> scans = new LinkedList<>();
            while (rs.next()) {
                AssetDiscovery scan = new AssetDiscovery();
                scan.setId(rs.getString("scan_id"));
                scan.setActiveHostsCount(rs.getInt("active_host_count"));
                scan.setNewHostsCount(rs.getInt("new_host_count"));
                
                scans.add(scan);
            }
            return scans;
        }
    }

    class HostScanResultSetExtractor implements ResultSetExtractor<List<AssetDiscovery>> {

        HostScanResultSetExtractor(boolean b) {

        }

        @Override
        public List<AssetDiscovery> extractData(ResultSet rs) throws SQLException, DataAccessException {
            Map<String, AssetDiscovery> scansMap = new HashMap<>();
            List<AssetDiscovery> scans = new LinkedList<>();
            while (rs.next()) {

                String scanId = rs.getString("id");
                AssetDiscovery scan = scansMap.get(scanId);

                if (scan == null) {
                    scan = new AssetDiscovery();
                    scan.setId(scanId);
                    scan.setName(rs.getString("name"));
                    scan.setDescription(rs.getString("description"));
                    scan.setRequestedBy(rs.getString("requested_by"));
                    scan.setRequestDate(rs.getTimestamp("request_date"));
                    scan.setScanDate(rs.getTimestamp("scan_date"));
                    if (rs.getString("target").contains(",")) { // nyzde grnm bozmamak iin yapld.
                        var tempString = rs.getString("target").replaceAll(",", ", ");
                        scan.setTarget(tempString);
                    } else {
                        scan.setTarget(rs.getString("target"));
                    }
                    scan.setResultsSaved(rs.getBoolean("results_saved"));
                    scan.setScheduled(rs.getBoolean("scheduled"));
                    scan.setResultAction(rs.getString("result_action"));
                    scan.setPolicyId(rs.getString("policy_id"));
                    scan.setPolicyIdForScan(rs.getString("policy_id_for_scan"));
                    scan.setScannerIdForScan(rs.getString("scanner_id_for_scan"));
                    scan.setServerIdForScan(rs.getString("server_id_for_scan"));
                    scan.setTimezoneForScan(rs.getString("timezone_for_scan"));
                    scan.setAutoCloseForScan(rs.getBoolean("auto_close_for_scan"));
                    scan.setMinRiskLevel(rs.getInt("min_risk_level"));
                    scan.setMail(rs.getString("mail"));
                    scan.setAssetGroupId(rs.getString("asset_group_id"));
                    scan.setCompletionDate(rs.getTimestamp("completion_date"));
                    scan.setAlarmLevel(rs.getInt("alarm_level"));
                    scan.setExcludeIps(rs.getString("exclude_ips"));
                    scan.setAutoGroupAssign(rs.getBoolean("auto_grouping"));
                    scan.setScanProscriptiveTimeStart(rs.getString("scan_proscriptive_time_start"));
                    scan.setScanProscriptiveTimeEnd(rs.getString("scan_proscriptive_time_end"));
                    scan.setToolScanId(rs.getString("tool_scan_id"));
                    try {
                        scan.setLastScanId(rs.getString("last_scan_id"));
                    } catch (Exception ex) {
                        //Nothing todo
                    }
                    if (!BizzyUtil.isEmpty(rs.getString("status"))) {
                        scan.setStatus(ScanStatus.valueOf(rs.getString("status")));
                    }

                    if (!BizzyUtil.isEmpty(rs.getString("timezone"))) {
                        PentestTimezone timezone = new PentestTimezone();
                        timezone.setValue(rs.getString("timezone"));
                        scan.setTimezone(timezone);
                    }

                    PentestScanner scanner = new PentestScanner();
                    scanner.setId(rs.getString("scanner_id"));
                    scan.setScanner(scanner);

                    Server server = new Server();
                    server.setSettingId(rs.getString("server_id"));
                    server.setDomain(rs.getString("domain"));
                    scan.setServer(server);

                    if (!BizzyUtil.isEmpty(rs.getString("source"))) {
                        scan.setSource(Source.valueOf(rs.getString("source")));
                    }
                    if (!BizzyUtil.isEmpty(rs.getString("scheduled_passive_asset_scan_id"))) {
                        ScheduledAssetDiscovery scheduled = new ScheduledAssetDiscovery();
                        scheduled.setUuid(rs.getString("scheduled_passive_asset_scan_id"));
                        scan.setScheduledAssetDiscovery(scheduled);
                    }

                    Customer customer = new Customer();
                    customer.setCustomerId(rs.getString("customer_id"));

                    scan.setCustomer(customer);

                    scansMap.put(scan.getId(), scan);
                    scans.add(scan);
                }
            }
            return scans;
        }
    }
     class HostScanResultSetPassiveAssetScanExtractor implements ResultSetExtractor<List<AssetDiscovery>> {

        HostScanResultSetPassiveAssetScanExtractor(boolean b) {

        }

        @Override
        public List<AssetDiscovery> extractData(ResultSet rs) throws SQLException, DataAccessException {
            Map<String, AssetDiscovery> scansMap = new HashMap<>();
            List<AssetDiscovery> scans = new LinkedList<>();
            while (rs.next()) {
                String scanId = rs.getString("id");
                AssetDiscovery scan = scansMap.get(scanId);
                if (scan == null) {
                    scan = new AssetDiscovery();
                    scan.setId(scanId);
                    ScheduledAssetDiscovery scScan = new ScheduledAssetDiscovery();
                    if (!BizzyUtil.isEmpty(rs.getString("scheduled_passive_asset_scan_id"))) {  
                        scScan.setId(rs.getString("scheduled_passive_asset_scan_id")); 
                    }
                    scan.setScheduledAssetDiscovery(scScan);
                    scansMap.put(scan.getId(), scan);
                    scans.add(scan);
                }
            }
            return scans;
        }
    }

    class ScheduledHostScanResultSetExtractor implements ResultSetExtractor<List<ScheduledAssetDiscovery>> {

        ScheduledHostScanResultSetExtractor(boolean b) {

        }

        @Override
        public List<ScheduledAssetDiscovery> extractData(ResultSet rs) throws SQLException, DataAccessException {
            Map<String, ScheduledAssetDiscovery> scansMap = new HashMap<>();
            List<ScheduledAssetDiscovery> scans = new LinkedList<>();
            while (rs.next()) {

                String scanId = rs.getString("id");
                ScheduledAssetDiscovery scan = scansMap.get(scanId);

                if (scan == null) {
                    scan = new ScheduledAssetDiscovery();
                    scan.setId(scanId);
                    scan.setName(rs.getString("name"));
                    scan.setDescription(rs.getString("description"));
                    scan.setRequestedBy(rs.getString("requested_by"));
                    scan.setRequestDate(rs.getTimestamp("request_date"));
                    scan.setScanDate(rs.getTimestamp("scan_date"));
                    scan.setRecurrence(rs.getInt("recurrence"));
                    scan.setAlarmLevel(rs.getInt("alarm_level"));
                    scan.setTarget(rs.getString("target"));
                    scan.setResultsSaved(rs.getBoolean("results_saved"));
                    scan.setScheduled(rs.getBoolean("scheduled"));
                    scan.setResultAction(rs.getString("result_action"));
                    scan.setCompletedScanCount(rs.getInt("completed_scan_count"));
                    scan.setPolicyId(rs.getString("policy_id"));
                    scan.setPolicyIdForScan(rs.getString("policy_id_for_scan"));
                    scan.setServerIdForScan(rs.getString("server_id_for_scan"));
                    scan.setScannerIdForScan(rs.getString("scanner_id_for_scan"));
                    scan.setTimezoneForScan(rs.getString("timezone_for_scan"));
                    scan.setAutoCloseForScan(rs.getBoolean("auto_close_for_scan"));
                    scan.setMinRiskLevel(rs.getInt("min_risk_level"));
                    scan.setActive(rs.getBoolean("active"));
                    scan.setAssetGroupId(rs.getString("asset_group_id"));
                    scan.setAutoGroupAssign(rs.getBoolean("auto_grouping"));
                    scan.setParams(rs.getString("params"));
                    scan.setPorts(rs.getString("ports"));
                    scan.setExcludeIps(rs.getString("exclude_ips"));
                    scan.setScanProscriptiveTimeStart(rs.getString("scan_proscriptive_time_start"));
                    scan.setScanProscriptiveTimeEnd(rs.getString("scan_proscriptive_time_end"));
                    scan.setMail(rs.getString("mail"));
                    scan.setAutoCloseForScan(rs.getBoolean("auto_close_for_scan"));
                    if (!BizzyUtil.isEmpty(rs.getString("status"))) {
                        scan.setStatus(ScanStatus.valueOf(rs.getString("status")));
                    }

                    if (!BizzyUtil.isEmpty(rs.getString("timezone"))) {
                        PentestTimezone timezone = new PentestTimezone();
                        timezone.setValue(rs.getString("timezone"));
                        scan.setTimezone(timezone);
                    }

                    PentestScanner scanner = new PentestScanner();
                    scanner.setId(rs.getString("scanner_id"));
                    scan.setScanner(scanner);

                    Server server = new Server();
                    server.setSettingId(rs.getString("server_id"));
                    scan.setServer(server);

                    if (!BizzyUtil.isEmpty(rs.getString("source"))) {
                        scan.setSource(Source.valueOf(rs.getString("source")));
                    }
                    if (!BizzyUtil.isEmpty(rs.getString("launch"))) {
                        scan.setLaunch(ScanLaunch.valueOf(rs.getString("launch")));
                    }

                    Customer customer = new Customer();
                    customer.setCustomerId(rs.getString("customer_id"));

                    scan.setCustomer(customer);
                    scansMap.put(scan.getId(), scan);
                    scans.add(scan);
                }
            }
            return scans;
        }
    }

    class PentestScannerResultSetExtractor implements ResultSetExtractor<List<PentestScanner>> {

        private PentestScannerResultSetExtractor(boolean b) {

        }

        @Override
        public List<PentestScanner> extractData(ResultSet rs) throws SQLException, DataAccessException {
            List<PentestScanner> scanners = new LinkedList<>();
            while (rs.next()) {
                PentestScanner sc = new PentestScanner();
                sc.setId(rs.getString("id"));
                sc.setName(rs.getString("name"));

                scanners.add(sc);
            }
            return scanners;
        }
    }

    class PentestPolicyResultSetExtractor implements ResultSetExtractor<List<PentestPolicy>> {

        private PentestPolicyResultSetExtractor(boolean b) {

        }

        @Override
        public List<PentestPolicy> extractData(ResultSet rs) throws SQLException, DataAccessException {
            List<PentestPolicy> policies = new LinkedList<>();
            while (rs.next()) {
                PentestPolicy policy = new PentestPolicy();
                policy.setId(rs.getString("id"));
                policy.setName(rs.getString("name"));
                policy.setAutoSelected(rs.getBoolean("auto_selected"));

                policies.add(policy);
            }
            return policies;
        }
    }

    public String getServerIdByName(String name) {

        Map params = new HashMap();
        String sql = "SELECT setting_id "
                + "FROM server "
                + "WHERE name = :name ";
        params.put("name", name);
        String result = jdbcTemplate.queryForObject(sql, params, String.class);

        return result;
    }

    public String getScannerIdByName(String name) {

        Map params = new HashMap();
        String sql = "SELECT id "
                + "FROM pentest_scanner "
                + "WHERE name = :name ";
        params.put("name", name);
        String result = jdbcTemplate.queryForObject(sql, params, String.class);

        return result;
    }

    public String getPolicyIdByName(String name) {

        Map params = new HashMap();
        String sql = "SELECT id "
                + "FROM pentest_policy "
                + "WHERE name = :name ";
        params.put("name", name);
        String result = jdbcTemplate.queryForObject(sql, params, String.class);

        return result;
    }

    public List<String> getScanAssetsByScanId(String scanId) {

        Map params = new HashMap();
        String sql = "SELECT scan_asset_id "
                + "FROM scan_asset "
                + "WHERE scan_id = :scanId ";
        params.put("scanId", scanId);
        List<String> result = jdbcTemplate.queryForList(sql, params, String.class);

        return result;
    }

    @Transactional
    public void saveAssetDiscoveryResults(List<AssetDiscoveryResult> result) {
        for (AssetDiscoveryResult item : result) {
            item.setId(BizzyUtil.generateGUID());
            String sql = "INSERT INTO passive_asset_scan_result "
                    + "(id, ip, operating_system, cpe, scan_id, mac, netbios) "
                    + "VALUES "
                    + "(:id, :ip, :operatingSystem, :osCPE, :scanId, :mac, :netbios) ";
            int rows = jdbcTemplate.update(sql, new CustomParameterSource(item));
            if (rows != 1) {
                throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
                };
            }

            for (Port port : item.getPorts()) {
                String portSql = "INSERT INTO passive_asset_scan_port_result "
                        + "(port_id, result_id, port_number, protocol, service, banner) "
                        + "SELECT :id, :resultId, :portNumber, :protocol, :service, :banner "
                        + "WHERE NOT EXISTS ("
                        + "SELECT * "
                        + "FROM passive_asset_scan_port_result "
                        + "WHERE port_number = :portNumber AND result_id= :resultId ) ";

                Map params = new HashMap();
                params.put("id", BizzyUtil.generateGUID());
                params.put("resultId", item.getId());
                params.put("portNumber", port.getPortNumber());
                params.put("protocol", port.getProtocol());
                params.put("service", port.getService());
                params.put("banner", port.getBanner());

                jdbcTemplate.update(portSql, params);

            }
        }
    }

    public int getRunningScanCount(DataTablesRequest dataTablesRequest, String customerId, String source, boolean isSsl) {

        Map params = new HashMap();
        String sql = "SELECT count(*) as count "
                + "FROM scan s "
                + "LEFT JOIN pentest_policy p "
                + "     ON (s.policy_id = p.id AND s.server_id = p.server_id) "
                + "WHERE customer_id= :customerId AND ( s.status = :status1 OR s.status = :status2 OR s.status = :status3 OR s.status = :status4) ";
        if (!source.equals("all")) {
            sql += " AND s.source = :sourceFilter ";
            params.put("sourceFilter", source);
        }
        if(isSsl){
            sql += " AND s.ssl_scan = true ";
        } else {
            sql += " AND s.ssl_scan = false ";
        }
        sql += createSearch(scanColumnNameMapper, dataTablesRequest, params);

        params.put("customerId", customerId);
        params.put("status1", ScanStatus.RUNNING.getValue());
        params.put("status2", ScanStatus.QUEUED.getValue());
        params.put("status3", ScanStatus.PAUSED.getValue());
        params.put("status4", ScanStatus.IMPORTING.getValue());
        Integer count = jdbcTemplate.queryForObject(sql, params, Integer.class);
        return count;

    }

    public int getRunningHostScanCount(String customerId) {

        Map params = new HashMap();
        String sql = "SELECT count(*) as count "
                + "FROM passive_asset_scan s "
                + "WHERE customer_id= :customerId AND (status='QUEUED' OR status='RUNNING') ";

        params.put("customerId", customerId);
        Integer count = jdbcTemplate.queryForObject(sql, params, Integer.class);
        return count;

    }

    public float getTotalRiskScoreByScanId(String id, String customerId) {

        Map params = new HashMap();
        String formula = getVulnerabilityFormulaSqlByCustomerId(customerId);
        String sql = "SELECT TRUNC (SUM( ";
        sql += formula + "),2) AS score "
                + "FROM scan_vulnerability sv	"
                + "	LEFT JOIN vulnerability v           "
                + "         ON sv.vulnerability_id = v.vulnerability_id  "
                + "	LEFT JOIN scan_asset asset "
                + "         ON sv.scan_asset_id = asset.scan_asset_id "
                + "     LEFT JOIN asset a "
                + "         ON asset.asset_id = a.asset_id "
                + "     LEFT JOIN scan s "
                + "         ON s.scan_id = asset.scan_id "
                + " WHERE 1=1 AND a.deleted = false AND s.scan_id= :svId ";
        params.put("svId", id);
        try {
            return (float) jdbcTemplate.queryForObject(sql, params, Float.class);
        } catch (Exception e) {
            return 0;
        }
    }

    public int getCompletedScanCount(String customerId) {

        Map params = new HashMap();
        params.put("source", Source.PENTEST.toString());
        String sql = "SELECT count(*) as count "
                + "FROM scan s "
                + "WHERE customer_id= :customerId AND hidden IS NOT true AND status='COMPLETED' AND source != :source ";

        params.put("customerId", customerId);
        Integer count = jdbcTemplate.queryForObject(sql, params, Integer.class);
        return count;

    }

    public int getCompletedHostScanCount(String customerId) {

        Map params = new HashMap();
        String sql = "SELECT count(*) as count "
                + "FROM passive_asset_scan s "
                + "WHERE customer_id= :customerId AND status='COMPLETED' ";

        params.put("customerId", customerId);
        Integer count = jdbcTemplate.queryForObject(sql, params, Integer.class);
        return count;

    }

    public Date getLastCompletedScanDateByScheduledScanId(String scheduledScanId) {

        Map params = new HashMap();
        String sql = "SELECT scan_date FROM scan WHERE scheduled_scan_id = :scheduledScanId ORDER BY scan_date DESC LIMIT 1";
        params.put("scheduledScanId", scheduledScanId);
        try {
            Date date = jdbcTemplate.queryForObject(sql, params, Date.class);
            return date;
        } catch (Exception ex) {
            return null;
        }

    }

    public String getLastCompletedScanStatusByScheduledScanId(String scheduledScanId) {

        Map params = new HashMap();
        String sql = "SELECT status FROM scan WHERE scheduled_scan_id = :scheduledScanId ORDER BY scan_date DESC LIMIT 1";
        params.put("scheduledScanId", scheduledScanId);
        try {
            String status = jdbcTemplate.queryForObject(sql, params, String.class);
            return status;
        } catch (Exception ex) {
            return null;
        }

    }

    public Date getLastCompletedHostScanDateByScheduledScanId(String scheduledScanId) {

        Map params = new HashMap();
        String sql = "SELECT scan_date FROM passive_asset_scan WHERE scheduled_passive_asset_scan_id = :scheduledScanId ORDER BY scan_date DESC LIMIT 1";
        params.put("scheduledScanId", scheduledScanId);
        try {
            Date date = jdbcTemplate.queryForObject(sql, params, Date.class);
            return date;
        } catch (Exception ex) {
            return null;
        }

    }

    public String getLastCompletedHostScanStatusByScheduledScanId(String scheduledScanId) {

        Map params = new HashMap();
        String sql = "SELECT status FROM passive_asset_scan WHERE scheduled_passive_asset_scan_id = :scheduledScanId ORDER BY scan_date DESC LIMIT 1";
        params.put("scheduledScanId", scheduledScanId);
        try {
            String status = jdbcTemplate.queryForObject(sql, params, String.class);
            return status;
        } catch (Exception ex) {
            return null;
        }

    }

    public String getFortifyCommand(String language) {
        Map params = new HashMap();
        String sql = "SELECT translate_code FROM fortify_commands WHERE language = :language";
        params.put("language", language);
        try {
            String command = jdbcTemplate.queryForObject(sql, params, String.class);
            return command;
        } catch (DataAccessException ex) {
            logger.log(LogLevel.ERROR, "Fortify komutu veritabanndan getirilirken hata olutu.", ex);
            return null;
        }
    }

    class RiskDistributionResultSetExtractor implements ResultSetExtractor<Map<Integer, Integer>> {

        private RiskDistributionResultSetExtractor(boolean b) {

        }

        @Override
        public Map<Integer, Integer> extractData(ResultSet rs) throws SQLException, DataAccessException {
            Map<Integer, Integer> risks = new HashMap<>();
            while (rs.next()) {
                risks.put(rs.getInt("risk_level"), rs.getInt("count"));
            }
            return risks;
        }
    }

    class ScanNamesResultSetExtractor implements ResultSetExtractor<LinkedHashMap<String, String>> {

        private ScanNamesResultSetExtractor(boolean b) {

        }

        @Override
        public LinkedHashMap<String, String> extractData(ResultSet rs) throws SQLException, DataAccessException {
            LinkedHashMap<String, String> scans = new LinkedHashMap<>();
            while (rs.next()) {
                scans.put(rs.getString("scan_id"), rs.getString("name"));
            }
            return scans;
        }
    }

    class ScanAssetResultSetExtractor implements ResultSetExtractor<List<ScanAsset>> {

        ScanAssetResultSetExtractor(boolean b) {

        }

        @Override
        public List<ScanAsset> extractData(ResultSet rs) throws SQLException, DataAccessException {
            List<ScanAsset> scanAssets = new LinkedList<>();
            while (rs.next()) {

                Asset asset = new Asset();
                asset.setAssetType(rs.getString("type"));
                asset.setOtherIps(BizzyUtil.parseCommaSeparatedStringAsList(rs.getString("other_ips")));
                asset.setIp(rs.getString("ip"));
                asset.setHostname(rs.getString("host"));
                if(!BizzyUtil.isEmpty(asset.getAssetType()) && asset.getAssetType().equals(AssetType.VIRTUAL_HOST.toString())
                && asset.getOtherIps() != null && !asset.getOtherIps().isEmpty() && IpOperationsUtil.validIP(asset.getOtherIps().get(0))) {
                    asset.setHostname(asset.getIp());
                    asset.setIp(asset.getOtherIps().get(0));
                }
                ScanAsset scanAsset = new ScanAsset();
                scanAsset.setScanAssetId(rs.getString("scan_asset_id"));
                scanAsset.setScanId(rs.getString("scan_id"));
                scanAsset.setAssetId(rs.getString("asset_id"));
                scanAsset.setScannedIp(asset.getIp());
                scanAsset.setScannedIpDecimal(rs.getLong("ip_decimal"));
                scanAsset.setHostname(asset.getHostname());
                scanAsset.setOperatingSystem(rs.getString("os"));
                scanAsset.setAsvComment(rs.getString("asv_comment"));
                scanAsset.setVulnCount(rs.getInt("count"));
                scanAssets.add(scanAsset);
            }
            return scanAssets;
        }
    }

    class ScanDiffResultSetExtractor implements ResultSetExtractor<List<ScanDiff>> {

        ScanDiffResultSetExtractor(boolean b) {

        }

        @Override
        public List<ScanDiff> extractData(ResultSet rs) throws SQLException {
            List<ScanDiff> differenceList = new LinkedList<>();
            while (rs.next()) {

                ScanDiff scanDiff = new ScanDiff();
                scanDiff.setName(rs.getString("name"));
                scanDiff.setRiskScores(rs.getString("riskScores"));
                scanDiff.setRiskLevels(rs.getString("riskLevels"));
                scanDiff.setIps(rs.getString("ips"));
                scanDiff.setScanIds(rs.getString("scanIds"));
                scanDiff.setPorts(rs.getString("ports"));
                scanDiff.setStatuses(rs.getString("statuses"));
                scanDiff.setProtocols(rs.getString("protocols"));
                differenceList.add(scanDiff);
            }
            return differenceList;
        }
    }

    class ScanDetailsRowMapper implements RowMapper<PentestScan> {

        @Override
        public PentestScan mapRow(ResultSet rs, int rowNum) throws SQLException {
            PentestScan scan = new PentestScan();
            scan.setScanId(rs.getString("scan_id"));
            scan.setName(rs.getString("name"));
            scan.setResultsSaved(rs.getBoolean("results_saved"));
            scan.setScanDate(rs.getTimestamp("scan_date"));
            scan.setRequestDate(rs.getTimestamp("request_date"));
            scan.setRequestedBy(rs.getString("requested_by"));
            scan.setCompletionDate(rs.getTimestamp("completion_date"));
            scan.setRecurrence(rs.getInt("recurrence"));

            scan.setSource(Source.valueOf(rs.getString("source")));

            Customer customer = new Customer();
            customer.setCustomerId(rs.getString("customer_id"));
            scan.setCustomer(customer);
            
            if(rs.getString("server_id") != null) {
                Server server = new Server();
                server.setSettingId(rs.getString("server_id"));
                scan.setServer(server);
            }
            return scan;
        }
    }

    public List<PentestScan> getAssetScanHistory(DataTablesRequest dataTablesRequest, String assetId, String customerId) {
        HashMap params = new HashMap();
        params.put("assetId", assetId);
        params.put("customerId", customerId);
        String sql = "SELECT s.scan_id, s.name as name, s.scan_date, s.source, pp.name as ppname, a.ip FROM scan as s LEFT JOIN scan_asset asset ON s.scan_id=asset.scan_id\n"
                + "LEFT JOIN asset a ON a.asset_id = asset.asset_id LEFT JOIN pentest_policy pp ON pp.id=s.policy_id AND s.server_id = pp.server_id WHERE a.asset_id=:assetId AND a.customer_id=:customerId ";
        if (dataTablesRequest != null) {
            sql += createLimit(dataTablesRequest, params);
        }
        List<PentestScan> result = jdbcTemplate.query(sql, params, new AssetScanHistoryExtractor(false));
        return result;
    }
    
    public List<PentestScan> getPassiveVulnerabilityHistory(String customerId, String ip, String pluginId, Integer port, String protocol) {
        Map params = new HashMap();
        params.put("ip", ip);
        params.put("pluginId", pluginId);
        params.put("customerId", customerId);
        String sql = "select s.scan_id, sv.active, s.name, sv.create_date, s.scan_date from scan_vulnerability sv "
                + "left join vulnerability v on v.vulnerability_id = sv.vulnerability_id "
                + "left join scan_asset sa on sa.scan_asset_id = sv.scan_asset_id "
                + "left join scan s on s.scan_id = sa.scan_id "
                + "left join asset a on a.asset_id = sa.asset_id "
                + "left join port p on p.asset_id = a.asset_id "
                + "where a.customer_id =:customerId and v.vuln_number =:pluginId and a.ip =:ip ";
        if (port != null && protocol != null) {
            sql += " and p.port_number =:port and p.protocol =:protocol ";
            params.put("port", port);
            params.put("protocol", protocol);
        }
        sql += "order by sv.create_date asc";
        List<PentestScan> result = jdbcTemplate.query(sql, params, new VulnerabilityScanHistoryExtractor(false));
        return result;
    }

    class AssetScanHistoryExtractor implements ResultSetExtractor<List<PentestScan>> {

        private AssetScanHistoryExtractor(boolean b) {

        }

        @Override
        public List<PentestScan> extractData(ResultSet rs) throws SQLException, DataAccessException {
            List<PentestScan> scans = new LinkedList<>();
            while (rs.next()) {
                String scanId = rs.getString("scan_id");
                PentestScan scan = new PentestScan();
                scan.setScanId(scanId);
                scan.setName(rs.getString("name"));
                scan.setScanDate(rs.getTimestamp("scan_date"));
                scan.setSource(Source.valueOf(rs.getString("source")));
                PentestPolicy pp = new PentestPolicy();
                pp.setName(rs.getString("ppname"));
                scan.setPolicy(pp);
                scans.add(scan);
            }
            return scans;
        }
    }
    
    class VulnerabilityScanHistoryExtractor implements ResultSetExtractor<List<PentestScan>> {

        private VulnerabilityScanHistoryExtractor(boolean b) {

        }

        @Override
        public List<PentestScan> extractData(ResultSet rs) throws SQLException, DataAccessException {
            List<PentestScan> scans = new LinkedList<>();
            while (rs.next()) {
                PentestScan scan = new PentestScan();
                scan.setScanId(rs.getString("scan_id"));
                scan.setName(EscapeUtil.escapeForHtml(rs.getString("name")));
                scan.setScanDate(rs.getTimestamp("scan_date"));
                scan.setCompletionDate(rs.getTimestamp("create_date"));
                scan.setActive(rs.getBoolean("active"));
                scans.add(scan);
            }
            return scans;
        }
    }

    public List<String> getDistinctSourceTypesByCustomerId(String customerId) {

        HashMap params = new HashMap();
        params.put("customerId", customerId);
        String sql = "SELECT s.source FROM scan s WHERE s.customer_id = :customerId "
                + "UNION "
                + "SELECT ss.source FROM scheduled_scan ss WHERE ss.customer_id = :customerId";
        List<String> result = jdbcTemplate.queryForList(sql, params);
        return result;

    }

    public List<PentestScan> getPentestScansByCustomerId(String customerId) {
        String sql = "SELECT s.scan_id, s.name "
                + "FROM scan s "
                + "WHERE s.customer_id =:customerId AND s.source = 'PENTEST' ";
        Map params = new HashMap();
        params.put("customerId", customerId);
        List<PentestScan> result = jdbcTemplate.query(sql, params, new ScanLessDetailsResultSetExtractor(false));
        return result;
    }

    public String isKbCategorySaved(String name) {
        try {
            String sql = "SELECT id "
                    + "FROM knowledge_base_category "
                    + "WHERE name= :name ";
            Map params = new HashMap();
            params.put("name", name);
            String catId = jdbcTemplate.queryForObject(sql, params, String.class);
            return catId;
        } catch (EmptyResultDataAccessException ex) {
            return null;
        }
    }

    public void saveScanProcessDetail(String scanId, String targetId, String toolScanId, String reportId) {
        String sql;
        if (toolScanId == null && reportId == null) {
            sql = "INSERT INTO scan_process "
                    + "(scan_id, target_id) "
                    + "VALUES "
                    + "(:scanId, :targetId) ";
        } else if (reportId == null) {
            sql = "UPDATE scan_process "
                    + "SET tool_scan_id= :toolScanId "
                    + "WHERE scan_id= :scanId AND (target_id= :targetId OR target_id IS NULL) ";
        } else {
            sql = "UPDATE scan_process "
                    + "SET report_id= :reportId "
                    + "WHERE scan_id= :scanId AND (target_id= :targetId OR target_id IS NULL) AND tool_scan_id= :toolScanId";
        }
        Map params = new HashMap();
        params.put("scanId", scanId);
        params.put("targetId", targetId);
        params.put("toolScanId", toolScanId);
        params.put("reportId", reportId);
        int rows = jdbcTemplate.update(sql, params);
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
    }

    public List<ScanProcess> getScanProcessDetail(String scanId, String targetId, String toolScanId, String reportId) {
        Map params = new HashMap();
        String sql = "SELECT scan_id, target_id, tool_scan_id, report_id FROM scan_process WHERE 1=1 ";
        if (scanId != null) {
            params.put("scanId", scanId);
            sql += " AND scan_id= :scanId ";
        }
        if (targetId != null) {
            params.put("targetId", targetId);
            sql += " AND target_id= :targetId ";
        }
        if (toolScanId != null) {
            params.put("toolScanId", toolScanId);
            sql += " AND tool_scan_id= :toolScanId ";
        }
        List<ScanProcess> result = jdbcTemplate.query(sql, params, new ScanProcessResultSetExtractor(false));
        return result;
    }

    class ScanProcessResultSetExtractor implements ResultSetExtractor<List<ScanProcess>> {

        ScanProcessResultSetExtractor(boolean b) {

        }

        @Override
        public List<ScanProcess> extractData(ResultSet rs) throws SQLException, DataAccessException {
            List<ScanProcess> scans = new LinkedList<>();
            while (rs.next()) {
                String scanId = rs.getString("scan_id");
                String targetId = rs.getString("target_id");
                String toolScanId = rs.getString("tool_scan_id");
                String reportId = rs.getString("report_id");
                ScanProcess scanProcess = new ScanProcess();
                scanProcess.setScanAssetId(scanId);
                scanProcess.setTargetId(targetId);
                scanProcess.setToolScanId(toolScanId);
                scanProcess.setReportId(reportId);
                scans.add(scanProcess);
            }
            return scans;
        }
    }

    public List<PentestScan> getScansByScheduledScanId(String id) {
        String sql = "SELECT * FROM scan WHERE scheduled_scan_id= :id  ORDER BY completion_date desc ";
        Map params = new HashMap();
        params.put("id", id);
        List<PentestScan> result = jdbcTemplate.query(sql, params, new ScansByScheduledScanIdResultSetExtractor(false));
        return result;
    }

    class ScansByScheduledScanIdResultSetExtractor implements ResultSetExtractor<List<PentestScan>> {

        ScansByScheduledScanIdResultSetExtractor(boolean b) {

        }

        @Override
        public List<PentestScan> extractData(ResultSet rs) throws SQLException, DataAccessException {
            List<PentestScan> scans = new LinkedList<>();
            while (rs.next()) {

                String scanId = rs.getString("scan_id");
                PentestScan scan = new PentestScan();
                scan.setScanId(scanId);
                scans.add(scan);
            }
            return scans;
        }
    }
    
    public void updateScanVulnerabilityDetails(ScanVulnerabilityDetails svd) {
        Map params = new HashMap();
        params.put("scanVulnId", svd.getScanVulnerabilityId());
        params.put("firstSeen", svd.getFirstSeen());
        params.put("lastSeen", svd.getLastSeen());
        params.put("vprScore", svd.getVprScore());
        String detailSql = "UPDATE scan_vulnerability_details "
            + "SET last_seen = :lastSeen, first_seen = :firstSeen, vpr_score = :vprScore "
            + "WHERE scan_vulnerability_id = :scanVulnId ";
        jdbcTemplate.update(detailSql, params);
        
        if(svd.getPluginLevel() != null) {
            params.put("pluginLevel", svd.getPluginLevel());
            String svSql = "UPDATE scan_vulnerability SET plugin_level = :pluginLevel "
                + "WHERE scan_vulnerability_id = :scanVulnId ";
            jdbcTemplate.update(svSql, params);
        }
    }
    
    /**
     * Otomatik ara kt sonularn tarama olarak kaydeder.
     *
     * @param assetList
     * @param scanId
     * @param source
     * @param createdBy tarama isteini oluturan kii createdBy olarak
     * veriliyor.
     * @return
     * @throws java.text.ParseException
     */
    public List<ScanAsset> saveScanResults(List<ScanAsset> assetList, String scanId, Source source, String createdBy) throws Exception {
        PentestScan scan = getScanById(scanId);

        // Tarama tarihini zafiyet tarihi olarak veriyoruz hangi taramadan geldiini belirlemek iin.
        Date createDate = scan.getScanDate();
        List<Label> labelList = null;
        
        try {
               String scanlabelSql =  " select vl.label from vulnerability_label vl " +
                            " left join scan_label  sl on sl.label_id = vl.label_id  " +
                            " where sl.scan_id = :scanId ";
             Map parameter = new HashMap();  
            parameter.put("scanId", scanId); 
            labelList = jdbcTemplate.query(scanlabelSql, parameter, new ScanLabelResultSetExtractor(false));
        } 
         catch (Exception ex) {
            logger.log(LogLevel.ERROR, "Tarama etiketlerini almada hata!");
        }
     
        for (ScanAsset asset : assetList) {
            String scanAssetId = getScanAssetIdByIp(asset.getScannedIp(), scan.getScanId());
            String assetId = getAssetIdByScanAsset(scanAssetId);

            for (ScanVulnerability sv : asset.getScanVulnerabilityList()) {
                Vulnerability vuln = sv.getVulnerability();
                if(labelList != null) {
                     vuln.setLabels(labelList);
                }
               
                /*if (!source.equals(Source.PENTEST)) {
                    Category emptyCat = new Category();
                    vuln.setCategory(emptyCat);
                }*/
                String portId = "";

                String vulnId = "";
                if (!source.equals(Source.EXCEL)) {
                    vulnId = isVulnerabilitySaved(vuln.getVulnNumber(), Source.valueOf(vuln.getSource()));
                }

                //Burp'te port ilikisi yok. Nessus'ta ve Qualys'te port kayd da ekleniyor. Ayrca Nessus ve OpenVas'ta kategori kayd da ekleniyor.
                switch (source) {
                    case QUALYS:
                        Port port = sv.getPort();
                        if (port != null) {
                            if (port.getPortNumber() == null) {
                                sv.getPort().setPortId(null);
                            } else {
                                portId = isPortSaved(port.getPortNumber(), port.getProtocol(), assetId);
                            }

                            //Port kaytl deil ise kaydedilir.
                            if (BizzyUtil.isEmpty(portId)) {
                                String portSql = "INSERT INTO port "
                                        + "(port_id, port_number, protocol, service, asset_id, create_date, created_by) "
                                        + "VALUES "
                                        + "(:portId, :portNumber, :protocol, :service, :assetId, :createDate, :createdBy) ";
                                portId = BizzyUtil.generateGUID();
                                port.setPortId(portId);
                                port.setAssetId(assetId);
                                port.setCreateDate(createDate);
                                port.setCreatedBy(createdBy);
                                if (!BizzyUtil.isEmpty(port.getProtocol())) {
                                    port.setProtocol(port.getProtocol().toUpperCase());
                                }
                                int portRows = jdbcTemplate.update(portSql, new CustomParameterSource(port));
                                if (portRows != 1) {
                                    throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + portRows) {
                                    };
                                }
                            } else {      //Port kaytl ise service bilgisini gncelliyoruz.
                                Port saved = customerDao.getPortById(portId);
                                if (!BizzyUtil.isEmpty(port.getService()) && BizzyUtil.isEmpty(saved.getService())) {
                                    saved.setService(port.getService());
                                    saved.setUpdatedBy(createdBy);
                                    customerDao.updatePort(port);
                                }
                            }
                        }
                        break;
                    default:
                        //Kategori kaytl deilse kaydeder. Kaydetmesi iptal edilmi.
                        if (source.equals(Source.NESSUS) || source.equals(Source.OPENVAS) || source.equals(Source.APPSCAN) || source.equals(Source.FORTIFY)) {
                            vuln.getCategory().setId(vuln.getCategory().getId());
                        }
                        if (source.equals(Source.BURP)) {
                            //update port 
                            Port newPort = new Port();
                            if (sv.getHost().getName().replace(":/", "").contains(":")) {
                                String portInfo = sv.getHost().getName().split(":")[1];
                                newPort.setPortNumber(Integer.parseInt(portInfo));
                                newPort.setAssetId(asset.getAssetId());
                                newPort.setProtocol("TCP");
                                if (portInfo.equals("80")) {
                                    newPort.setService("http");
                                } else if (portInfo.equals("443")) {
                                    newPort.setService("https");
                                    sv.setPort(newPort);
                                }
                            } else if (sv.getHost().getName().contains("https")) {
                                newPort.setPortNumber(443);
                                newPort.setService("https");
                                newPort.setProtocol("TCP");
                                sv.setPort(newPort);

                            } else if (sv.getHost().getName().contains("http")) {
                                newPort.setPortNumber(80);
                                newPort.setService("http");
                                newPort.setProtocol("TCP");
                                sv.setPort(newPort);
                            }
                        }
                        if (source.equals(Source.PENTEST)) {
                            // Pentest ktsndaki kategori kaytl deilse kaydedilir. Kaytlysa mevcutla eletirilir.
                            if (vuln.getCategory() != null) {
                                String catId = isKbCategorySaved(vuln.getCategory().getName());
                                if (catId == null && vuln.getCategory().getName() != null && !vuln.getCategory().getName().equals("")) {
                                    tr.biznet.bizzy.service.kb.domain.Category cat = new tr.biznet.bizzy.service.kb.domain.Category();
                                    cat.setName(vuln.getCategory().getName());
                                    User user = HttpUtil.getUser();
                                    cat.setCreatedBy(user);
                                    cat.setCreationDate(createDate);
                                    kbService.saveCategory(cat);
                                    String savedId = isKbCategorySaved(vuln.getCategory().getName());
                                    Category catIdNew = new Category();
                                    catIdNew.setId(savedId);
                                    sv.getVulnerability().setCategory(catIdNew);
                                } else {
                                    Category catIdNew = new Category();
                                    catIdNew.setId(catId);
                                    sv.getVulnerability().setCategory(catIdNew);
                                }
                            }
                        }

                        port = sv.getPort();
                        if (port != null) {
                            if (port.getPortNumber() == null) {
                                sv.getPort().setPortId(null);
                            } else {
                                portId = isPortSaved(port.getPortNumber(), port.getProtocol(), assetId);
                            }
                            if (source.equals(Source.EXCEL)) {
                                vuln.getPort().setPortId(portId);
                            }
                            //Port kaytl deil ise kaydedilir.
                            if (BizzyUtil.isEmpty(portId)) {
                                String portSql = "INSERT INTO port "
                                        + "(port_id, port_number, protocol, service, asset_id, create_date, created_by) "
                                        + "VALUES "
                                        + "(:portId, :portNumber, :protocol, :service, :assetId, :createDate, :createdBy) ";
                                portId = BizzyUtil.generateGUID();
                                port.setPortId(portId);
                                port.setAssetId(assetId);
                                port.setCreateDate(createDate);
                                port.setCreatedBy(createdBy);
                                if (!BizzyUtil.isEmpty(port.getProtocol())) {
                                    port.setProtocol(port.getProtocol().toUpperCase());
                                }
                                int portRows = jdbcTemplate.update(portSql, new CustomParameterSource(port));
                                if (portRows != 1) {
                                    throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + portRows) {
                                    };
                                }
                            } else {      //Port kaytl ise service bilgisini gncelliyoruz.
                                Port saved = customerDao.getPortById(portId);
                                if (!BizzyUtil.isEmpty(port.getService()) && BizzyUtil.isEmpty(saved.getService())) {
                                    saved.setService(port.getService());
                                    saved.setUpdatedBy(createdBy);
                                    customerDao.updatePort(saved);
                                }
                            }
                        }
                        break;
                }

                // Kaytl deil ise zafiyeti kaydeder.
                if (BizzyUtil.isEmpty(vulnId)) {
                    vulnId = BizzyUtil.generateGUID();
                    vuln.setVulnerabilityId(vulnId);
                    if (vuln.getCreateDate() == null) {
                        vuln.setCreateDate(createDate);
                    }
                    vuln.setCreatedBy(createdBy);
                    if (vuln.getCvssTemporalScore() == null) {
                        vuln.setCvssTemporalScore(vuln.getCvssBaseScore());
                    }

                    String sql = "INSERT INTO vulnerability "
                            + "(vulnerability_id, name, solution, cvss_base_score, create_date, "
                            + "risk_level, type, description, cvss3_base_score, cvss3_temporal_score,  "
                            + "cvss_temporal_score, created_by, pci_status, has_malware, has_public_exploit, "
                            + "source, vuln_number, last_update, diagnosis, consequence, vulnerability_references, effect, root_cause, problem_area, owasp, vulnerability_category_id, plugin_category, plugin_type) "
                            + "VALUES "
                            + "(:vulnerabilityId, :name, :solution, :cvssBaseScore, :createDate, "
                            + ":riskLevel, :type, :description, :cvss3BaseScore, :cvss3TemporalScore, "
                            + ":cvssTemporalScore, :createdBy, :pciStatus, :hasMalware, :hasPublicExploit, "
                            + ":source, :vulnNumber, :lastUpdate, :diagnosis, :consequence, :references, :effect, :rootCause, :problemArea, :owasp, :category.id, :pluginCategory, :pluginType) ";
                    int rows = jdbcTemplate.update(sql, new CustomParameterSource(vuln));
                    if (rows != 1) {
                        throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
                        };
                    }
                } else {
                    vuln.setVulnerabilityId(vulnId);
                    vuln.setUpdateDate(new Date());
                    vuln.setUpdatedBy(createdBy);

                    //Kaytl ise exploit ve malware bilgilerini gncelliyoruz, nk bu kolonlarn default deeri false. 30.03.2018
                    String updateExploitsSql = "UPDATE vulnerability SET has_malware= :hasMalware, has_public_exploit= :hasPublicExploit, update_Date = :updateDate, updated_By = :updatedBy, plugin_category = :pluginCategory "
                            + "WHERE vuln_number= :vulnNumber ";
                    Map updateVulnParam = new HashMap();
                    updateVulnParam.put("hasMalware", vuln.isHasMalware());
                    updateVulnParam.put("hasPublicExploit", vuln.isHasPublicExploit());
                    updateVulnParam.put("updateDate", vuln.getUpdateDate());
                    updateVulnParam.put("updatedBy", vuln.getUpdatedBy());
                    updateVulnParam.put("vulnNumber", vuln.getVulnNumber());
                    updateVulnParam.put("pluginCategory", vuln.getPluginCategory());
                    jdbcTemplate.update(updateExploitsSql, updateVulnParam);
                }

                //Zafiyet sonucu ve tarama ile ilikisi scan_vulnerability tablosuna kaydedilir.
                String scanVulnId;
                if (sv.getScanVulnerabilityId() == null) {
                    scanVulnId = BizzyUtil.generateGUID();
                } else {
                    scanVulnId = sv.getScanVulnerabilityId();
                }
                sv.setScanVulnerabilityId(scanVulnId);
                sv.setCreatedBy(createdBy);
                String scanVulnSql = "INSERT INTO scan_vulnerability "
                        + "(scan_vulnerability_id, vulnerability_id, scan_asset_id, result, port_id, create_date, created_by, source, active, plugin_id, likelihood, social_impact, has_root, plugin_level) "
                        + "VALUES "
                        + "(:scanVulnId, :vulnId, :scanAssetId, :result, :portId, :createDate, :created_by, :source, :active, :pluginId, :likelihood, :socialImpact, :hasRootPrivilege, :pluginLevel) ";
                Map vulnParam = new HashMap();
                vulnParam.put("scanVulnId", scanVulnId);
                vulnParam.put("vulnId", vulnId);
                vulnParam.put("scanAssetId", scanAssetId);
                vulnParam.put("result", sv.getResult());
                if (sv.getCreateDate() == null) {
                    vulnParam.put("createDate", createDate);
                } else {
                    vulnParam.put("createDate", sv.getCreateDate());
                }
                vulnParam.put("source", sv.getSource());
                vulnParam.put("created_by", createdBy);
                vulnParam.put("active", sv.isActive());
                vulnParam.put("pluginId", sv.getPluginId());
                vulnParam.put("hasRootPrivilege", sv.isHasRootPrivilege());
                vulnParam.put("likelihood", sv.getLikelihood());
                vulnParam.put("socialImpact", sv.getSocialImpact());
                vulnParam.put("pluginLevel", sv.getPluginLevel());
                if (BizzyUtil.isEmpty(portId)) {
                    portId = null;
                }
                vulnParam.put("portId", portId);
                jdbcTemplate.update(scanVulnSql, vulnParam);
                
                //Fortify gibi sdlc srelerinde svye ait path, line gibi bilgilerin kaydedilmesi
                if(sv.getSvDetails() != null) {
                    Map detailParams = new HashMap();
                    detailParams.put("scanVulnId", sv.getScanVulnerabilityId());
                    detailParams.put("path", sv.getSvDetails().getPath());
                    detailParams.put("lineNumber", sv.getSvDetails().getLineNumber());
                    detailParams.put("firstSeen", sv.getSvDetails().getFirstSeen()); 
                    detailParams.put("lastSeen", sv.getSvDetails().getLastSeen());
                    detailParams.put("vprScore", sv.getSvDetails().getVprScore());
                    String detailSql = "INSERT INTO scan_vulnerability_details "
                        + "(scan_vulnerability_id, path, line_number, first_seen, last_seen, vpr_score) "
                        + "VALUES "
                        + "(:scanVulnId, :path, :lineNumber, :firstSeen, :lastSeen, :vprScore) ";
                    jdbcTemplate.update(detailSql, detailParams);
                }

                if (vuln.getLabels() != null) {
                    if (!vuln.getLabels().isEmpty()) {
                        //Etiket ilikileri kaydedilir.

                        String labelSelectSql = "SELECT label_id FROM vulnerability_label WHERE label = :name AND (customer_id = :customerId OR customer_id IS NULL)";

                        for (Label label : vuln.getLabels()) {
                            Map params = new HashMap();
                            params.put("name", label.getName());
                            params.put("customerId", scan.getCustomer().getCustomerId());
                            try {
                                String labelId = jdbcTemplate.queryForObject(labelSelectSql, params, String.class);
                                if (labelId != null) {
                                    label.setLabelId(labelId);
                                }
                            } catch (Exception e) {
                                logger.log(LogLevel.INFO, "Veritabannda kayt yok.", e);
                                label.setLabelId(null);
                            }
                        }
                        

                        // label kaytl deilse kaydedilir.
                        String labelSql = "INSERT INTO vulnerability_label "
                                + "(label_id, label, creator, create_date, customer_id) "
                                + "SELECT :labelId, :name, :user, :createDate, :customerId "
                                + "WHERE NOT EXISTS ("
                                + "SELECT label "
                                + "FROM vulnerability_label "
                                + "WHERE label = :name AND (customer_id = :customerId OR customer_id IS NULL)) ";

                        Map[] paramsArr = new Map[vuln.getLabels().size()];
                        int index = 0;
                        for (Label label : vuln.getLabels()) {
                            Map param = new HashMap();
                            if (label.getLabelId() == null) {
                                label.setLabelId(BizzyUtil.generateGUID());
                            }
                            param.put("labelId", label.getLabelId());
                            param.put("name", label.getName());
                            param.put("user", createdBy);
                            param.put("createDate", createDate);
                            param.put("customerId", scan.getCustomer().getCustomerId());
                            paramsArr[index] = param;

                            index++;
                        }
                        int[] labelRows = jdbcTemplate.batchUpdate(labelSql, paramsArr);
                        for (int i = 0; i < labelRows.length; i++) {
                            if (labelRows[i] != 1 && labelRows[i] != 0) {
                                throw new DataAccessException("Unexpected rows. Expected: 1 or 0 Rows: " + labelRows[i]) {
                                };
                            }
                        }

                        // label zafiyet ilikileri kaydedilir.
                        String labelRelSql = "INSERT INTO vulnerability_label_relations "
                                + "(relation_id, vulnerability_id, label, label_id, scan_vulnerability_id) "
                                + "VALUES "
                                + "(:relationId, :vulnerabilityId, :label, :labelId, :scanVulnerabilityId) ";
                        paramsArr = new Map[vuln.getLabels().size()];
                        index = 0;
                        for (Label label : vuln.getLabels()) {
                            Map param = new HashMap();
                            param.put("relationId", BizzyUtil.generateGUID());
                            param.put("vulnerabilityId", vuln.getVulnerabilityId());
                            param.put("label", label.getName());
                            param.put("labelId", label.getLabelId());
                            param.put("scanVulnerabilityId", sv.getScanVulnerabilityId());
                            paramsArr[index] = param;

                            index++;
                        }
                        int[] labelRelRows = jdbcTemplate.batchUpdate(labelRelSql, paramsArr);
                        for (int i = 0; i < labelRelRows.length; i++) {
                            if (labelRelRows[i] != 1 && labelRelRows[i] != 0) {
                                throw new DataAccessException("Unexpected rows. Expected: 1 or 0 Rows: " + labelRelRows[i]) {
                                };
                            }
                        }
                    }
                }
                if (sv.getWebApps() != null) {
                    if (!sv.getWebApps().isEmpty()) {
                        for (WebApp webApp : sv.getWebApps()) {
                            String id = customerDao.saveWebApp(webApp);
                            customerDao.updateWebAppScanVulnerabilityIdByWebAppId(id, sv.getScanVulnerabilityId());
                        }
                    }
                }
                //Cve dzenler.
                if (vuln.getCveIdList() != null) {
                    String cveSql = "INSERT INTO cve "
                            + "(cve_id, cve_url) "
                            + "SELECT :cveId, :cveUrl "
                            + "WHERE NOT EXISTS ("
                            + "SELECT cve_id FROM cve WHERE cve_id = :cveId ) ";
                    Map[] paramsArr = new Map[vuln.getCveIdList().size()];
                    int index = 0;
                    for (CveId cve : vuln.getCveIdList()) {
                        Map param = new HashMap();
                        param.put("cveId", cve.getId());
                        param.put("cveUrl", cve.getUrl());
                        paramsArr[index] = param;
                        index++;
                    }
                    int[] cveRow = jdbcTemplate.batchUpdate(cveSql, paramsArr);
                    for (int i = 0; i < cveRow.length; i++) {
                        if (cveRow[i] != 1 && cveRow[i] != 0) {
                            throw new DataAccessException("Unexpected rows. Expected: 1 or 0 Rows: " + cveRow[i]) {
                            };
                        }
                    }

                    String cveRelSql = "INSERT INTO vulnerability_cve "
                            + "(vulnerability_cve_id, vulnerability_id, cve_id) "
                            + "VALUES "
                            + "(:relationId, :vulnerabilityId, :cveId) ";
                    paramsArr = new Map[vuln.getCveIdList().size()];
                    index = 0;
                    for (CveId cve : vuln.getCveIdList()) {
                        Map param = new HashMap();
                        param.put("relationId", BizzyUtil.generateGUID());
                        param.put("vulnerabilityId", vuln.getVulnerabilityId());
                        param.put("cveId", cve.getId());
                        paramsArr[index] = param;

                        index++;
                    }
                    int[] cveRelRows = jdbcTemplate.batchUpdate(cveRelSql, paramsArr);
                    for (int i = 0; i < cveRelRows.length; i++) {
                        if (cveRelRows[i] != 1 && cveRelRows[i] != 0) {
                            throw new DataAccessException("Unexpected rows. Expected: 1 or 0 Rows: " + cveRelRows[i]) {
                            };
                        }
                    }
                }

                //Cwe dzenler.
                if (vuln.getCweIdList() != null) {
                    String cweSql = "INSERT INTO cwe "
                            + "(cwe_id, cwe_url) "
                            + "SELECT :cweId, :cweUrl "
                            + "WHERE NOT EXISTS ("
                            + "SELECT cwe_id FROM cwe WHERE cwe_id = :cweId ) ";
                    Map[] paramsArr = new Map[vuln.getCweIdList().size()];
                    int index = 0;
                    for (CweId cwe : vuln.getCweIdList()) {
                        Map param = new HashMap();
                        param.put("cweId", cwe.getId());
                        param.put("cweUrl", cwe.getUrl());
                        paramsArr[index] = param;
                        index++;
                    }
                    int[] cweRow = jdbcTemplate.batchUpdate(cweSql, paramsArr);
                    for (int i = 0; i < cweRow.length; i++) {
                        if (cweRow[i] != 1 && cweRow[i] != 0) {
                            throw new DataAccessException("Unexpected rows. Expected: 1 or 0 Rows: " + cweRow[i]) {
                            };
                        }
                    }

                    String cweRelSql = "INSERT INTO vulnerability_cwe "
                            + "(vulnerability_cwe_id, vulnerability_id, cwe_id) "
                            + "VALUES "
                            + "(:relationId, :vulnerabilityId, :cweId) ";
                    paramsArr = new Map[vuln.getCweIdList().size()];
                    index = 0;
                    for (CweId cwe : vuln.getCweIdList()) {
                        Map param = new HashMap();
                        param.put("relationId", BizzyUtil.generateGUID());
                        param.put("vulnerabilityId", vuln.getVulnerabilityId());
                        param.put("cweId", cwe.getId());
                        paramsArr[index] = param;

                        index++;
                    }
                    int[] cweRelRows = jdbcTemplate.batchUpdate(cweRelSql, paramsArr);
                    for (int i = 0; i < cweRelRows.length; i++) {
                        if (cweRelRows[i] != 1 && cweRelRows[i] != 0) {
                            throw new DataAccessException("Unexpected rows. Expected: 1 or 0 Rows: " + cweRelRows[i]) {
                            };
                        }
                    }
                }
            }
        }

        // tarama tablosunda results_saved alann gnceller.
        setScanResultsSaved(scan);

        return assetList;
    }
    
    public List<ScanAsset> saveSyncSecurityCenterScanResults(List<ScanAsset> assetList, List<Port> portList, List<Vulnerability> vulnList, List<ScanVulnerability> svList, List<CveId> cveIdList, List<CweId> cweIdList, PentestScan scan) throws Exception {
        Date createDate = scan.getScanDate();
        String createdBy = scan.getRequestedBy();

        
        BeanPropertySqlParameterSource[] parameterSources;
        int index;
        if(!portList.isEmpty()) {
            String portSql = "INSERT INTO port "
                    + "(port_id, port_number, protocol, service, asset_id, create_date, created_by) "
                    + "SELECT "
                    + ":portId, :portNumber, :protocol, :service, :assetId, :createDate, :createdBy "
                    + "WHERE NOT EXISTS (SELECT port_id FROM port WHERE port_number = :portNumber AND protocol = :protocol AND asset_id = :assetId) ";
            parameterSources = new BeanPropertySqlParameterSource[portList.size()];
            index = 0;
            for (Port port : portList) {
                parameterSources[index] = new CustomParameterSource(port);
                index++;
            }
            jdbcTemplate.batchUpdate(portSql, parameterSources);
        }
        if(!vulnList.isEmpty()) {
            String vulnSql = "INSERT INTO vulnerability "
                + "(vulnerability_id, name, solution, cvss_base_score, create_date, "
                + "risk_level, type, description, cvss3_base_score, cvss3_temporal_score,  "
                + "cvss_temporal_score, created_by, pci_status, has_malware, has_public_exploit, "
                + "source, vuln_number, last_update, diagnosis, consequence, vulnerability_references, "
                + "effect, root_cause, problem_area, owasp, vulnerability_category_id, plugin_category) "
                + "SELECT "
                + ":vulnerabilityId, :name, :solution, :cvssBaseScore, :createDate, "
                + ":riskLevel, :type, :description, :cvss3BaseScore, :cvss3TemporalScore, "
                + ":cvssTemporalScore, :createdBy, :pciStatus, :hasMalware, :hasPublicExploit, "
                + ":source, :vulnNumber, :lastUpdate, :diagnosis, :consequence, :references, "
                + ":effect, :rootCause, :problemArea, :owasp, :category.id, :pluginCategory "
                + "WHERE NOT EXISTS (SELECT vulnerability_id FROM vulnerability WHERE vuln_number= :vulnNumber and source= :source) ";
            parameterSources = new BeanPropertySqlParameterSource[vulnList.size()];
            index = 0;
            for (Vulnerability vuln : vulnList) {
                parameterSources[index] = new CustomParameterSource(vuln);
                index++;
            }
            jdbcTemplate.batchUpdate(vulnSql, parameterSources);
        }
        if(!svList.isEmpty()) {
            String scanVulnSql = "INSERT INTO scan_vulnerability "
                    + "(scan_vulnerability_id, vulnerability_id, scan_asset_id, result, port_id, create_date, created_by, source, active, plugin_id, likelihood, social_impact, has_root, plugin_level) "
                    + "VALUES "
                    + "(:scanVulnerabilityId, :vulnerabilityId, :scanAssetId, :result, :portId, :createDate, :createdBy, :source, :active, :pluginId, :likelihood, :socialImpact, :hasRootPrivilege, :pluginLevel) ";
            parameterSources = new BeanPropertySqlParameterSource[svList.size()];
            index = 0;
            for (ScanVulnerability sv : svList) {
                parameterSources[index] = new CustomParameterSource(sv);
                index++;
            }
            jdbcTemplate.batchUpdate(scanVulnSql, parameterSources);
        }
        if(!cveIdList.isEmpty()) {
            String cveSql = "INSERT INTO cve "
                    + "(cve_id, cve_url) "
                    + "SELECT :id, :url "
                    + "WHERE NOT EXISTS ("
                    + "SELECT cve_id FROM cve WHERE cve_id = :id ) ";
            parameterSources = new BeanPropertySqlParameterSource[cveIdList.size()];
            index = 0;
            for (CveId cveId : cveIdList) {
                parameterSources[index] = new CustomParameterSource(cveId);
                index++;
            }
            jdbcTemplate.batchUpdate(cveSql, parameterSources);

            String cveRelSql = "INSERT INTO vulnerability_cve "
                    + "(vulnerability_cve_id, vulnerability_id, cve_id) "
                    + "VALUES "
                    + "(:relationId, :vulnerabilityId, :id) ";
            jdbcTemplate.batchUpdate(cveRelSql, parameterSources);
        }
        if(!cweIdList.isEmpty()) {
            String cweSql = "INSERT INTO cwe "
                    + "(cwe_id, cwe_url) "
                    + "SELECT :id, :url "
                    + "WHERE NOT EXISTS ("
                    + "SELECT cwe_id FROM cwe WHERE cwe_id = :id ) ";
            parameterSources = new BeanPropertySqlParameterSource[cweIdList.size()];
            index = 0;
            for (CweId cweId : cweIdList) {
                parameterSources[index] = new CustomParameterSource(cweId);
                index++;
            }
            jdbcTemplate.batchUpdate(cweSql, parameterSources);

            String cweRelSql = "INSERT INTO vulnerability_cwe "
                    + "(vulnerability_cwe_id, vulnerability_id, cwe_id) "
                    + "VALUES "
                    + "(:relationId, :vulnerabilityId, :id) ";
            jdbcTemplate.batchUpdate(cweRelSql, parameterSources);
        }

        // tarama tablosunda results_saved alann gnceller.
        setScanResultsSaved(scan);

        return assetList;
    }

    public String getVulnerabilityFormulaSqlByCustomerId(String customerId) {

        String sql = "SELECT vulnerabilityScoreSqlFormula(:customerId)";
        Map params = new HashMap();
        params.put("customerId", customerId);
        return jdbcTemplate.queryForObject(sql, params, String.class);

    }

    /**
     * Pentester takvimine yeni bir plan eklendii zaman veritabanna kaydeden
     * method.
     *
     * @param schedule
     * @param userId
     * @throws java.text.ParseException
     */
    public void saveCalendarEntry(Schedule schedule, String userId) throws ParseException {
        String sql = "INSERT INTO calendar (id,calendar_id,title,body,start_date,end_date,state,isAllDay,location,user_id) VALUES (:id,:calendar_id,:title,:body,:start,:end,:state,:isAllDay,:location,:userId) ";
        Map params = new HashMap();
        params.put("id", schedule.getId());
        params.put("calendar_id", "1");
        params.put("title", schedule.getTitle());
        params.put("body", schedule.getBody());
        params.put("start", new SimpleDateFormat("yyyy-MM-dd HH:mm").parse(schedule.getStart()));
        params.put("end",  new SimpleDateFormat("yyyy-MM-dd HH:mm").parse(schedule.getEnd()));
        params.put("state",  schedule.getState());
        params.put("isAllDay", schedule.isAllDay());
        params.put("location", schedule.getLocation());
        params.put("userId", userId);
        int rows = jdbcTemplate.update(sql, params);
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
        //Attende tablosunda kaytlarn oluturulmas.
        saveScheduleAttendees(schedule.getId(), schedule.getAttendees());
        //Proje bilgilerinin kaydedilmesi
        //TODO: Kaldrlacak
        //saveCalendarProject(schedule.getLocation(), schedule.getBgColor());
    }
    /**
     * Yeni oluturulan 
     * @param scheduleId
     * @param attendees 
     */
    public void saveScheduleAttendees(String scheduleId, String[] attendees) {
        if(attendees.length > 0) {
            for(String attendee : attendees) {
                Map params = new HashMap();
                String sql = "INSERT INTO calendar_attendees (id,username) VALUES (:id,:username) ";
                params.put("id", scheduleId);
                params.put("username", attendee);
                jdbcTemplate.update(sql, params);
            }
        }
    }

    /**
     * Pentester takviminde plann veritabnda update edilmesini salayan
     * method.nce mevcut kayd siliyor. Ardndan yeni bilgileri kaydediyor.
     *
     * @param schedule
     * @param userId
     * @throws java.text.ParseException
     */
    public void updateCalendarEntry(Schedule schedule, String userId) throws ParseException {
        deleteCalendarEntry(schedule.getId(), userId);
        saveCalendarEntry(schedule, userId);
    }

    /**
     * Pentester takvimi zerinden bir plan silindii zaman veritabanndan silen
     * method.
     *
     * @param scheduleId
     * @param userId
     */
    public void deleteCalendarEntry(String scheduleId, String userId) {
        String sql = "DELETE FROM calendar WHERE id = :id AND user_id = :userId ";
        Map params = new HashMap();
        params.put("userId", userId);
        params.put("id", scheduleId);
        int rows = jdbcTemplate.update(sql, params);
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
        //Attendee tablosundan silme ilemeri
        String sqlAttendee = "DELETE FROM calendar_attendees WHERE id = :id ";
        jdbcTemplate.update(sqlAttendee, params);
        
    }

    /**
     * Btn kullanclara ait takvimlerin proje bilgisini getiren method.
     *
     * @return list of user_ids
     */
    public List<String> getAllCalendarProjects() {
        Map params = new HashMap();
        String sql = "SELECT DISTINCT(name) FROM calendar_projects WHERE deleted = false ";
        List<String> data = jdbcTemplate.queryForList(sql, params, String.class);
        return data;
    }
    
    /**
     * Takvim iin kaydedilmi btn projeleri idleri ile birlikte dnen method.
     * @return list of projects
     */
    public List<CalendarProject> getAllCalendarProjectObjects(DataTablesRequest dataTablesRequest) {
        String sql = "SELECT id, name, duration FROM calendar_projects WHERE deleted = false ";
        Map map = new HashMap();
        if(dataTablesRequest != null) {
            ProjectColumnNameMapper projectColumnNameMapper = new ProjectColumnNameMapper();
            sql += createOrderBy(projectColumnNameMapper, dataTablesRequest)
                    + createLimit(dataTablesRequest, map);
        }      
        List<CalendarProject> results = jdbcTemplate.query(sql, map, new CalenderProjectResultSetExtractor(false));
        return results;
    }
    /**
     * Takvim iin kaydedilmi btn projelerin saysn dnen method.
     * @return list of projects
     */
    public int getAllCalendarProjectObjectsCount() {
        String sql = "SELECT count(*) FROM calendar_projects WHERE deleted = false ";
        Map map = new HashMap();  
        int count = (int) jdbcTemplate.queryForObject(sql, map, Integer.class);
        return count;
    }
    
    /**
     * ID ile Tekil Takvim projesi silen method.
     * @param id 
     */
    public void deleteCalendarProject(String id) {
        String sql = "UPDATE calendar_projects SET deleted = true WHERE id = :id ";
        Map params = new HashMap();
        params.put("id", id);
        int rows = jdbcTemplate.update(sql, params);
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
    }
    /**
     * ID ile Tekil Takvim projesi silen method.
     * @param id 
     * @param project 
     */
    public void updateCalendarProject(String id, CalendarProject project) {
        String sql = "UPDATE calendar_projects SET name = :name, duration = :duration WHERE id = :id ";
        Map params = new HashMap();
        params.put("id", id);
        params.put("name", project.getProject());
        params.put("duration", project.getDuration());
        int rows = jdbcTemplate.update(sql, params);
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
    }   
    
    /**
     * Tabloya eklenen yeni kaytta yer alan proje bilgisini eer yoksa veritabanna kaydeder.
     * Beraberinde n yzde generate edilmi arkaplan rengi de tutulur.
     * @param project
     * @param bgColor 
     */
    public void saveCalendarProject(CalendarProject project) {
        String sql = "INSERT INTO calendar_projects (id, name, bg_color, duration)\n" +
                        "SELECT :id, :name, :color, :duration \n" +
                        "WHERE NOT EXISTS (\n" +
                        "    SELECT id, name, bg_color, duration \n" +
                        "    FROM calendar_projects\n" +
                        "    WHERE name = :name \n" +
                        "    )";
        Map map = new HashMap();
        map.put("id", BizzyUtil.generateGUID());
        map.put("name", project.getProject());
        map.put("color", project.getBgColor());
        map.put("duration", project.getDuration());
        jdbcTemplate.update(sql, map);
    }
    
    /**
     * Pentest userlar tarafndan girilen efor kaytlarnn veritabanna kaydedildii method.
     * mesut.kutlu 02.10.2019
     * @param effort 
     */
    public void saveCalendarEffort(Effort effort) {
       String sql = "INSERT INTO calendar_effort (id, project, user_id, time_log, dates, start_date, user_comment) VALUES (:id, :project, :user_id, :time_log, :dates, :start_date, :user_comment)";
       Map params = new HashMap();
       params.put("id", effort.getId());
       params.put("project", effort.getProject());
       params.put("user_id", effort.getUserId());
       params.put("time_log", effort.getWorkLogNum());
       params.put("dates", effort.getDates());
       params.put("start_date", effort.getStartDate());
       params.put("user_comment", effort.getUserComment());
       jdbcTemplate.update(sql, params);   
    }
    /**
     * Pentest userlar tarafndan girilen efor kaytlarnn veritabanndan id ile silen method.
     * mesut.kutlu 02.10.2019
     * @param effortId 
     */
    public void deleteCalendarEffort(String effortId) {
        String sql = "DELETE FROM calendar_effort WHERE id = :id ";
        Map params = new HashMap();
        params.put("id", effortId);
        int rows = jdbcTemplate.update(sql, params);
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
    }
    
    /**
     * Pentester eforlarn update eden method. nce mevcut kayd silip sonra yeni kayd ekler.
     * mesut.kutlu 02.10.2019
     * @param effort 
     */
    public void updateCalendarEffort(Effort effort) {
        deleteCalendarEffort(effort.getId());
        saveCalendarEffort(effort);
    }
    
    /**
     * Eforlarn kaydedildii tablodan btn kaytlar getiren sorgu.mesut.kutlu 02.10.2019
     * @param dataTablesRequest
     * @param filter
     * @return 
     */
    public List<Effort> getAllEfforts(DataTablesRequest dataTablesRequest, EffortFilter filter) {
        Map map = new HashMap();
        map.put("userId", filter.getUser());
        map.put("project", filter.getProject());
        String sql = "SELECT ce.*, cp.id as project_id, cp.name, aa.username FROM calendar_effort ce "
                + "LEFT JOIN aa_user aa ON aa.user_id = ce.user_id "
                + "LEFT JOIN calendar_projects cp ON ce.project = cp.id "
                + "WHERE 1=1 ";
        if(filter.getUser() != null) {
            sql += " AND ce.user_id = :userId ";
        }
        if(filter.getProject() != null) {
            sql += " AND ce.project = :project ";
        }
        if(dataTablesRequest != null) {
            EffortColumnNameMapper effortColumnNameMapper = new EffortColumnNameMapper();
            sql += createOrderBy(effortColumnNameMapper, dataTablesRequest)
                    + createLimit(dataTablesRequest, map);
        }

        List<Effort> results = jdbcTemplate.query(sql, map, new CalenderEffortResultSetExtractor(false));
        return results;
    }
    /**
     * Datatable iin toplam efor kayt saysn dnen method 
     * mesut.kutlu 02.10.2019
     * @param filter
     * @return 
     */
    public int getAllEffortsCount(EffortFilter filter) {
        Map map = new HashMap();
        map.put("userId", filter.getUser());
        map.put("project", filter.getProject());
        String sql = "SELECT count(*) FROM calendar_effort ce "
                + " LEFT JOIN calendar_projects cp ON ce.project = cp.id "
                + " LEFT JOIN aa_user aa ON aa.user_id = ce.user_id "
                + " WHERE 1=1 ";
        if(filter.getUser() != null) {
            sql += " AND ce.user_id = :userId ";
        }
        if(filter.getProject() != null) {
            sql += " AND cp.id = :project ";
        }
        int count = (int) jdbcTemplate.queryForObject(sql, map, Integer.class);
        return count;
    }
    /**
     * Parametre olarak alnan kullanclrdan verilen zaman aralnda mevcut takvim etkinlii bulunan <br>
     * kiileri dnen method.
     * @param schedule
     * @return user string list
     * @author mesut.kutlu
     * @throws ParseException 
     */
    public List<String> checkUsersAvailability(Schedule schedule) throws ParseException {
    	Map map = new HashMap();
    	DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm", Locale.US); 
    	map.put("startDate", formatter.parse(schedule.getStart()));
    	map.put("endDate", formatter.parse(schedule.getEnd()));
    	String sql = "SELECT  DISTINCT(username) FROM calendar c " 
    			+ " LEFT JOIN calendar_attendees ca ON  ca.id = c.id " 
    			+ " LEFT JOIN calendar_projects cp ON cp.id = c.location " 
    			+ " WHERE username IN ( :list[" + 0 + "]";
                for (int i = 1; i <= schedule.getAttendees().length - 1; i++) {
                    sql += " , :list[" + i + "] ";
                    map.put("list[" + i + "]", schedule.getAttendees()[i]);
                }               
                sql += " ) ";
                map.put("list[0]", schedule.getAttendees()[0]);
    			sql += " AND NOT(end_date < :startDate OR start_date > :endDate) ";
    	List<String> values = jdbcTemplate.query(sql, map, new RowMapper<String>() {
            public String mapRow(ResultSet rs, int rowNum)
                    throws SQLException {
                return rs.getString(1);
            }
        });
    	return values;
    }
    class CalenderEffortResultSetExtractor implements ResultSetExtractor<List<Effort>> {

        CalenderEffortResultSetExtractor(boolean b) {

        }

        @Override
        public List<Effort> extractData(ResultSet rs) throws SQLException, DataAccessException {
            List<Effort> efforts = new LinkedList<>();
            while (rs.next()) {
                Effort effort = new Effort();
                effort.setId(rs.getString("id"));
                effort.setWorkLog(String.valueOf(rs.getLong("time_log")));
                effort.setUsername(rs.getString("username"));
                try {
                    int count = 0;
                    StringBuilder effortDates = new StringBuilder();
                    for (String date : rs.getString("dates").split(", ")) {
                        String dateStr[] = date.split("\\s+");
                        SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy", new Locale("tr"));
                        String dateFormed = sdf.format(new SimpleDateFormat("EEE MMM dd yyyy").parse(dateStr[0] + " " + dateStr[1] + " " + dateStr[2] + " " + dateStr[3]));     
                        if(count != 0) {
                            effortDates.append(", ");
                        }
                        effortDates.append(dateFormed);
                        count++;               
                    }
                    effort.setDates(effortDates.toString());
                } catch(ParseException | NullPointerException ex) {
                    effort.setDates("");
                }
                
                effort.setStartDate(rs.getTimestamp("start_date"));
                effort.setUserComment(rs.getString("user_comment"));
                effort.setProject(rs.getString("name"));
                effort.setProjectId(rs.getString("project_id"));
                efforts.add(effort);
            }
            return efforts;
        }
    }
    class CalenderProjectResultSetExtractor implements ResultSetExtractor<List<CalendarProject>> {

        CalenderProjectResultSetExtractor(boolean b) {

        }

        @Override
        public List<CalendarProject> extractData(ResultSet rs) throws SQLException, DataAccessException {
            List<CalendarProject> projects = new LinkedList<>();
             while (rs.next()) {
                 CalendarProject project = new CalendarProject();
                 project.setId(rs.getString("id"));
                 project.setProject(rs.getString("name"));
                 project.setDuration(rs.getInt("duration"));
                 projects.add(project);
             }
            return projects;
        }
    }
    class EffortColumnNameMapper implements ColumnNameMapper {

        @Override
        public String getColumnName(String data) {
            String result;

            switch (data) {
                case "username":
                    result = "username";
                    break;
                case "project":
                    result = "project";
                    break;
                case "workLog":
                    result = "time_log";
                    break;
                case "dates":
                    result = "dates";
                    break;
                case "userComment":
                    result = "user_comment";
                    break;
                default:
                    throw new IllegalArgumentException(data + " is not a valid column name.");
            }
            return result;
        }
        @Override
        public boolean isDefault(String data) {
            return data.equals("username");
        }

        @Override
        public String getDefault() {
            return "username ASC";
        }
    }
    class ProjectColumnNameMapper implements ColumnNameMapper {

        @Override
        public String getColumnName(String data) {
            String result;

            switch (data) {
                case "id":
                    result = "id";
                    break;
                case "project":
                    result = "name";
                    break;          
                default:
                    throw new IllegalArgumentException(data + " is not a valid column name.");
            }
            return result;
        }
        @Override
        public boolean isDefault(String data) {
            return data.equals("project");
        }

        @Override
        public String getDefault() {
            return "name ASC";
        }
    }
   /**
     * Usera ait btn takvim bilgilerini getiren method.
     *
     * @param userTag
     * @param getAll
     * @return
     */
    public List<Schedule> getAllCalendarEntries(String userTag, Boolean getAll) {      
        Map params = new HashMap();     
        params.put("username", userTag);
        String sql = "SELECT * FROM calendar c "
                + "LEFT JOIN calendar_attendees ca ON  ca.id = c.id "
                + "LEFT JOIN calendar_projects cp ON cp.id = c.location ";
        if(!getAll) {
            sql += " WHERE username = :username ";
        }
        List<Schedule> results = jdbcTemplate.query(sql, params, new CalenderEntryResultSetExtractor(false));
        return results;
    }

    class CalenderEntryResultSetExtractor implements ResultSetExtractor<List<Schedule>> {

        CalenderEntryResultSetExtractor(boolean b) {

        }

        @Override
        public List<Schedule> extractData(ResultSet rs) throws SQLException, DataAccessException {
            List<Schedule> entries = new LinkedList<>();
            HashMap<String, Schedule> map = new HashMap<>();
            while (rs.next()) {
                String id = rs.getString("id");
                if(map.containsKey(id)) {
                    List<String> temp = new LinkedList<>(Arrays.asList(map.get(id).getAttendees()));
                    temp.add(rs.getString("username"));
                    String[] array = temp.toArray(new String[temp.size()]);
                    map.get(id).setAttendees(array);
                }else {
                    Schedule entry = new Schedule();
                    entry.setId(id);
                    entry.setTitle(rs.getString("title"));
                    entry.setBody(rs.getString("body"));
                    String startStr = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssXXX").format(rs.getTimestamp("start_date"));
                    String endStr = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssXXX").format(rs.getTimestamp("end_date"));
                    entry.setStart(startStr);
                    entry.setEnd(endStr);
                    entry.setState(rs.getString("state"));
                    entry.setAllDay(rs.getBoolean("isAllDay"));
                    entry.setUserId(rs.getString("user_id"));
                    entry.setLocation(rs.getString("name"));
                    entry.setCalendarId(rs.getString("user_id")); 
                    entry.setBgColor(rs.getString("bg_color"));
                    String[] attendee = {rs.getString("username")};
                    entry.setAttendees(attendee);
                    entries.add(entry);
                    map.put(id, entry);
                }
                
            }
            return entries;
        }
    }
    /**
     * Her projeye harcanan toplam zaman gsteren grafiin verisini proje-zaman ikilisiyle besleyen sorgu methodu.
     * mesut.kutlu 03.10.2019
     * @param userId
     * @return 
     */
    public List<CalendarProjectTimeGraph> spentTimeOfProjectsGraph(DataTablesRequest dataTablesRequest, EffortFilter filter) {
    	Map params = new HashMap();
    	String userId = filter.getUser();
        params.put("userId", userId);
        
        String sql = "SELECT sum(time_log), cp.name as tag FROM public.calendar_effort ce "
                + " LEFT JOIN calendar_projects cp ON ce.project = cp.id "
                + " WHERE 1=1 ";
        if(userId != null && !userId.equals("") && !userId.equals("-1")) {
            sql += " AND user_id = :userId ";
        }
        if(filter.getStartDate() != null) {
        	params.put("startDate", filter.getStartDate());
            params.put("endDate", filter.getEndDate());
        	sql += " AND start_date >= :startDate AND start_date <= :endDate ";
        }
        sql += " GROUP BY cp.name ";
        if(dataTablesRequest != null) {
        	CalendarGraphColumnNameMapper calendarGraphColumnNameMapper = new CalendarGraphColumnNameMapper();
            sql += createOrderBy(calendarGraphColumnNameMapper, dataTablesRequest)
                    + createLimit(dataTablesRequest, params);
        }
        
        List<CalendarProjectTimeGraph> data = jdbcTemplate.query(sql, params, new SpentTimeOfProjectsGraphResultSetExtractor());
        return data;
    }
    
    /**
     * Her projeye harcanan toplam zaman gsteren grafiin e saysn dnen method.
     * @param userId
     * @return 
     */
    public int spentTimeOfProjectsGraphCount(EffortFilter filter) {
    	Map params = new HashMap();
    	String userId = filter.getUser();
        params.put("userId", userId);
        String sql = "SELECT COUNT(*) FROM ( SELECT COUNT(cp.name) FROM public.calendar_effort ce "
                + " LEFT JOIN calendar_projects cp ON ce.project = cp.id "
                + " WHERE 1=1 ";
        if(userId != null && !userId.equals("") && !userId.equals("-1")) {
            sql += " AND user_id = :userId ";
        }
        if(filter.getStartDate() != null) {
        	params.put("startDate", filter.getStartDate());
            params.put("endDate", filter.getEndDate());
        	sql += " AND start_date >= :startDate AND start_date <= :endDate ";
        }
        sql += " GROUP BY cp.name) AS z";
        int count = (int) jdbcTemplate.queryForObject(sql, params, Integer.class);
        return count;
    }
    
    /**
     * Toplam harcanan zamann userlar baznda ayrmn gsteren grafiin verisini kii-zaman ile besleyen sorgu methodu.
     * mesut.kutlu 03.10.2019
     * @param project
     * @return HashMap String,Integer
     */
    public List<CalendarProjectTimeGraph> usersSpentTimeGraphByProject(DataTablesRequest dataTablesRequest, EffortFilter filter) {
    	Map params = new HashMap();
    	String project = filter.getProject();
        params.put("project", project);
        String sql = "SELECT sum(time_log), user_id as tag FROM public.calendar_effort ce "
                + " LEFT JOIN calendar_projects cp ON ce.project = cp.id "
                + " WHERE 1=1 ";
        if(project != null && !project.equals("") && !project.equals("-1")) {
            sql += " AND cp.id = :project ";
        }
        if(filter.getStartDate() != null) {
        	params.put("startDate", filter.getStartDate());
            params.put("endDate", filter.getEndDate());
        	sql += " AND start_date >= :startDate AND start_date <= :endDate ";
        }
        sql += " GROUP BY user_id ";
        if(dataTablesRequest != null) {
        	CalendarGraphColumnNameMapper calendarGraphColumnNameMapper = new CalendarGraphColumnNameMapper();
            //sql += createOrderBy(calendarGraphColumnNameMapper, dataTablesRequest)
        	sql += createLimit(dataTablesRequest, params);
        }
        
        List<CalendarProjectTimeGraph> map = jdbcTemplate.query(sql, params, new SpentTimeOfProjectsGraphResultSetExtractor());
        return map;
    }
    
    /**
     * Toplam harcanan zamann userlar baznda ayrmn gsteren grafiin e saysn dnen method
     * @param userId
     * @return
     */
    public int  usersSpentTimeGraphByProjectCount(EffortFilter filter) {
    	Map params = new HashMap();
    	String project = filter.getProject();
        params.put("project", project);
        String sql = "SELECT COUNT(*) FROM ( SELECT sum(time_log), user_id as tag FROM public.calendar_effort ce "
                + " LEFT JOIN calendar_projects cp ON ce.project = cp.id "
                + " WHERE 1=1 ";
        if(project != null && !project.equals("") && !project.equals("-1")) {
            sql += " AND cp.id = :project ";
        }
        if(filter.getStartDate() != null) {
        	params.put("startDate", filter.getStartDate());
            params.put("endDate", filter.getEndDate());
        	sql += " AND start_date >= :startDate AND start_date <= :endDate ";
        }
        sql += " GROUP BY user_id) AS z";
        int count = (int) jdbcTemplate.queryForObject(sql, params, Integer.class);
        return count;
    }
    
    /**
     * Haftalara gre efor toplamlar grafiini date-efor ikilsiyle besleyen method.
     * mesut.kutlu 04.10.2019
     * @param filter
     * @return 
     */
    public List<CalendarProjectTimeGraph> spentTimeCumulativeGraph(DataTablesRequest dataTablesRequest, EffortFilter filter) {
        Map params = new HashMap();
        params.put("project", filter.getProject());
        params.put("user", filter.getUser());
        StringBuilder sql = new StringBuilder();
        sql.append("SELECT date_trunc('week', start_date::date) AS tag, SUM(time_log) FROM  calendar_effort ce "
                + " LEFT JOIN calendar_projects cp ON ce.project = cp.id "
                + " WHERE 1=1 ");
            if(filter.getUser() != null) {
                sql.append(" AND user_id = :user ");
            }
            if(filter.getProject() != null) {
                sql.append(" AND cp.id = :project ");
            }
            if(filter.getStartDate() != null) {
            	params.put("startDate", filter.getStartDate());
                params.put("endDate", filter.getEndDate());
            	sql.append(" AND start_date >= :startDate AND start_date <= :endDate ");
            }
            sql.append("GROUP BY tag ORDER BY tag ");
            if(dataTablesRequest != null) {
            	WeeklyEffortColumnNameMapper weeklyEffortColumnNameMapper = new WeeklyEffortColumnNameMapper();
                sql.append(createLimit(dataTablesRequest, params));
            }         
        return jdbcTemplate.query(sql.toString(), params, new SpentTimeOfProjectsGraphResultSetExtractor());    
    }
    
    /**
     * Haftalara gre efor toplamlar grafiinin e saysn dnen method.
     * @param filter
     * @return int
     * @author mesut.kutlu
     */
    public int spentTimeCumulativeGraphCount(EffortFilter filter) {
    	Map params = new HashMap();
        params.put("project", filter.getProject());
        params.put("user", filter.getUser());
       
        StringBuilder sql = new StringBuilder();
        sql.append("SELECT COUNT(*) FROM ( SELECT date_trunc('week', start_date::date) AS tag, SUM(time_log) FROM  calendar_effort ce  ");
        sql.append(" LEFT JOIN calendar_projects cp ON ce.project = cp.id ");
        sql.append(" WHERE 1=1 ");
        
        if(filter.getUser() != null) {
            sql.append(" AND user_id = :user ");
        }
        if(filter.getProject() != null) {
            sql.append(" AND cp.id = :project ");
        }
        if(filter.getStartDate() != null) {
        	params.put("startDate", filter.getStartDate());
            params.put("endDate", filter.getEndDate());
        	sql.append(" AND start_date >= :startDate AND start_date <= :endDate ");
        }
        sql.append(" GROUP BY tag) AS z");
        int count = (int) jdbcTemplate.queryForObject(sql.toString(), params, Integer.class);
        return count;
    }
    
    class SpentTimeCumulativeGraphResultSetExtractor implements ResultSetExtractor<HashMap<Date,Integer>> {
        SpentTimeCumulativeGraphResultSetExtractor(boolean b) {

        }
        @Override
        public HashMap<Date,Integer> extractData(ResultSet rs) throws SQLException, DataAccessException {
            HashMap<Date, Integer> map = new HashMap<>();
            while (rs.next()) {
                map.put(rs.getTimestamp("tag"),rs.getInt("sum"));       
            }
            return map;
        }
    }
    class SpentTimeOfProjectsGraphResultSetExtractor implements ResultSetExtractor<List<CalendarProjectTimeGraph>> {
        @Override
        public List<CalendarProjectTimeGraph> extractData(ResultSet rs) throws SQLException, DataAccessException {
        	List<CalendarProjectTimeGraph> list = new ArrayList<CalendarProjectTimeGraph>();
            while (rs.next()) {
            	CalendarProjectTimeGraph data = new CalendarProjectTimeGraph();
            	try {
            		data.setDate(rs.getDate("date"));
                } catch (Exception e) {
                	data.setName(rs.getString("tag"));
     			}       	
            	data.setTime(rs.getInt("sum"));
                list.add(data);       
            }
            return list;
        }
    }
    class CalendarGraphColumnNameMapper implements ColumnNameMapper {

        @Override
        public String getColumnName(String data) {
            String result;

            switch (data) {
            	case "date":
                case "name":
                    result = "tag";
                    break;
                case "time":
                    result = "sum";
                    break;          
                default:
                    throw new IllegalArgumentException(data + " is not a valid column name.");
            }
            return result;
        }
        @Override
        public boolean isDefault(String data) {
            return data.equals("project");
        }

        @Override
        public String getDefault() {
            return "name ASC";
        }
    }
    class WeeklyEffortColumnNameMapper implements ColumnNameMapper {

        @Override
        public String getColumnName(String data) {
            String result;

            switch (data) {
            	case "date":
                    result = "tag";
                    break;      
                default:
                    throw new IllegalArgumentException(data + " is not a valid column name.");
            }
            return result;
        }
        @Override
        public boolean isDefault(String data) {
            return data.equals("project");
        }

        @Override
        public String getDefault() {
            return "name ASC";
        }
    }
    /**
     * Varln bir nceki taramada sahip olduu vcs revizyon numarasn dnen method.mesut.kutlu 25.10.2019
     * @param projectName
     * @param vcsId
     * @param customerId
     * @return 
     */
    public String getPreviousRevision(String projectName, String vcsId, String customerId) {
        String sql = "SELECT revision from scan_project_details spd LEFT JOIN scan s ON s.scan_id = spd.scan_id\n" +
                    "WHERE revision != 'failed' AND spd.project_name = :projectName AND spd.vcs_id = :vcsId AND s.customer_id = :customerId AND s.scan_date IS NOT NULL AND spd.revision IS NOT NULL ORDER BY scan_date DESC LIMIT 1 OFFSET 1";
        Map params = new HashMap();
        params.put("customerId", customerId);
        params.put("projectName", projectName);
        params.put("vcsId", vcsId);
        String previousRevision = null;
        try {
            previousRevision = jdbcTemplate.queryForObject(sql, params, String.class);
        }catch(DataAccessException ex) {
            logger.log(LogLevel.ERROR, "Son revizyon bulunamad.");
            return null;
        }
        return previousRevision;
    }
    /**
     * Security Center senkronizasyon ile zafiyetlerin Bizzy'e aktarld durumlarda sadece yeni eklenen <br>
     * zafiyetleri tespit etmek iin son ektiimiz vakti getiren method.
     * @param customerId
     * @param scheduledScanId
     * @return 
     */
    public Long getLatestScheduledSecurityCenterScanDate(String customerId, String scheduledScanId) {
        String sql = "SELECT scan_date from scan \n" +
                    " WHERE sync_scan = true AND scan_date IS NOT NULL AND customer_id = :customerId AND source='SECURITY_CENTER' AND status='COMPLETED' AND scheduled_scan_id = :scheduledScanId ORDER BY scan_date DESC LIMIT 1 ";
        Map params = new HashMap();
        params.put("customerId", customerId);
        params.put("scheduledScanId", scheduledScanId);
        try {
            return ((Date) jdbcTemplate.queryForObject(sql, params, Date.class)).getTime() / 1000;
        }catch(DataAccessException ex) {
            return null;
        }
    }
    
    /**
     * Taramaya ait detay tablosundaki revision kolonunu gncelleyen method.
     * mesut.kutlu 30.10.2019
     * @param scanId
     * @param revision 
     */
    public void updateScanDetailsRevision(String scanId, String revision) {
        String sql = "UPDATE scan_project_details SET revision = :revision WHERE scan_id = :scanId ";
        Map params = new HashMap();
        params.put("scanId", scanId);
        params.put("revision", revision);
        jdbcTemplate.update(sql, params);
    }
    
    /**
     * Devam eden taramalarda yzde gsterimin sakland alan update eden method.
     * @param scanId
     * @param progress 
     */
    public void updateScanProgress(String scanId, Integer progress) {
        String sql = "UPDATE scan SET progress = :progress WHERE scan_id = :scanId ";
        Map params = new HashMap();
        params.put("progress", progress);
        params.put("scanId", scanId);
        jdbcTemplate.update(sql, params);
    }
    
       public List<PentestScan> getScansByCustomerIdAndName(String customerId, String name,String username) {
        String sql = "SELECT s.scan_id, s.name "
                + " FROM scan s "
                + "WHERE s.name ILIKE :name AND s.customer_id =:customerId ";
        Map params = new HashMap();
        if (username != null){
            sql += " AND s.requested_by = :username";
            params.put("username", username);
        }
        params.put("customerId", customerId);
        params.put("name", "%" + name + "%");
        List<PentestScan> result = jdbcTemplate.query(sql, params, new ScanLessDetailsResultSetExtractor(false));
        return result;
    }
        
   class ScanLessDetailsResultSetExtractor implements ResultSetExtractor<List<PentestScan>> {

        private ScanLessDetailsResultSetExtractor(boolean b) {

        }

        @Override
        public List<PentestScan> extractData(ResultSet rs) throws SQLException, DataAccessException {
            List<PentestScan> scans = new LinkedList<>();
            while (rs.next()) {
                PentestScan scan = new PentestScan();
                String scanId = rs.getString("scan_id");
                scan.setName(rs.getString("name"));
                scan.setScanId(scanId);
                scans.add(scan);
            }
            return scans;
        }
    }
   
    class ScanLabelResultSetExtractor implements ResultSetExtractor<List<Label>> {

        ScanLabelResultSetExtractor(boolean b) {

        }

        @Override
        public List<Label> extractData(ResultSet rs) throws SQLException, DataAccessException {
            List<Label> labelList = new LinkedList<>();
             while (rs.next()) {
                 Label label = new Label();
                 label.setName(rs.getString("label"));
                 labelList.add(label);
             }
            return labelList;
        }
    }
    
    
    public boolean saveNessusVersion(String currentNessusVersion,String name) {
        Map params = new HashMap();
        params.put("currentNessusVersion", currentNessusVersion);
        params.put("name", name);

        String sql = "UPDATE server SET version = :currentNessusVersion "
                + "where name= :name and version IS NULL; ";

        int rows = jdbcTemplate.update(sql, params);
        
        return true;

    }
    
    
    public boolean updateNessusVersion(String currentNessusVersion,String name) {
        Map params = new HashMap();
        params.put("currentNessusVersion", currentNessusVersion);
        params.put("name", name);

        String sql = "UPDATE server SET version = :currentNessusVersion "
                + "where name= :name ";

        int rows = jdbcTemplate.update(sql, params);
        
        if (rows != 1) {
            throw new DataAccessException("Unexpected rows. Expected: 1 Rows: " + rows) {
            };
        }
        
        return true;

    }
    public String getLocalNessusVersion(String name) {
        String sql = "SELECT version FROM server "
                + "WHERE name= :name ";
        Map params = new HashMap();
        params.put("name", name);
        String result = jdbcTemplate.queryForObject(sql, params, String.class);
        return result;
    }
    
}
