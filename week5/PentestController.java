/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package tr.biznet.bizzy.controller;

import com.google.json.JsonSanitizer;
import tr.biznet.bizzy.plugins.fortify.FortifyXmlParser;
import com.google.gson.Gson;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;
import javax.imageio.ImageIO;
import javax.script.ScriptException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.xml.bind.JAXBException;
import javax.xml.stream.XMLStreamException;
import org.apache.commons.codec.binary.Base64;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang.ArrayUtils;
import org.apache.commons.lang.time.DateUtils;
import org.apache.commons.net.util.SubnetUtils;
import org.apache.poi.openxml4j.exceptions.InvalidFormatException;
import org.json.JSONException;
import org.json.JSONObject;
import org.quartz.SchedulerException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.propertyeditors.CustomCollectionEditor;
import org.springframework.beans.propertyeditors.CustomDateEditor;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Controller;
import org.springframework.util.StreamUtils;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.ServletRequestBindingException;
import org.springframework.web.bind.ServletRequestUtils;
import org.springframework.web.bind.WebDataBinder;
import org.springframework.web.bind.annotation.InitBinder;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.multipart.MultipartHttpServletRequest;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;
import org.springframework.web.servlet.support.RequestContextUtils;
import static tr.biznet.bizzy.common.domain.MessageType.ASSET_SEVERITY;
import static tr.biznet.bizzy.common.domain.MessageType.PROBLEM_AREA;
import static tr.biznet.bizzy.common.domain.MessageType.ROOT_CAUSE;
import static tr.biznet.bizzy.common.domain.MessageType.VULNERABILITY_EFFECT;
import static tr.biznet.bizzy.common.domain.MessageType.VULNERABILITY_SOURCE;
import tr.biznet.bizzy.configuration.service.ConfigurationService;
import tr.biznet.bizzy.domain.BizzyException;
import tr.biznet.bizzy.domain.BizzySecurityException;
import tr.biznet.bizzy.domain.DatabaseMessageSourceBase;
import tr.biznet.bizzy.limit.enums.LimitTypeEnum;
import tr.biznet.bizzy.limit.enums.LimitValueTypeEnum;
import tr.biznet.bizzy.limit.service.LimitService;
import tr.biznet.bizzy.owaps.OwapsReport;
import tr.biznet.bizzy.owaps.OwapsService;
import tr.biznet.bizzy.owaps.OwapsXmlParser;
import tr.biznet.bizzy.plugins.acunetix.AcunetixHtmlParser;
import tr.biznet.bizzy.plugins.acunetix.AcunetixService;
import tr.biznet.bizzy.plugins.acunetix.AcunetixXmlParser;
import tr.biznet.bizzy.plugins.acunetix.domain.AcunetixReport;
import tr.biznet.bizzy.plugins.agent.BizzyAgentService;
import tr.biznet.bizzy.plugins.agent.domain.RepositoryRequest;
import tr.biznet.bizzy.plugins.appScan.AppScanService;
import tr.biznet.bizzy.plugins.appScan.AppScanXmlParser;
import tr.biznet.bizzy.plugins.appScan.domain.scan.AppScanReport;
import tr.biznet.bizzy.plugins.appScan.domain.scan.HostItem;
import tr.biznet.bizzy.plugins.arachni.ArachniService;
import tr.biznet.bizzy.plugins.arachni.ArachniXmlParser;
import tr.biznet.bizzy.plugins.arachni.domain.scan.ArachniReport;
import tr.biznet.bizzy.plugins.burp.BurpXmlParser;
import tr.biznet.bizzy.plugins.burp.domain.scan.Issue;
import tr.biznet.bizzy.plugins.burp.domain.scan.Issues;
import tr.biznet.bizzy.plugins.nessus.NessusService;
import tr.biznet.bizzy.plugins.nessus.NessusXmlParser;
import tr.biznet.bizzy.plugins.nessus.domain.scan.NessusClientData_v2;
import tr.biznet.bizzy.plugins.nessus.domain.scan.Preference;
import tr.biznet.bizzy.plugins.nessus.domain.scan.Report;
import tr.biznet.bizzy.plugins.nessus.domain.scan.ReportHost;
import tr.biznet.bizzy.plugins.nessus.domain.scan.Tag;
import tr.biznet.bizzy.plugins.burp.domain.scan.RequestResponse;
import tr.biznet.bizzy.plugins.checkmarx.CheckmarxService;
import tr.biznet.bizzy.plugins.checkmarx.CheckmarxXmlParser;
import tr.biznet.bizzy.plugins.checkmarx.domain.CheckmarxReport;
import tr.biznet.bizzy.plugins.fortify.FortifyService;
import tr.biznet.bizzy.plugins.fortify.domain.BuildTool;
import tr.biznet.bizzy.plugins.fortify.domain.LanguageType;
import tr.biznet.bizzy.plugins.fortify.domain.scan.FortifyReport;
import tr.biznet.bizzy.plugins.netsparker.NetsparkerEntXmlParser;
import tr.biznet.bizzy.plugins.nexpose.NexposeService;
import tr.biznet.bizzy.plugins.nmap.NmapScanService;
import tr.biznet.bizzy.plugins.openvas.OpenVASService;
import tr.biznet.bizzy.plugins.qualys.QualysPlugin;
import tr.biznet.bizzy.plugins.qualys.QualysXmlParser;
import tr.biznet.bizzy.plugins.qualys.domain.appliance.Appliance;
import tr.biznet.bizzy.plugins.qualys.domain.appliance.ApplianceListOutput;
import tr.biznet.bizzy.plugins.qualys.domain.report.fetch.Ip;
import tr.biznet.bizzy.plugins.qualys.domain.report.fetch.Key;
import tr.biznet.bizzy.plugins.qualys.domain.report.fetch.Scan;
import tr.biznet.bizzy.plugins.netsparker.NetsparkerService;
import tr.biznet.bizzy.plugins.netsparker.NetsparkerXmlParser;
import tr.biznet.bizzy.plugins.netsparker.domain.NetsparkerEntReport;
import tr.biznet.bizzy.plugins.netsparker.domain.NetsparkerReport;
import tr.biznet.bizzy.plugins.securitycenter.SecurityCenterService;
import tr.biznet.bizzy.plugins.securitycenter.domain.Repository;
import tr.biznet.bizzy.plugins.ti.TiService;
import tr.biznet.bizzy.plugins.ti.domain.AlertType;
import tr.biznet.bizzy.plugins.wapiti.WapitiXmlParser;
import tr.biznet.bizzy.plugins.wapiti.domain.scan.WapitiEntry;
import tr.biznet.bizzy.plugins.wapiti.domain.scan.WapitiInfo;
import tr.biznet.bizzy.plugins.wapiti.domain.scan.WapitiReference;
import tr.biznet.bizzy.plugins.wapiti.domain.scan.WapitiReport;
import tr.biznet.bizzy.plugins.wapiti.domain.scan.WapitiVulnerability;
import tr.biznet.bizzy.plugins.webinspect.WebinspectService;
import tr.biznet.bizzy.plugins.webinspect.WebinspectXmlParser;
import tr.biznet.bizzy.plugins.webinspect.domain.scan.WebinspectInfo;
import tr.biznet.bizzy.plugins.webinspect.domain.scan.WebinspectReport;
import tr.biznet.bizzy.report.entity.VulnerabilityReportStatistics;
import tr.biznet.bizzy.report.enums.ReportTypeEnum;
import tr.biznet.bizzy.report.service.ReportService;
import tr.biznet.bizzy.service.server.domain.Server;
import tr.biznet.bizzy.service.server.enums.ServerType;
import tr.biznet.bizzy.service.aa.domain.Group;
import tr.biznet.bizzy.service.aa.domain.User;
import tr.biznet.bizzy.service.aa.service.UserService;
import tr.biznet.bizzy.service.asset.service.AssetService;
import tr.biznet.bizzy.service.customer.CustomerService;
import tr.biznet.bizzy.service.customer.domain.Customer;
import tr.biznet.bizzy.service.customer.domain.ScanVulnDetails;
import tr.biznet.bizzy.service.excel.ExcelService;
import tr.biznet.bizzy.service.file.entity.ImageFile;
import tr.biznet.bizzy.service.file.entity.ProofFile;
import tr.biznet.bizzy.service.file.enums.FileDataTypeEnum;
import tr.biznet.bizzy.service.file.service.FileService;
import tr.biznet.bizzy.service.importHelper.ImportService;
import tr.biznet.bizzy.service.kb.KBService;
import tr.biznet.bizzy.service.kb.domain.KBItem;
import tr.biznet.bizzy.service.kb.domain.PCIStatus;
import tr.biznet.bizzy.service.message.MessageService;
import tr.biznet.bizzy.service.pci.PciService;
import tr.biznet.bizzy.service.pci.domain.OccurrenceType;
import tr.biznet.bizzy.service.pci.domain.PassiveScanVulnerabilityInfo;
import tr.biznet.bizzy.service.pci.domain.ScanAsset;
import tr.biznet.bizzy.service.pentest.domain.ScanStatus;
import tr.biznet.bizzy.service.pci.domain.ScanVulnerability;
import tr.biznet.bizzy.service.pci.domain.WebApp;
import tr.biznet.bizzy.service.pentest.HostScanSchedulerService;
import tr.biznet.bizzy.service.pentest.HostScanStatusService;
import tr.biznet.bizzy.service.pentest.HostScanTaskExecutor;
import tr.biznet.bizzy.service.scan.domain.Asset;
import tr.biznet.bizzy.service.pentest.PentestService;
import tr.biznet.bizzy.service.pentest.ScanSchedulerService;
import tr.biznet.bizzy.service.pentest.ScanTaskExecutor;
import tr.biznet.bizzy.service.pentest.domain.AssetDiscovery;
import tr.biznet.bizzy.service.pentest.domain.AssetDiscoveryResult;
import tr.biznet.bizzy.service.pentest.domain.PentestPolicy;
import tr.biznet.bizzy.service.pentest.domain.PentestScan;
import tr.biznet.bizzy.service.pentest.domain.PentestScanner;
import tr.biznet.bizzy.service.pentest.domain.PentestTimezone;
import tr.biznet.bizzy.service.pentest.domain.ScanLaunch;
import tr.biznet.bizzy.service.pentest.domain.ScheduledAssetDiscovery;
import tr.biznet.bizzy.service.pentest.domain.ScheduledPentestScan;
import tr.biznet.bizzy.service.pentest.domain.VulnerabilityKbItem;
import tr.biznet.bizzy.service.pentest.domain.validator.HostScanValidator;
import tr.biznet.bizzy.service.pentest.domain.validator.ScanValidator;
import tr.biznet.bizzy.service.scan.domain.AssetGroup;
import tr.biznet.bizzy.service.scan.domain.Category;
import tr.biznet.bizzy.service.scan.domain.Label;
import tr.biznet.bizzy.service.scan.domain.Message;
import tr.biznet.bizzy.service.scan.domain.Port;
import tr.biznet.bizzy.service.scan.domain.Vulnerability;
import tr.biznet.bizzy.service.scan.domain.VulnerabilityFilter;
import tr.biznet.bizzy.service.scan.domain.Source;
import tr.biznet.bizzy.service.scan.domain.ScanResultsFilter;
import tr.biznet.bizzy.service.server.ServerService;
import tr.biznet.bizzy.ticket.entity.TicketLink;
import tr.biznet.bizzy.ticket.entity.TicketStatus;
import tr.biznet.bizzy.ticket.enums.TicketLinkTypeEnum;
import tr.biznet.bizzy.ticket.view.TicketAssigneeChangeView;
import tr.biznet.bizzy.ticket.view.TicketStatusChangeView;
import tr.biznet.bizzy.ticket.service.TicketExternalService;
import tr.biznet.bizzy.util.BizzyUtil;
import tr.biznet.bizzy.util.DaoUtil;
import tr.biznet.bizzy.util.HttpUtil;
import tr.biznet.bizzy.util.JsonUtil;
import tr.biznet.bizzy.util.datatables.DataTablesRequest;
import tr.biznet.bizzy.util.datatables.DataTablesUtil;
import tr.biznet.bizzy.util.log.LogLevel;
import tr.biznet.bizzy.util.log.LoggerFactory;
import tr.biznet.bizzy.service.pentest.domain.AssetAndGroup;
import tr.biznet.bizzy.service.pentest.domain.CalendarProject;
import tr.biznet.bizzy.service.pentest.domain.CalendarProjectTimeGraph;
import tr.biznet.bizzy.service.pentest.domain.Effort;
import tr.biznet.bizzy.service.pentest.domain.EffortFilter;
import tr.biznet.bizzy.service.pentest.domain.ImportObject;
import tr.biznet.bizzy.service.pentest.domain.ScanDiff;
import tr.biznet.bizzy.service.pentest.domain.Schedule;
import tr.biznet.bizzy.service.pentest.domain.SelectOption;
import tr.biznet.bizzy.service.pentest.domain.validator.TargetValidator;
import tr.biznet.bizzy.service.scan.domain.AssetFilter;
import tr.biznet.bizzy.service.scan.domain.AssetProperty;
import tr.biznet.bizzy.service.scan.domain.AssetType;
import tr.biznet.bizzy.service.scan.domain.AssetVulnerability;
import tr.biznet.bizzy.service.scan.domain.VirtualHost;
import tr.biznet.bizzy.service.ssl.service.SslService;
import tr.biznet.bizzy.taskengine.util.MessageUtil;
import tr.biznet.bizzy.ticket.entity.Ticket;
import tr.biznet.bizzy.ticket.service.TicketService;
import tr.biznet.bizzy.util.BizzyGson;
import tr.biznet.bizzy.util.EscapeUtil;
import tr.biznet.bizzy.util.RegexUtil;
import tr.biznet.bizzy.util.conf.Configuration;

/**
 *
 * @author adem.dilbaz
 */
@Controller
@RequestMapping("/pentest/")
public class PentestController extends PentestBaseController{

    @Autowired
    private MessageService messageService;
    @Autowired
    private AcunetixService acunetixService;
    @Autowired
    private ArachniService arachniService;
    @Autowired
    private NetsparkerService netsparkerService;
    @Autowired
    private FortifyService fortifyService;
    @Autowired
    private CheckmarxService checkmarxService;
    @Autowired
    private OwapsService owapsService;
    @Autowired
    private BizzyAgentService bizzyAgentService;
    @Autowired
    private WebinspectService webinspectService;
    @Autowired
    private AppScanService appScanService;
    @Autowired
    private OpenVASService openVASService;
    @Autowired
    private PentestService pentestService;
    @Autowired
    private CustomerService customerService;
    @Autowired
    private FileService fileService;
    @Autowired
    private KBService kBService;
    @Autowired
    private NessusService nessusService;
    @Autowired
    private SecurityCenterService securityCenterService;
    @Autowired
    private NexposeService nexposeService;
    @Autowired
    private PciService pciService;
    @Autowired
    private UserService aaService;
    @Autowired
    private ServerService serverService;
    @Autowired
    private ReportService reportService;
    @Autowired
    private ExcelService excelService;
    @Autowired
    private TicketExternalService ticketExternalService;
    @Autowired
    private NmapScanService nmapScanService;
    @Autowired
    private ScanSchedulerService scanSchedulerService;
    @Autowired
    private HostScanSchedulerService hostScanSchedulerService;
    @Autowired
    private DatabaseMessageSourceBase messageSource;
    @Autowired
    private AssetService assetService;
    @Autowired
    private ConfigurationService configurationService;
    @Autowired
    private LimitService limitService;
    @Autowired
    private ScanTaskExecutor scanTaskExecutor;
    @Autowired
    private HostScanTaskExecutor hostScanTaskExecutor;
    @Autowired
    private ImportService importService;
    @Autowired
    private SslService sslService;
    @Autowired
    private TiService tiService;
    @Autowired
    private TicketService ticketService;
    
    @Autowired
    private HostScanStatusService hostScanStatusService;
    
    private CompletableFuture<String> future;

    private static final String ESCAPE_REGEX_1 = "(?i)<(/?script[^>]*)>";
    private static final String ESCAPE_REGEX_2 = "&lt;$1&gt;";

    Gson gson = BizzyGson.createGson();
    private static final tr.biznet.bizzy.util.log.Logger logger = LoggerFactory.getLogger(PentestController.class);
    private static final String[] ALL_STATUS = new String[]{"OPEN", "CLOSED", "RISK_ACCEPTED", "RECHECK", "ON_HOLD", "IN_PROGRESS", "FALSE_POSITIVE"};

    private CompletableFuture<String> scanReport;
    private CompletableFuture<String> bddkReport;

    @RequestMapping(value = "listAssetDiscoveries.htm", method = {RequestMethod.GET})
    public ModelAndView listAssetDiscoveries(HttpServletRequest request, HttpServletResponse response) throws BizzyException, BizzySecurityException {
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        List<Server> scanEngines = serverService.getHostDiscoveryServers(customerId);

        ModelAndView mv = new ModelAndView();
        mv.addObject(new AssetDiscovery());
        mv.addObject("scanEngines", scanEngines);
        return mv;
    }

    //Ajax tarafından çağrılıyor.
    @RequestMapping(value = "loadAssetDiscoveries.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String loadAssetDiscoveries(HttpServletRequest request, HttpServletResponse response) {
        DataTablesRequest dataTablesRequest = DataTablesUtil.getRequest(request);
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);

        int totalCount;
        List<AssetDiscovery> scans = null;

        totalCount = pentestService.getCompletedHostScansCount(dataTablesRequest, customerId);
        scans = pentestService.getCompletedHostScans(dataTablesRequest, customerId);
        scans = setHostScanResultCounts(scans); //Yeni host ve aktif host sayıları

        return DataTablesUtil.getResponse(dataTablesRequest.getDraw(), totalCount, totalCount, scans);
    }

    //Ajax tarafından çağrılıyor.
    @RequestMapping(value = "loadRunningAssetDiscoveries.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String loadRunningAssetDiscoveries(HttpServletRequest request, HttpServletResponse response) {
        DataTablesRequest dataTablesRequest = DataTablesUtil.getRequest(request);
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);

        int totalCount;
        List<AssetDiscovery> scans = null;

        totalCount = pentestService.getRunningHostScansCount(dataTablesRequest, customerId);
        scans = pentestService.getRunningHostScans(dataTablesRequest, customerId);

        return DataTablesUtil.getResponse(dataTablesRequest.getDraw(), totalCount, totalCount, scans);
    }

    /**
     * Listelenen varlık keşiflerinde, planlı ise kaç aktif host bulunmuş, kaç
     * host yeni bulunmuş bilgilerini hesaplar. Bunun için bir önceki planlı
     * keşifle kıyaslama yapıyoruz 28.12.2017.
     *
     * @param scans
     * @return
     */
    public List<AssetDiscovery> setHostScanResultCounts(List<AssetDiscovery> scans) {        
        for (AssetDiscovery scan : scans) {
            scan = pentestService.setActiveAndNewHostCounts(scan);
        }
        return scans;
    }

    //Ajax tarafından çağrılıyor.
    @RequestMapping(value = "refreshScanStatus.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String refreshScanStatus(HttpServletRequest request, HttpServletResponse response) {
        pentestService.updatePentestScanStates();
        return "{}";
    }

    //Ajax tarafından çağrılıyor.
    @RequestMapping(value = "refreshAssetDiscoveryStatus.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String refreshAssetDiscoveryStatus(HttpServletRequest request, HttpServletResponse response) {
        pentestService.updateHostScanStates();
        return "{}";
    }

    @RequestMapping(value = "loadScheduledAssetDiscoveries.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String loadScheduledAssetDiscoveries(HttpServletRequest request, HttpServletResponse response) {
        DataTablesRequest dataTablesRequest = DataTablesUtil.getRequest(request);
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        int totalCount = pentestService.getScheduledHostScansCount(dataTablesRequest, customerId);
        List<ScheduledAssetDiscovery> scans = pentestService.getScheduledHostScans(dataTablesRequest, customerId);
        setPreviousAndNextScanDates(null, scans);
        return DataTablesUtil.getResponse(dataTablesRequest.getDraw(), totalCount, totalCount, scans);
    }

    //Modal submit edildiğinde bu metod çağırılıyor.
    @RequestMapping(value = "startAssetDiscovery.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    @Deprecated
    public AssetDiscovery startAssetDiscovery(HttpServletRequest request, HttpServletResponse response, AssetDiscovery scan, BindingResult result, final RedirectAttributes redirectAttributes) throws BizzyException, BizzySecurityException {
        try {
            Date now = new Date();
            boolean scheduled = ServletRequestUtils.getBooleanParameter(request, "scheduledRadio", false);
            scan.setScheduled(scheduled);
            scan.setRequestDate(now);

            Locale locale = RequestContextUtils.getLocale(request);
            User user = HttpUtil.getUser();

            Customer customer = customerService.getCustomerByUserId(user.getUserId());
            if (!scan.getServer().getSettingId().equals("-1")) {
                scan.setServer(serverService.getServer(scan.getServer().getSettingId(), customer.getCustomerId()));
            }
            scan.setCustomer(customer);
            scan.setRequestedBy(user.getUsername());

            if (scan.getLaunch() == ScanLaunch.ON_DEMAND) { //ON_DEMAND seçildiyse 2 defa çalışacak!
                scan.setRecurrence(1);
            }
            if (scan.getRecurrence() == null || scan.getRecurrence() == 0 || scan.getRecurrence() > 100) { // RECCURENCE 1-100 ARASI DEĞİLSE
                scan.setRecurrence(-1);                        // RECCURENCE VERITABANI KAYDI İÇİN -1 OLARAK SET EDİLİR (SÜREKLİ TARAMA)
            }

            HostScanValidator validator = new HostScanValidator();
            validator.validate(scan, result);

            //Hata varsa errorList'e ekleyip json ile gönderilir.
            if (result.hasErrors()) {
                List<String> errorList = new LinkedList();
                for (Object object : result.getAllErrors()) {
                    if (object instanceof FieldError) {
                        FieldError fieldError = (FieldError) object;
                        errorList.add(messageSource.getMessage(fieldError.getCode(), locale));
                    }

                }
                if (!scan.getServer().getSettingId().equals("-1")) {
                    scan.getServer().setUsername(null);
                    scan.getServer().setPassword(null);
                }
                scan.setErrorList(errorList);
                return scan;
            }

            createHostScan(scan);
        } catch (Exception ex) {
            logger.log(LogLevel.ERROR, "Yeni tarama başlatılırken hata oluştu.", ex);
            throw new BizzyException("Yeni tarama başlatılırken hata oluştu." + ex.getMessage(), ex);
        }

        if (!scan.getServer().getSettingId().equals("-1")) {
            scan.getServer().setUsername(null);
            scan.getServer().setPassword(null);
        }
        return scan;

    }

    //Ajax tarafından çağrılıyor.
    @RequestMapping(value = "deleteScheduledAssetDiscovery.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String deleteScheduledAssetDiscovery(HttpServletRequest request, HttpServletResponse response) throws BizzyException {
        String scanId = ServletRequestUtils.getStringParameter(request, "scanId", null);
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        if (scanId != null) {
            try {
                ScheduledAssetDiscovery scan = pentestService.getScheduledAssetDiscoveryById(scanId, customerId);
                //Yetkisiz erişimi önlemek için kontroller
                if (scan == null) {
                    logger.log(LogLevel.ERROR, "Böyle bir tarama yok ! Tarama Id: " + scanId);
                    throw new BizzyException("Böyle bir tarama yok ! ScanId: " + scanId);
                }
                if (!scan.getCustomer().getCustomerId().equals(customerId)) {
                    logger.log(LogLevel.ERROR, "Yetkisiz tarama erişimi ! Tarama Id: " + scanId);
                    throw new BizzyException("Yetkisiz tarama erişimi ! Tarama Id: " + scanId);
                }
                List<AssetDiscovery> scans = pentestService.getHostScans(null, customerId);

                for (AssetDiscovery item : scans) {
                    if (item.getScheduledAssetDiscovery() != null && scanId.equals(item.getScheduledAssetDiscovery().getUuid())) {
                        item.setScheduledAssetDiscovery(null);
                        pentestService.updateAssetDiscovery(item.getId());
                    }
                }

                pentestService.deleteScheduledAssetDiscovery(scanId);

                AssetDiscovery assetDiscovery = (AssetDiscovery) Class.forName("tr.biznet.bizzy.service.pentest.domain.AssetDiscovery").cast(scan);

                hostScanSchedulerService.deregisterJob(assetDiscovery);
                logger.log(LogLevel.INFO, "Tarama silme işlemi başarılı.");
            } catch (Exception ex) {
                logger.log(LogLevel.ERROR, "Tarama silme işlemi başarısız.", ex);
                throw new BizzyException("Tarama silme işlemi başarısız.", ex);
            }
        }
        return "{}";
    }

    @RequestMapping(value = "listTags.htm", method = {RequestMethod.GET})
    public ModelAndView listTags(HttpServletRequest request, HttpServletResponse response) throws BizzyException {

        ModelAndView mv = new ModelAndView();
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        List<Label> labels = pentestService.getVulnerabilityLabels(null, null, customerId);
        List<Label> labelList = new LinkedList<>();
        if (labels.size() > 10) {
            labelList = new ArrayList<Label>(labels.subList(0, 10));
        } else {
            labelList = labels;
        }

        mv.addObject("labelList", labelList);
        mv.addObject("label", new Label());
        return mv;
    }

    //Ajax tarafından çağrılıyor.
    @RequestMapping(value = "loadTags.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String loadTags(HttpServletRequest request, HttpServletResponse response) {
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        String searchedLabel = ServletRequestUtils.getStringParameter(request, "label", "");
        DataTablesRequest dataTablesRequest = DataTablesUtil.getRequest(request);
        int totalCount = pentestService.getVulnerabilityLabelCount(dataTablesRequest, searchedLabel, customerId);
        List<Label> labelList = pentestService.getVulnerabilityLabels(dataTablesRequest, searchedLabel, customerId);
        return DataTablesUtil.getResponse(dataTablesRequest.getDraw(), totalCount, totalCount, labelList);
    }

    @RequestMapping(value = "updateTag.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public void updateMessage(HttpServletRequest request, HttpServletResponse response) throws BizzyException {

        String label = ServletRequestUtils.getStringParameter(request, "label", "XX");
        
        if (BizzyUtil.isEmpty(label) || !RegexUtil.isAllowedText(label)) {
            logger.log(LogLevel.WARN, "Etiket alanında beklenmeyen karakterler tespit edildi.");
            throw new BizzyException("Etiket alanında beklenmeyen karakterler tespit edildi.");
        }
        
        User user = HttpUtil.getUser();
        Date date = new Date();

        Label newLabel = new Label();
        newLabel.setLabelId(BizzyUtil.generateGUID());
        newLabel.setName(label);
        newLabel.setCreator(user.getUsername());
        newLabel.setCreateDate(date);
        newLabel.setCustomerId(BizzyUtil.getCustomerIdByUser(user));

        pentestService.addVulnerabilityLabel(newLabel);
    }

    //Ajax tarafından çağrılıyor.
    @RequestMapping(value = "deleteTags.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    @ResponseStatus(value = HttpStatus.OK)
    public void deleteTags(HttpServletRequest request, HttpServletResponse response) throws BizzyException {

        logger.log(LogLevel.INFO, "etiket silme basladi");
        String[] labelsArr;

        labelsArr = ServletRequestUtils.getStringParameters(request, "labelIds[]");

        for (int i = 0; i < labelsArr.length; i++) {
            pentestService.removeVulnerabilityLabel(labelsArr[i]);
        }

        logger.log(LogLevel.INFO, "etiket silme başarı ile gerçekleşti");
    }

    /**
     * Taramalar sayfası
     *
     * @param request
     * @param response
     * @return mv
     * @throws BizzyException
     */
    @RequestMapping(value = "listScans.htm", method = {RequestMethod.GET})
    public ModelAndView listScans(HttpServletRequest request, HttpServletResponse response) throws BizzyException {
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user); 

        OccurrenceType[] scanOccurrenceForScheduled = OccurrenceType.values();

        ModelAndView mv = new ModelAndView();
        List<String> existingSources = pentestService.getDistinctSourceTypesByCustomerId(customerId);
        mv.addObject("existingSources", existingSources);
        mv.addObject(new PentestScan());
        mv.addObject(new Asset());
        mv.addObject("scanOccurrenceForScheduled", scanOccurrenceForScheduled);
        return mv;
        
    }

    /**
     * Taramaları grafik olarak karşılaştırma
     *
     * @param request
     * @param response
     * @return String
     * @throws JSONException
     */
    @RequestMapping(value = "scanDiffGraph.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String scanDiffGraph(HttpServletRequest request, HttpServletResponse response) throws JSONException {
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        String[] scansIds = ServletRequestUtils.getStringParameters(request, "scansIds[]");
        List<String> scans = Arrays.asList(scansIds);
        List<String> scansNames = customerService.getScansByCustomerId(customerId, scans);
        for(String scanName : scansNames){
            scanName = EscapeUtil.escapeForHtml(scanName);
        }
        List<Integer> assetCounts = new ArrayList<>();
        for (int i = 0; i < scans.size(); i++) {
            Integer a = customerService.getScannedAssetCountByCustomerId(customerId, scans.get(i));
            assetCounts.add(a);
        }
        List<Integer> level4or5assetCounts = new ArrayList<>();
        List<Integer> level4or5vulnerabilityCounts = new ArrayList<>();
        List<Integer> level3vulnerabilityCounts = new ArrayList<>();
        List<Integer> level2vulnerabilityCounts = new ArrayList<>();
        List<Integer> level1vulnerabilityCounts = new ArrayList<>();
        List<Float> riskScoreDiffCounts = new ArrayList<>();

        for (int i = 0; i < scans.size(); i++) {
            Integer a = customerService.getLevel5ScannedAssetCountByCustomerId(customerId, scans.get(i));
            level4or5assetCounts.add(a);
            Integer c = customerService.getLevel4or5ScannedVulnCountByCustomerId(customerId, scans.get(i));
            level4or5vulnerabilityCounts.add(c);
            Integer e = customerService.getLevelScannedVulnCountByCustomerId(customerId, scans.get(i), 3);
            level3vulnerabilityCounts.add(e);
            Integer f = customerService.getLevelScannedVulnCountByCustomerId(customerId, scans.get(i), 2);
            level2vulnerabilityCounts.add(f);
            Integer g = customerService.getLevelScannedVulnCountByCustomerId(customerId, scans.get(i), 1);
            level1vulnerabilityCounts.add(g);
            Float riskScore = pentestService.getTotalRiskScoreByScanId(scans.get(i), customerId);
            riskScoreDiffCounts.add(riskScore);
        }
        JSONObject obj = new JSONObject();
        obj.append("scans", scansNames);
        obj.append("assetCounts", assetCounts);
        obj.append("level4or5AssetCounts", level4or5assetCounts);
        obj.append("level4or5vulnerabilityCounts", level4or5vulnerabilityCounts);
        obj.append("level3vulnerabilityCounts", level3vulnerabilityCounts);
        obj.append("level2vulnerabilityCounts", level2vulnerabilityCounts);
        obj.append("level1vulnerabilityCounts", level1vulnerabilityCounts);
        obj.append("riskScoreDiffCounts", riskScoreDiffCounts);
        return obj.toString();
    }

    /**
     * Taramaları tablo olarak karşılaştırma
     *
     * @param request
     * @param response
     * @return String
     */
    @RequestMapping(value = "loadScanDiff.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String loadScanDiff(HttpServletRequest request, HttpServletResponse response) {

        DataTablesRequest dataTablesRequest = DataTablesUtil.getRequest(request);
        User user = HttpUtil.getUser();
        Locale locale = RequestContextUtils.getLocale(request);
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        String scan1Id = ServletRequestUtils.getStringParameter(request, "scan1", null);
        String scan2Id = ServletRequestUtils.getStringParameter(request, "scan2", null);
        boolean onlyDiff = ServletRequestUtils.getBooleanParameter(request, "onlyDiff", false);
        List<ScanDiff> scanDiffList = pentestService.getScanDiff(dataTablesRequest, customerId, scan1Id, scan2Id);
        for (ScanDiff scanDiff : scanDiffList) {
            if (!BizzyUtil.isEmpty(scanDiff.getStatuses())) {
                String[] statuses = scanDiff.getStatuses().split(",");
                String stat = "";
                for (String status : statuses) {
                    stat += messageSource.getMessage("genericdb." + status, locale);
                    stat += ",";
                }
                stat = stat.substring(0, stat.length() - 1);
                scanDiff.setStatuses(stat);
                if (scanDiff.getCommonVulnFirstStatuses() != null) {
                    List<String> firstStatuses = new LinkedList<>();
                    for (String status : scanDiff.getCommonVulnFirstStatuses()) {
                        firstStatuses.add(messageSource.getMessage("genericdb." + status, locale));
                    }
                    scanDiff.setCommonVulnFirstStatuses(firstStatuses);
                }
            }
            if (scanDiff.getCommonVulnSecondStatuses() != null) {
                List<String> secondStatuses = new LinkedList<>();
                for (String status : scanDiff.getCommonVulnSecondStatuses()) {
                    secondStatuses.add(messageSource.getMessage("genericdb." + status, locale));
                }
                scanDiff.setCommonVulnSecondStatuses(secondStatuses);
            }
        }
        int scanDiffCount = pentestService.getScanDiffCount(customerId, scan1Id, scan2Id, onlyDiff);
        scanDiffList = setDiffTableView(onlyDiff, scanDiffList, scan1Id, scan2Id);
        return DataTablesUtil.getResponse(dataTablesRequest.getDraw(), scanDiffCount, scanDiffCount, scanDiffList);
    }

    /**
     * Tamamlanan taramalar datatable
     *
     * @param request
     * @param response
     * @return
     */
    @RequestMapping(value = "loadScans.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String loadScans(HttpServletRequest request, HttpServletResponse response) {
        String archiveOrnot = ServletRequestUtils.getStringParameter(request, "isArchiveActive", null);
        String sourceFilter = ServletRequestUtils.getStringParameter(request, "sourceFilter", "all");
        DataTablesRequest dataTablesRequest = DataTablesUtil.getRequest(request);
        User user = HttpUtil.getUser();
        String scanCreatedBy = null;
        if(user.getRole().getId().equals("3")){
            scanCreatedBy = user.getUsername();
        }
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        int totalCount;
        List<PentestScan> scans;
        if (archiveOrnot.equals("true")) {
            totalCount = pentestService.getScansCount(dataTablesRequest, customerId, true, sourceFilter, false, scanCreatedBy);//Toplam kullanıcı sayısı        
            scans = pentestService.getScans(dataTablesRequest, customerId, true, sourceFilter, false, scanCreatedBy);
        } else {
            totalCount = pentestService.getScansCount(dataTablesRequest, customerId, false, sourceFilter, false, scanCreatedBy);//Toplam kullanıcı sayısı         
            scans = pentestService.getScans(dataTablesRequest, customerId, false, sourceFilter, false, scanCreatedBy);
        }

        for (PentestScan scan : scans) {
            scan.setVulnerabilityCount(pentestService.getVulnerabilityCountForScan(scan.getScanId()));
            scan.setAssetCount(pentestService.getScanAssetsCount(scan.getScanId()));
        }
        return DataTablesUtil.getResponse(dataTablesRequest.getDraw(), totalCount, totalCount, scans);
    }

    /**
     * Devam eden taramalar datatable
     *
     * @param request
     * @param response
     * @return
     */
    @RequestMapping(value = "loadRunningScans.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String loadRunningScans(HttpServletRequest request, HttpServletResponse response) {
        String sourceFilter = ServletRequestUtils.getStringParameter(request, "sourceFilter", null);
        DataTablesRequest dataTablesRequest = DataTablesUtil.getRequest(request);
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        int totalCount = pentestService.getRunningScanCount(dataTablesRequest, customerId, sourceFilter, false);
        List<PentestScan> scans = pentestService.getRunningScans(dataTablesRequest, customerId, sourceFilter, false);
        //Devam eden taramada varlık ve zafiyet oluşmuyor. Sayısını hesaplamaya gerek yok.
        /*ScanResultsFilter filter = null;
        for (PentestScan scan : scans) {
            filter = new ScanResultsFilter();
            filter.setScanId(scan.getScanId());
            scan.setVulnerabilityCount(pentestService.getScanResultsCount(filter));
            scan.setAssetCount(pentestService.getScanAssetsCount(scan.getScanId()));
        }*/
        return DataTablesUtil.getResponse(dataTablesRequest.getDraw(), totalCount, totalCount, scans);
    }

    @RequestMapping(value = "getScanDetails.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String getScanDetails(HttpServletRequest request, HttpServletResponse response) throws BizzyException {
        String scanId = ServletRequestUtils.getStringParameter(request, "scanId", null);
        String type = ServletRequestUtils.getStringParameter(request, "type", null);
        User user = HttpUtil.getUser();
        Map<String, String> scansMap = new HashMap<>();
        PentestScan scanDetails = null;
        if (scanId != null) {
            if (type.equals("scheduled")) {
                scanDetails = pentestService.getScheduledScanById(scanId);
            } else {
                scanDetails = pentestService.getScanById(scanId);
            }

            scansMap.put("name", EscapeUtil.escapeForHtml(scanDetails.getName()));
            scansMap.put("desc", EscapeUtil.escapeForHtml(scanDetails.getDescription()));
            scansMap.put("reqBy", scanDetails.getRequestedBy());
            if (scanDetails.getRequestDate() != null) {
                scansMap.put("reqDate", scanDetails.getRequestDate().toString());
            }
            if (scanDetails.getScanDate() != null) {
                scansMap.put("scanDate", scanDetails.getScanDate().toString());
            }
            if (scanDetails.getCompletionDate() != null) {
                scansMap.put("compDate", scanDetails.getCompletionDate().toString());
            }
            scansMap.put("active", String.valueOf(scanDetails.isActive()));
            scansMap.put("targets", EscapeUtil.escapeForHtml(scanDetails.getTargets()));
            scansMap.put("status", scanDetails.getStatus().getName());
            scansMap.put("policy", scanDetails.getPolicy().getName());
            scansMap.put("src", scanDetails.getSource().name());
        }
        return gson.toJson(scansMap);
    }
    
    @RequestMapping(value = "getActiveVulnList.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String getActiveVulnList(HttpServletRequest request, HttpServletResponse response) {
        String vulnId = ServletRequestUtils.getStringParameter(request, "vulnId", null);
        User user = HttpUtil.getUser();
        ScanVulnerability sv = customerService.getVulnerabilityById(vulnId);
        VulnerabilityFilter filter = new VulnerabilityFilter();
        filter.setIpAddress(sv.getVulnerability().getAsset().getIp());
        filter.setPort(sv.getVulnerability().getPort().getPortNumber());
        filter.setVulnName(sv.getVulnerability().getName());
        List<ScanVulnerability> list = customerService.getVulnerabilityDetails(filter);
        List<ScanVulnerability> filteredList = new LinkedList<>();
        for(ScanVulnerability item : list){
            if(!item.getScanVulnerabilityId().equals(sv.getScanVulnerabilityId())){
                filteredList.add(item);
            }
        }
        return gson.toJson(filteredList);
    }
    
    @RequestMapping(value = "setToPassive.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String setToPassive(HttpServletRequest request, HttpServletResponse response) {
        String vulnId = ServletRequestUtils.getStringParameter(request, "vulnId", null);
        ScanVulnerability sv = customerService.getVulnerabilityById(vulnId);
        VulnerabilityFilter filter = new VulnerabilityFilter();
        filter.setIpAddress(sv.getVulnerability().getAsset().getIp());
        filter.setPort(sv.getVulnerability().getPort().getPortNumber());
        filter.setVulnName(sv.getVulnerability().getName());
        List<ScanVulnerability> list = customerService.getVulnerabilityDetails(filter);
        List<ScanVulnerability> filteredList = new LinkedList<>();
        for (ScanVulnerability item : list) {
            if (!item.getScanVulnerabilityId().equals(sv.getScanVulnerabilityId())) {
                filteredList.add(item);
            }
        }
        if (filteredList.size() > 0) {
            customerService.updateVulnerabilityActiveness(vulnId, false);
            Ticket t = ticketService.getTicketByScanVulnerabilityId(vulnId);
            ticketService.deleteTicket(t.getTicketId());
            return "{\"status\":\"success\"}";
        } else {
            return "{\"status\":\"error\"}";
        }
        
    }

    @RequestMapping(value = "deleteScheduledScan.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String deleteScheduledScan(HttpServletRequest request, HttpServletResponse response) throws BizzyException {
        String scanId = ServletRequestUtils.getStringParameter(request, "scanId", null);
        User user = HttpUtil.getUser();
        String customerId = "";
        if (BizzyUtil.hasACustomerRole(user)) {
            customerId = BizzyUtil.getCustomerIdByUser(user);
        }
        if (scanId != null) {
            try {
                ScheduledPentestScan scan = pentestService.getScheduledScanById(scanId);
                //Yetkisiz erişimi önlemek için kontroller
                if (scan == null) {
                    logger.log(LogLevel.ERROR, "Böyle bir tarama yok ! Tarama Id: " + scanId);
                    throw new BizzyException("Böyle bir tarama yok ! ScanId: " + scanId);
                }
                if (!scan.getCustomer().getCustomerId().equals(customerId)) {
                    logger.log(LogLevel.ERROR, "Yetkisiz tarama erişimi ! Tarama Id: " + scanId);
                    throw new BizzyException("Yetkisiz tarama erişimi ! Tarama Id: " + scanId);
                }

                List<PentestScan> scans = pentestService.getScans(null, customerId, null, "all", false, null);

                for (PentestScan item : scans) {
                    if (item.getScheduledPentestScan() != null && scanId.equals(item.getScheduledPentestScan().getUuid())) {
                        item.setScheduledPentestScan(null);
                        pentestService.updateScan(item.getScanId());
                    }
                }

                pciService.deleteScheduledScan(scanId);
                if (scan.isCustomizedScan()) {
                    tiService.saveCustomizedScanAlert(customerId, scan.getRequestedBy(), AlertType.CUSTOMIZED_SCAN_DELETED, scan.getName(), scan.getSource().toString());
                }    
                PentestScan convertedScan = (PentestScan) Class.forName("tr.biznet.bizzy.service.pentest.domain.PentestScan").cast(scan);
                scanSchedulerService.deregisterJob(convertedScan);

                logger.log(LogLevel.INFO, "Tarama silme işlemi başarılı.");
            } catch (Exception ex) {
                logger.log(LogLevel.ERROR, "Tarama silme işlemi başarısız.", ex);
                throw new BizzyException("Tarama silme işlemi başarısız.", ex);
            }
        }
        return "{}";
    }

    //
    @RequestMapping(value = "deleteScheduledScans.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String deleteScheduledScans(HttpServletRequest request, HttpServletResponse response) throws BizzyException, ServletRequestBindingException {

        String[] scanIds = ServletRequestUtils.getRequiredStringParameters(request, "scanIds2[]");
        String scanId;
        if (scanIds != null && scanIds.length > 0) {

            for (int i = 0; i < scanIds.length; i++) {
                scanId = scanIds[i];

                //   String scanId = ServletRequestUtils.getStringParameter(request, "scanId", null);
                User user = HttpUtil.getUser();
                String customerId = "";
                if (BizzyUtil.hasACustomerRole(user)) {
                    customerId = BizzyUtil.getCustomerIdByUser(user);
                }
                if (scanId != null) {
                    try {
                        ScheduledPentestScan scan = pentestService.getScheduledScanById(scanId);
                        //Yetkisiz erişimi önlemek için kontroller
                        if (scan == null) {
                            logger.log(LogLevel.ERROR, "Böyle bir tarama yok ! Tarama Id: " + scanId);
                            throw new BizzyException("Böyle bir tarama yok ! ScanId: " + scanId);
                        }
                        if (!scan.getCustomer().getCustomerId().equals(customerId)) {
                            logger.log(LogLevel.ERROR, "Yetkisiz tarama erişimi ! Tarama Id: " + scanId);
                            throw new BizzyException("Yetkisiz tarama erişimi ! Tarama Id: " + scanId);
                        }
                        
                        List<PentestScan> scans = pentestService.getScans(null, customerId, null, "all", false, null);

                        for (PentestScan item : scans) {
                            if (item.getScheduledPentestScan() != null && scanId.equals(item.getScheduledPentestScan().getUuid())) {
                                item.setScheduledPentestScan(null);
                                pentestService.updateScan(item.getScanId());
                            }
                        }

                        pciService.deleteScheduledScan(scanId);
                        if (scan.isCustomizedScan()) {
                            tiService.saveCustomizedScanAlert(customerId, scan.getRequestedBy(), AlertType.CUSTOMIZED_SCAN_DELETED, scan.getName(), scan.getSource().toString());
                        }
                        PentestScan convertedScan = (PentestScan) Class.forName("tr.biznet.bizzy.service.pentest.domain.PentestScan").cast(scan);
                        scanSchedulerService.deregisterJob(convertedScan);
                        logger.log(LogLevel.INFO, "Tarama silme işlemi başarılı.");
                    } catch (Exception ex) {
                        logger.log(LogLevel.ERROR, "Tarama silme işlemi başarısız.", ex);
                        throw new BizzyException("Tarama silme işlemi başarısız.", ex);
                    }
                }

            }

        }

        return "{}";
    }

    //Ajax tarafından çağrılıyor.
    @RequestMapping(value = "addAssetGroup.json", method = {RequestMethod.POST}, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    @ResponseStatus(value = HttpStatus.OK)
    public String addAssetGroup(HttpServletRequest request, HttpServletResponse response, AssetGroup group) {
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        group.setCustomerId(customerId);
        if ("".equals(group.getParentGroupId())) {
            group.setParentGroupId(null);
        }
        if (group.getName().isEmpty() || !RegexUtil.isAllowedText(group.getName())) {
            logger.log(LogLevel.ERROR, "Varlık grubu adı önyüz doğrulaması atlatıldı!");
            return "-"; //Name validasyonu aşıldı.
        }

        String parent = group.getParentGroupId();
        int counter = 1;
        while (parent != null) {
            AssetGroup parentGroup = customerService.getAssetGroupById(parent);
            parent = parentGroup.getParentGroupId();
            counter += 1;
        }

        List<String> configurations = configurationService.getByKeyAndCustomerId("maxNestedGroup", customerId);
        int maxLevel = 0;
        if (configurations.isEmpty()) {
            maxLevel = 5;
        } else {
            maxLevel = Integer.parseInt(configurations.get(0));
        }

        if (counter > maxLevel) {
            return "{\"status\":\"maxLevel\"}";//Max level hatası önyüze basılır.
        }

        try {
            customerService.saveAssetGroup(group);
            logger.log(LogLevel.INFO, "Varlık grubu ekleme işlemi başarılı.");
        } catch (Exception ex) {
            logger.log(LogLevel.ERROR, "Varlık grubu eklenirken hata oluştu.", ex);
            return "-"; //Beklenmeyen hata durumu
        }

        return "{\"status\":\"success\"}";
    }

    /**
     * Planlı varlık keşfi güncelleme sayfası
     *
     * @param request
     * @param response
     * @param scheduledAssetDiscovery
     * @param result
     * @param redirectAttributes
     * @return mv
     * @throws Exception
     */
    @RequestMapping(value = "editScheduledHostScan.htm", method = {RequestMethod.GET, RequestMethod.POST})
    public ModelAndView editScheduledHostScan(HttpServletRequest request, HttpServletResponse response, ScheduledAssetDiscovery scheduledAssetDiscovery, BindingResult result, final RedirectAttributes redirectAttributes) throws Exception {
        ModelAndView mv = new ModelAndView();
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        String id = ServletRequestUtils.getStringParameter(request, "id", null);
        ScheduledAssetDiscovery scan = pentestService.getScheduledAssetDiscoveryById(id, customerId);
        List<Server> scanEngines = new LinkedList();
        List<Server> hostScanEngines = new LinkedList();
        List<String> targetList = new LinkedList<>();

        if (HttpUtil.isGet(request)) {
            mv.addObject(scan);
            mv.addObject("scan", scan);
            try {
                hostScanEngines = serverService.getHostDiscoveryServers(customerId);
                scanEngines.addAll(serverService.getServerNames(ServerType.NESSUS, customerId));
            } catch (Exception ex) {
                logger.log(LogLevel.ERROR, "Scanner listesi okunamadı.", ex);
            }
            targetList.add(scan.getTarget());
            mv.addObject("targetList", targetList);
            mv.addObject("hostScanEngines", hostScanEngines);
            mv.addObject("scanEngines", scanEngines);
            List<AssetGroup> assetGroups = customerService.getAssetGroups(null, customerId);
            mv.addObject("assetGroups", assetGroups);
            
            return mv;
        } else if (HttpUtil.isPost(request)) {
            AssetDiscovery convertedScan = (AssetDiscovery) Class.forName("tr.biznet.bizzy.service.pentest.domain.AssetDiscovery").cast(scan);
            hostScanSchedulerService.deregisterJob(convertedScan);
            Customer customer = customerService.getCustomer(customerId);
            
            Date now = new Date();
            scan.setName(scheduledAssetDiscovery.getName());
            scan.setDescription(scheduledAssetDiscovery.getDescription());
            String serverId = scheduledAssetDiscovery.getServer().getSettingId();
            Server server = serverService.getServer(serverId, customerId);
            scan.setServer(server);
            scan.setSource(server.getTypeByScanSource());
            scan.setTarget(scheduledAssetDiscovery.getTarget());
            scan.setExcludeIps(scheduledAssetDiscovery.getExcludeIps());
            scan.setScanner(scheduledAssetDiscovery.getScanner());
            scan.setPolicyId(scheduledAssetDiscovery.getPolicyId());
            scan.setTimezone(scheduledAssetDiscovery.getTimezone());
            scan.setServerIdForScan(scheduledAssetDiscovery.getServerIdForScan());
            scan.setScannerIdForScan(scheduledAssetDiscovery.getScannerIdForScan());
            scan.setPolicyIdForScan(scheduledAssetDiscovery.getPolicyIdForScan());
            scan.setTimezoneForScan(scheduledAssetDiscovery.getTimezoneForScan());
            scan.setMinRiskLevel(scheduledAssetDiscovery.getMinRiskLevel());
            scan.setActive(scheduledAssetDiscovery.isActive());
            scan.setAlarmLevel(scheduledAssetDiscovery.getAlarmLevel());
            scan.setScanDate(scheduledAssetDiscovery.getScanDate());
            scan.setLaunch(scheduledAssetDiscovery.getLaunch());
            scan.setRecurrence(scheduledAssetDiscovery.getRecurrence());
            scan.setScanProscriptiveTimeStart(scheduledAssetDiscovery.getScanProscriptiveTimeStart());
            scan.setScanProscriptiveTimeEnd(scheduledAssetDiscovery.getScanProscriptiveTimeEnd());            
            scan.setResultAction(scheduledAssetDiscovery.getResultAction());
            scan.setAssetGroupId(scheduledAssetDiscovery.getAssetGroupId());
            scan.setRequestDate(now);
            scan.setCustomer(customer);
            scan.setExcludeIps(scheduledAssetDiscovery.getExcludeIps());
            scan.setMail(scheduledAssetDiscovery.getMail());
            scan.setRequestedBy(user.getUsername());                                 //ARDINDAN PLANLI TARAMA UPDATE EDİLİR, 
            scan.setUuid(id);
            scan.setCompletedScanCount(0);
            pentestService.updateScheduledHostScan(scan);
            AssetDiscovery assetDiscovery = (AssetDiscovery) Class.forName("tr.biznet.bizzy.service.pentest.domain.AssetDiscovery").cast(scan);
            if (scan.isActive()) {
                hostScanSchedulerService.registerJob(assetDiscovery);
            }
            return HttpUtil.sendRedirect("listAssetDiscoveries.htm");
        } else {
            return null;
        }
    }

    /**
     * Planlı zafiyet taraması güncelleme sayfası
     *
     * @param request
     * @param response
     * @param scheduledPentestScan
     * @param result
     * @param redirectAttributes
     * @return mv
     * @throws ClassNotFoundException
     * @throws NoSuchMethodException
     * @throws ParseException
     * @throws SchedulerException
     * @throws BizzySecurityException
     */
    @RequestMapping(value = "editScheduledScan.htm", method = {RequestMethod.GET, RequestMethod.POST})
    public ModelAndView editScheduledScan(HttpServletRequest request, HttpServletResponse response, ScheduledPentestScan scheduledPentestScan, BindingResult result, final RedirectAttributes redirectAttributes) throws ClassNotFoundException, NoSuchMethodException, ParseException, SchedulerException, BizzySecurityException {
        ModelAndView mv = new ModelAndView();
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        Customer customer = customerService.getCustomer(customerId);
        String scanId = ServletRequestUtils.getStringParameter(request, "scanId", null);
        ScheduledPentestScan scan = pentestService.getScheduledScanById(scanId);

        if (HttpUtil.isGet(request)) {
            List<ScanAsset> assetList = new LinkedList<>();
            if(!scan.isSyncScan()) {
                List<Asset> ipList = customerService.getAssetsByCustomerId(customerId);
                for (Asset asset : ipList) {
                    String targets = scan.getTargets();
                    if (targets != null && asset != null && asset.getIp() != null && !targets.equals(asset.getIp())) {
                        ScanAsset scanAsset = new ScanAsset();
                        scanAsset.setScannedIp(asset.getIp());
                        assetList.add(scanAsset);
                    }
                }
                String targets = scan.getTargets();
                ScanAsset scanAsset = new ScanAsset();
                scanAsset.setScannedIp(targets);
                assetList.add(scanAsset);

                String excludedIps = scan.getExcludeIps();
                int temp = 0;
                if (excludedIps != null) {
                    for (Asset asset : ipList) {
                        if (excludedIps.equals(asset.getIp())) {
                            temp += 1;
                        }
                    }
                }
                if (temp == 0 && excludedIps != null) {
                    ScanAsset scanAssetEx = new ScanAsset();
                    scanAssetEx.setScannedIp(excludedIps);
                    assetList.add(scanAssetEx);
                }
            }

            mv.addObject(scan);
            mv.addObject("scan", scan);
            List<Server> scanEngines = new LinkedList();
            try {
                scanEngines = pentestService.getVulnerabilityScanEngines(customerId);
            } catch (BizzyException ex) {
                logger.log(LogLevel.ERROR, "Scanner listesi okunamadı.", ex);
            }
            mv.addObject("assetList", assetList);
            mv.addObject("scanEngines", scanEngines);
            return mv;

        } else if (HttpUtil.isPost(request)) {

            //Planlı tarama güncellenirken, ilk olarak önceki planlı job silinir.
            PentestScan convertedScan = (PentestScan) Class.forName("tr.biznet.bizzy.service.pentest.domain.PentestScan").cast(scan);
            scanSchedulerService.deregisterJob(convertedScan);

            Date now = new Date();
            scan.setName(scheduledPentestScan.getName());
            scan.setDescription(scheduledPentestScan.getDescription());
            String serverId = scheduledPentestScan.getServer().getSettingId();
            Server server = serverService.getServer(serverId, customerId);
            scan.setServer(server);
            scan.setSource(server.getTypeByScanSource());
            scan.setTargets(scheduledPentestScan.getTargets());
            scan.setIncludedIps(scan.getTargets());
            scan.setExcludeIps(scheduledPentestScan.getExcludeIps());
            scan.setScanner(scheduledPentestScan.getScanner());
            scan.setPolicy(scheduledPentestScan.getPolicy());
            scan.setTimezone(scheduledPentestScan.getTimezone());
            scan.setMinRiskLevel(scheduledPentestScan.getMinRiskLevel());
            scan.setActive(scheduledPentestScan.isActive());
            scan.setUpdateOperatingSystem(scheduledPentestScan.getUpdateOperatingSystem());
            scan.setScanDate(scheduledPentestScan.getScanDate());
            scan.setOccurrence(scheduledPentestScan.getOccurrence());
            scan.setRecurrence(scheduledPentestScan.getRecurrence());
            scan.setScanProscriptiveTimeStart(scheduledPentestScan.getScanProscriptiveTimeStart());
            scan.setScanProscriptiveTimeEnd(scheduledPentestScan.getScanProscriptiveTimeEnd());
            scan.setRequestDate(now);
            scan.setCustomer(customer);
            scan.setRequestedBy(user.getUsername());                                 //ARDINDAN PLANLI TARAMA UPDATE EDİLİR, 
            scan.setUuid(scanId);
            scan.setCompletedScanCount(0);
            pentestService.updateScheduledScan(scan);
            PentestScan pentestScan = (PentestScan) Class.forName("tr.biznet.bizzy.service.pentest.domain.PentestScan").cast(scan);
            if (scan.isActive()) {
                scanSchedulerService.registerJob(pentestScan);
            }
            if (scan.isSslScan()) {
                return HttpUtil.sendRedirect("../ssl/listSslScans.htm");
            } else {
                return HttpUtil.sendRedirect("listScans.htm");
            }
        } else {
            return null;
        }
    }

    /**
     * Planlı Taramalar datatable
     * @param request
     * @param response
     * @return String
     * @throws ParseException 
     */
    @RequestMapping(value = "loadScheduledScans.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String loadScheduledScans(HttpServletRequest request, HttpServletResponse response) throws ParseException {

        String sourceFilter = ServletRequestUtils.getStringParameter(request, "sourceFilter", null);
        DataTablesRequest dataTablesRequest = DataTablesUtil.getRequest(request);
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        int totalCount = pentestService.getScheduledScansCount(dataTablesRequest, customerId, sourceFilter, false);
        List<ScheduledPentestScan> scans = pentestService.getScheduledScans(dataTablesRequest, customerId, sourceFilter, false);
        setPreviousAndNextScanDates(scans, null);
        return DataTablesUtil.getResponse(dataTablesRequest.getDraw(), totalCount, totalCount, scans);
    }

    /**
     * Tarama kopyalama
     * @param request
     * @param response
     * @throws Exception 
     */
    @RequestMapping(value = "copyScan.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    @ResponseStatus(value = HttpStatus.OK)
    public void copyScan(HttpServletRequest request, HttpServletResponse response) throws Exception {
        logger.log(LogLevel.INFO, "tarama kopyalama basladi");
        String id = ServletRequestUtils.getStringParameter(request, "scanId", null);
        pentestService.copyScan(id);
        logger.log(LogLevel.INFO, "tarama kopyalama başarı ile gerçekleşti");
    }

    /**
     * Tarama silme
     * @param request
     * @param response
     * @throws BizzyException 
     */
    @RequestMapping(value = "deleteScan.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    @ResponseStatus(value = HttpStatus.OK)
    public void deleteScan(HttpServletRequest request, HttpServletResponse response) throws BizzyException {
        logger.log(LogLevel.INFO, "tarama silme basladi");
        String scanId = ServletRequestUtils.getStringParameter(request, "scanId", null);
        pentestService.deleteScan(scanId);
        logger.log(LogLevel.INFO, "tarama silme başarı ile gerçekleşti");
    }

    /**
     * Tarama arşivleme
     * @param request
     * @param response
     * @throws BizzyException
     * @throws ServletRequestBindingException 
     */
    @RequestMapping(value = "archiveScans.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public void archiveScans(HttpServletRequest request, HttpServletResponse response) throws BizzyException, ServletRequestBindingException {
        logger.log(LogLevel.INFO, "Tarama arşivleme işlemi başlatıldı.");
        String[] scanIds = ServletRequestUtils.getRequiredStringParameters(request, "scanIds2[]");
        for (String scanId : scanIds) {
            pentestService.archiveScan(scanId);
        }
    }

    /**
     * Taramaları arşivden çıkarma
     * @param request
     * @param response
     * @throws BizzyException
     * @throws ServletRequestBindingException 
     */
    @RequestMapping(value = "unarchiveScans.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public void unarchiveScans(HttpServletRequest request, HttpServletResponse response) throws BizzyException, ServletRequestBindingException {
        logger.log(LogLevel.INFO, "Tarama arşivden geri alma işlemi başlatıldı.");
        String[] scanIds = ServletRequestUtils.getRequiredStringParameters(request, "scanIds2[]");
        for (int i = 0; i < scanIds.length; i++) {
            pentestService.unarchiveScan(scanIds[i]);
        }
    }

    //
    @RequestMapping(value = "deleteScans.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    @ResponseStatus(value = HttpStatus.OK)
    public void deleteScans(HttpServletRequest request, HttpServletResponse response) throws BizzyException, ServletRequestBindingException {
        logger.log(LogLevel.INFO, "tarama silme basladı");
        String[] scanIds = ServletRequestUtils.getRequiredStringParameters(request, "scanIds2[]");
        for (int i = 0; i < scanIds.length; i++) {
            PentestScan scan = pentestService.getScanById(scanIds[i]);
            pentestService.deleteScan(scanIds[i]);
            if (scan.isSslScan()) {
                try {
                    sslService.deleteSslScanResults(scanIds[i]);
                } catch (Exception ex) {

                }
            }
        }
    }

    @RequestMapping(value = "changeScheduledScanStatus.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String changeScheduledScanStatus(HttpServletRequest request, HttpServletResponse response) {
        try {
            String scanId = ServletRequestUtils.getStringParameter(request, "scanId", null);
            boolean status = ServletRequestUtils.getBooleanParameter(request, "status", true);
            pentestService.changeScheduledScanStatus(scanId, status);

            ScheduledPentestScan scheduledPentestScan = pentestService.getScheduledScanById(scanId);

            PentestScan pentestScan = (PentestScan) Class.forName("tr.biznet.bizzy.service.pentest.domain.PentestScan").cast(scheduledPentestScan);

            if (scheduledPentestScan.isActive()) {
                scanSchedulerService.registerJob(pentestScan);
            } else {
                scanSchedulerService.deregisterJob(pentestScan);
            }
        } catch (Exception ex) {
            Logger.getLogger(PentestController.class.getName()).log(Level.SEVERE, null, ex);
            return "{\"success\":false}";
        }
        return "{\"success\":true}";
    }

    @RequestMapping(value = "changeScheduledHostStatus.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String changeScheduledHostStatus(HttpServletRequest request, HttpServletResponse response) {
        try {
            User user = HttpUtil.getUser();
            String customerId = BizzyUtil.getCustomerIdByUser(user);
            String id = ServletRequestUtils.getStringParameter(request, "id", null);
            boolean status = ServletRequestUtils.getBooleanParameter(request, "status", true);
            pentestService.changeScheduledHostStatus(id, status);

            ScheduledAssetDiscovery scheduledAssetDiscovery = pentestService.getScheduledAssetDiscoveryById(id, customerId);

            AssetDiscovery assetDiscovery = (AssetDiscovery) Class.forName("tr.biznet.bizzy.service.pentest.domain.AssetDiscovery").cast(scheduledAssetDiscovery);

            if (scheduledAssetDiscovery.isActive()) {
                hostScanSchedulerService.registerJob(assetDiscovery);
            } else {
                hostScanSchedulerService.deregisterJob(assetDiscovery);
            }
        } catch (Exception ex) {
            Logger.getLogger(PentestController.class.getName()).log(Level.SEVERE, null, ex);
            return "{\"success\":false}";
        }
        return "{\"success\":true}";
    }

    //
    @RequestMapping(value = "deleteAssetDiscoveries.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    @ResponseStatus(value = HttpStatus.OK)
    public void deleteAssetDiscoveries(HttpServletRequest request, HttpServletResponse response) throws BizzyException, ServletRequestBindingException {
        logger.log(LogLevel.INFO, "varlık keşif taramaları silme işlemi başladı.");
        String[] scanIds = ServletRequestUtils.getRequiredStringParameters(request, "scanIds[]");
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);

        for (int i = 0; i < scanIds.length; i++) {
            String scanId = scanIds[i];
            if (scanId != null) {
                try {
                    AssetDiscovery scan = pentestService.getAssetDiscoveryById(scanId, customerId);
                    //Yetkisiz erişimi önlemek için kontroller
                    if (scan == null) {
                        logger.log(LogLevel.ERROR, "Böyle bir varlık keşfi taraması yok ! Tarama Id: " + scanId);
                        throw new BizzyException("Böyle bir varlık keşfi taraması yok ! ScanId: " + scanId);
                    }
                    if (!scan.getCustomer().getCustomerId().equals(customerId)) {
                        logger.log(LogLevel.ERROR, "Yetkisiz varlık keşfi taraması erişimi ! Tarama Id: " + scanId);
                        throw new BizzyException("Yetkisiz varlık keşfi taraması erişimi ! Tarama Id: " + scanId);
                    }

                    pentestService.deleteAssetDiscovery(scanId);
                    //Tarama devam ediyorsa durduruyoruz.
                    if (scan.getStatus().equals(ScanStatus.RUNNING)) {
                        switch (scan.getSource()) {
                            case NESSUS:
                                nessusService.stopAssetDiscovery(scan);
                                break;

                            case NMAP:
                                nmapScanService.stopScan(scan);
                                break;

                            default:
                                break;
                        }
                    }
                    logger.log(LogLevel.INFO, "varlık keşfi taraması silme işlemi başarılı.");
                } catch (Exception ex) {
                    logger.log(LogLevel.ERROR, "varlık keşfi taraması silme işlemi başarısız.", ex);
                    throw new BizzyException("varlık keşfi taraması silme işlemi başarısız.", ex);
                }
            }
        }
        logger.log(LogLevel.INFO, "varlık keşif taramaları silme işlemi tamamlandı.");
    }

    //
    //Ajax tarafından çağrılıyor.
    @RequestMapping(value = "deleteAssetDiscovery.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String deleteAssetDiscovery(HttpServletRequest request, HttpServletResponse response) throws BizzyException {
        String scanId = ServletRequestUtils.getStringParameter(request, "scanId", null);
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        if (scanId != null) {
            try {
                AssetDiscovery scan = pentestService.getAssetDiscoveryById(scanId, customerId);
                //Yetkisiz erişimi önlemek için kontroller
                if (scan == null) {
                    logger.log(LogLevel.ERROR, "Böyle bir tarama yok ! Tarama Id: " + scanId);
                    throw new BizzyException("Böyle bir tarama yok ! ScanId: " + scanId);
                }
                if (!scan.getCustomer().getCustomerId().equals(customerId)) {
                    logger.log(LogLevel.ERROR, "Yetkisiz tarama erişimi ! Tarama Id: " + scanId);
                    throw new BizzyException("Yetkisiz tarama erişimi ! Tarama Id: " + scanId);
                }

                pentestService.deleteAssetDiscovery(scanId);
                //Tarama devam ediyorsa durduruyoruz.
                if (scan.getStatus().equals(ScanStatus.RUNNING)) {
                    switch (scan.getSource()) {
                        case NESSUS:
                            nessusService.stopAssetDiscovery(scan);
                            break;

                        case NMAP:
                            nmapScanService.stopScan(scan);
                            break;

                        default:
                            break;
                    }
                }
                logger.log(LogLevel.INFO, "Tarama silme işlemi başarılı.");
            } catch (Exception ex) {
                logger.log(LogLevel.ERROR, "Tarama silme işlemi başarısız.", ex);
                throw new BizzyException("Tarama silme işlemi başarısız.", ex);
            }
        }
        return "{}";
    }

    //Ajax tarafından çağrılıyor.
    @RequestMapping(value = "addScanResultAsAsset.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String addScanResultAsAsset(HttpServletRequest request, HttpServletResponse response) throws BizzyException {
        String[] resultIds = ServletRequestUtils.getStringParameters(request, "resultIds[]");
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        try {
            for (String resultId : resultIds) {

                AssetDiscoveryResult result = pentestService.getAssetDiscoveryResult(resultId);
                Asset asset = customerService.getAssetByIp(result.getIp(), customerId);

                if (asset == null) {
                    if (BizzyUtil.isEmpty(result.getIp()) || result.getIp().equals(" ")) {
                        logger.log(LogLevel.WARN, "Empty Ip while saving asset!");
                        continue;
                    }
                    asset = new Asset();
                    asset.setAssetType("IP");
                    asset.setIp(result.getIp());
                    asset.setOperatingSystem(result.getOperatingSystem());
                    asset.setActive(true);
                    asset.setCustomerId(customerId);

                    assetService.saveAsset(asset);
                } else {
                    logger.log(LogLevel.WARN, "Bu varlık sistemde zaten kayıtlı: " + result.getIp());
                }
            }
        } catch (Exception ex) {
            logger.log(LogLevel.ERROR, "Varlık ekleme işlemi başarısız.", ex);
            throw new BizzyException("Tarama silme işlemi başarısız.", ex);
        }
        return "{}";
    }

    /**
     * Pentest taraması exportu alma işlemi
     *
     * @param request
     * @param response
     * @throws BizzyException
     * @throws ServletRequestBindingException
     */
    @RequestMapping(value = "exportPentestResult.htm", method = {RequestMethod.GET})
    public void getJsonReport(HttpServletRequest request, HttpServletResponse response) throws BizzyException, ServletRequestBindingException {

        String scanId = ServletRequestUtils.getStringParameter(request, "scanId", null);
        String assetFilter = ServletRequestUtils.getStringParameter(request, "assetFilter", "");
        String[] scanIds = new String[]{scanId};

        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);

        List<ScanAsset> scanAssets = pentestService.getScannedAssetsByScanId(scanId);
        for (ScanAsset scanAsset : scanAssets) {
            VulnerabilityFilter filter = new VulnerabilityFilter();
            filter.setCustomerId(customerId);
            filter.setActive(true);
            filter.setScan(scanIds);
            filter.setAssetId(scanAsset.getAssetId());
            List<ScanVulnerability> vulnerabilities = customerService.getVulnerabilityDetailsForScanReport(filter);
            for (ScanVulnerability item : vulnerabilities) {
                ScanVulnerability sv = customerService.getVulnerabilityById(item.getScanVulnerabilityId());
                List<tr.biznet.bizzy.service.file.entity.File> files = fileService.getFileListByDataTypeAndTableIdAndCustomerIdWithoutData(customerId, sv.getVulnerability().getVulnerabilityId(), FileDataTypeEnum.VULNERABILITY.getType());
                for (tr.biznet.bizzy.service.file.entity.File file : files) { // ZAFİYET DOSYALARI İÇERİĞİ
                    try {
                        tr.biznet.bizzy.service.file.entity.File tempFile = fileService.getFileByKeyAndCustomerId(customerId, file.getFileId());
                        InputStream is = tempFile.getDataStream();
                        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
                        int nRead;
                        byte[] data = new byte[16384];

                        while ((nRead = is.read(data, 0, data.length)) != -1) {
                            buffer.write(data, 0, nRead);
                        }
                        is.close();
                        file.setData(buffer.toByteArray());
                        file.setFileDataType(FileDataTypeEnum.VULNERABILITY.getType());
                        file.setFileExtension(tempFile.getFileExtension());
                    } catch (IOException ex) {
                        logger.log(LogLevel.ERROR, "Export sırasında zafiyet dosyası hatası.", ex);
                    }
                }
                List<ProofFile> proofFiles = fileService.getProofFileListByDataTypeAndTableIdAndCustomerIdWithoutData(customerId, sv.getScanVulnerabilityId(), FileDataTypeEnum.VULNERABILITY.getType());
                for (ProofFile file : proofFiles) { // KANIT DOSYALARI İÇERİĞİ
                    try {
                        ProofFile tempFile = fileService.getProofFileByKeyAndCustomerId(customerId, file.getProofFileId());
                        InputStream is = tempFile.getDataStream();
                        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
                        int nRead;
                        byte[] data = new byte[16384];

                        while ((nRead = is.read(data, 0, data.length)) != -1) {
                            buffer.write(data, 0, nRead);
                        }
                        is.close();
                        file.setData(buffer.toByteArray());
                        file.setFileDataType(FileDataTypeEnum.VULNERABILITY.getType());
                        file.setFileExtension(tempFile.getFileExtension());
                    } catch (IOException ex) {
                        logger.log(LogLevel.ERROR, "Export sırasında zafiyet dosyası hatası.", ex);
                    }
                }
                List<ImageFile> images = fileService.getImageFileListByDataTypeAndTableIdAndCustomerIdWithData(customerId, sv.getScanVulnerabilityId(), FileDataTypeEnum.VULNERABILITY.getType());  // RESİMLER İÇERİĞİ
                item.setImages(images);
                List<WebApp> webApps = customerService.getWebApps(null, item.getScanVulnerabilityId());
                item.setWebApps(webApps);
                item.setProofFileList(proofFiles);
                item.getVulnerability().setFileList(files);
                item.getVulnerability().setLabels(sv.getVulnerability().getLabels());
                item.getVulnerability().setCveIdList(sv.getVulnerability().getCveIdList());
                item.setCreateDate(null);
                item.setUpdateDate(null);
                item.getVulnerability().setCreateDate(null);
                item.getVulnerability().setUpdateDate(null);
                if (item.getVulnerability().getPort().getPortNumber() != null) {
                    item.setPort(item.getVulnerability().getPort());
                } else {
                    item.setPort(null);
                }
            }
            scanAsset.setScanVulnerabilityList(vulnerabilities);
        }

        List<ScanAsset> filteredScanAssets = new LinkedList<>();
        if (assetFilter.equals("")) {
            // varlık filtresi yoksa tüm tarama kapsamının çıktısı alınır.
            filteredScanAssets = scanAssets;
        } else {
            // varlık filtresi var ise, seçilen varlıklara ait zafiyetlerin çıktısı alınır.
            assetFilter = assetFilter.substring(0, assetFilter.length() - 1);
            String[] assetIps = assetFilter.split(",");
            for (ScanAsset sa : scanAssets) {
                for (String assetIp : assetIps) {
                    if (assetIp.equals(sa.getScannedIp())) {
                        filteredScanAssets.add(sa);
                    }
                }
            }
        }

        Gson gson = new Gson();
        String jsonInString = gson.toJson(filteredScanAssets);

        try {
            response.setContentType("application/zip");
            response.setHeader("Content-Transfer-Encoding", "binary");
            response.setHeader("Content-Disposition", "attachment; filename=Bizzy Pentest.zip");

            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ZipOutputStream zout = new ZipOutputStream(baos);
            zout.putNextEntry(new ZipEntry("Bizzy Pentest.json"));
            zout.write(jsonInString.getBytes(Charset.forName("UTF-8")));
            zout.closeEntry();
            zout.close();
            StreamUtils.copy(baos.toByteArray(), response.getOutputStream());
            baos.close();
            // response.getOutputStream().write();
            response.flushBuffer();
            response.setStatus(HttpServletResponse.SC_OK);

        } catch (Exception ex) {
            logger.log(LogLevel.ERROR, "Dosya okunurken hata oluştu.", ex);
            throw new BizzyException("Dosya okunurken hata oluştu.", ex);
        }

    }

    //Modal submit edildiğinde bu metod çağırılıyor.
    @RequestMapping(value = "startScan.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public PentestScan startScan(HttpServletRequest request, HttpServletResponse response, PentestScan scan, BindingResult result, final RedirectAttributes redirectAttributes) throws BizzyException, BizzySecurityException {
        Locale locale = RequestContextUtils.getLocale(request);
        Date now = new Date();
        boolean scheduled = ServletRequestUtils.getBooleanParameter(request, "scheduledRadio", false);
        scan.setScheduled(scheduled);
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        if (!scan.isPentestScan()) {
            scan.setServer(serverService.getServer(scan.getServer().getSettingId(), customerId));
        }

        ScanValidator validator = new ScanValidator();
        validator.validate(scan, result);

        List<String> errorList = new LinkedList();

        //Hata varsa errorList'e ekleyip json ile gönderilir.
        if (result.hasErrors()) {
            for (Object object : result.getAllErrors()) {
                if (object instanceof FieldError) {
                    FieldError fieldError = (FieldError) object;
                    errorList.add(messageSource.getMessage(fieldError.getCode(), locale));
                }
            }
            if (!scan.isPentestScan()) {
                scan.getServer().setUsername(null);
                scan.getServer().setPassword(null);
            }
            scan.setErrorList(errorList);
            return scan;
        }

        //Host Discovery'den geliyorsa target değişkeni bizim seçilen result'larımız oluyor.
        if (scan.isHostDiscovery()) {
            List<ScanAsset> scanAssets = new LinkedList<>();
            ScanAsset sa = new ScanAsset();
            List<String> ids = Arrays.asList(scan.getTargets().split("\\s*,\\s*")); //Host discovery sonuç id'leri, bunlar ile ip bilgisini alacağız.
            String ipsToScan = "";
            for (String resultId : ids) {
                AssetDiscoveryResult pasr = pentestService.getAssetDiscoveryResult(resultId);
                ipsToScan += pasr.getIp() + ", ";
            }
            ipsToScan = ipsToScan.substring(0, ipsToScan.length() - 2);

            sa.setScannedIp(ipsToScan); // Taranacak IPlerin virgüllü halini vermiş olduk.
            scanAssets.add(sa);
            scan.setScanAssets(scanAssets);
            scan.setOccurrence(OccurrenceType.ON_DEMAND);// Anlık tarama
        }

        if (scan.getOccurrence() == OccurrenceType.ON_DEMAND) {    //ON_DEMAND seçiliyse bi kere çalışacak
            scan.setRecurrence(1);
        }
        if (scan.getRecurrence() == null || scan.getRecurrence() == 0 || scan.getRecurrence() > 100) { // RECCURENCE 1-100 ARASI DEĞİLSE
            scan.setRecurrence(-1);                        // RECCURENCE VERITABANI KAYDI İÇİN -1 OLARAK SET EDİLİR (SÜREKLİ TARAMA)
        }

        List<PentestScan> scanList = pentestService.getScans(null, customerId, null, "all", false, null);
        for (PentestScan ps : scanList) {
            if (scan.getName().equals(ps.getName())) {
                errorList.add("scanValidator.nameInvalid");
                scan.setErrorList(errorList);
                if (!scan.isPentestScan()) {
                    scan.getServer().setUsername(null);
                    scan.getServer().setPassword(null);
                }
                return scan;
            }
        }
        List<ScheduledPentestScan> scheduledScanList = pentestService.getScheduledScans(null, customerId, "all", false);
        for (ScheduledPentestScan ps : scheduledScanList) {
            if (scan.getName().equals(ps.getName())) {
                errorList.add("scanValidator.nameInvalid");
                scan.setErrorList(errorList);
                if (!scan.isPentestScan()) {
                    scan.getServer().setUsername(null);
                    scan.getServer().setPassword(null);
                }
                return scan;
            }
        }

        String includeIps = pentestService.parseScopeIps(scan); //IP listesi parse ediliyor, aralık ya da virgülle ayrılmış olarak girilebilme durumları handle ediliyor.
        scan.setRequestDate(now);
        scan.setTargets(includeIps);
        
        Customer customer = new Customer();
        customer.setCustomerId(customerId);
        scan.setCustomer(customer);
        try {
            pentestService.createPentestScan(scan);
        } catch (Exception ex) {
            logger.log(LogLevel.ERROR, "Yeni tarama başlatılırken hata oluştu.", ex);
            throw new BizzyException("Yeni tarama başlatılırken hata oluştu." + ex.getMessage(), ex);
        }
        
        if (!scan.isPentestScan()) {
            scan.getServer().setUsername(null);
            scan.getServer().setPassword(null);
        }
        return scan;
    }

    public void createHostScan(AssetDiscovery scan) throws BizzySecurityException, Exception {
        if (!scan.isScheduled()) {
            sendHostScanRequest(scan);  //İlgili araç üzerinden direkt tarama başlatılır.
        } else {
            sendScheduledHostScanRequest(scan); //Belirlenen tarihte tarama yapılması için job oluşturulur.
        }
    }

    private void sendScheduledHostScanRequest(AssetDiscovery scan) throws Exception {
        scan.setStatus(ScanStatus.SCHEDULED);
        scan.setActive(true);
        String scanId = BizzyUtil.generateGUID();
        scan.setId(scanId);
        Server server = scan.getServer();

        switch (ServerType.findWithType(server.getType())) {
            case NESSUS:
                logger.log(LogLevel.INFO, "Nessus üzerinden varlık keşfi yapılıyor. Tarama aracı: " + server.getName());
                scan.setSource(Source.NESSUS);
                break;
            case NMAP:
                logger.log(LogLevel.INFO, "Nmap üzerinden varlık keşfi yapılıyor. Tarama aracı: " + server.getName());
                scan.setSource(Source.NMAP);

                if (BizzyUtil.isEmpty(scan.getPorts())) {
                    scan.setPorts(server.getFolderId()); //Default port değerleri bu alandan alınıyor.
                }

                if (BizzyUtil.isEmpty(scan.getParams())) {
                    scan.setParams(server.getDomain()); //Default nmap parametreleri bu alandan alınıyor.
                }
                break;
            default:
                break;
        }

        pentestService.saveScheduledHostScan(scan);//Tarama kaydet
        hostScanSchedulerService.registerJob(scan);
    }

    private void sendHostScanRequest(AssetDiscovery scan) throws Exception {
        String scanId;
        scan.setStatus(ScanStatus.QUEUED);
        scan.setScanDate(new Date());
        Server server = scan.getServer();
        switch (ServerType.findWithType(server.getType())) {
            case NESSUS:
                logger.log(LogLevel.INFO, "Nessus üzerinden varlık keşfi yapılıyor. Tarama aracı: " + scan.getServer().getName());

                scanId = nessusService.createAndLaunchHostScan(scan);//Tarama başlat
                try {
                      String currentNessusVersion = nessusService.getNessusApiKeyVersion(server);
                      pentestService.saveNessusVersion(currentNessusVersion,server.getName());

                      String localNessusVersion = pentestService.getLocalNessusVersion(server.getName());
                
               
                      if(!currentNessusVersion.equals(localNessusVersion)) {
                            pentestService.updateNessusVersion(currentNessusVersion,server.getName());
                            nessusService.updateApiKey(server);
                      }
                }
                catch(Exception ex) {
                   logger.log(LogLevel.INFO, "Bizzy üzerindeki nessus tanımında api key güncellenmesinde hata ! " + ex);
                }
                
                
                scan.setId(BizzyUtil.generateGUID());
                scan.setToolScanId(scanId);
                scan.setSource(Source.NESSUS);

                logger.log(LogLevel.INFO, "Nessus üzerinden varlık keşfi için tarama oluşturuldu. Tarama No: " + scanId);
                
                //Varlı keşfi yasaklı zaman için job oluşturuyoruz.
                //Pause job oluşturuyoruz. Pause job çalıştıktan sonra resume job oluşuyor.
                if (!BizzyUtil.isEmpty(scan.getScanProscriptiveTimeStart())) {
                    logger.log(LogLevel.INFO, "Varlık keşfi yasaklı zaman kontrolü için pause job oluşturuluyor: " + scan.getName());
                    hostScanStatusService.registerPauseJob(scan);
                }
                pentestService.saveHostScan(scan);//Tarama kaydet
                
         

                break;
            case NMAP:
                logger.log(LogLevel.INFO, "Nmap üzerinden varlık keşfi yapılıyor. Tarama aracı: " + scan.getServer().getName());

                scan.setId(BizzyUtil.generateGUID());
                scan.setSource(Source.NMAP);

                if (BizzyUtil.isEmpty(scan.getPorts())) {
                    scan.setPorts(server.getFolderId()); //Default port değerleri bu alandan alınıyor.
                }
                if (BizzyUtil.isEmpty(scan.getParams())) {
                    scan.setParams(server.getDomain()); //Default nmap parametreleri bu alandan alınıyor.
                }
                scan.setStatus(ScanStatus.RUNNING);
                future = nmapScanService.startNmapScan(scan); //Tarama başlat

                logger.log(LogLevel.INFO, "Nmap üzerinden varlık keşfi için tarama oluşturuldu.");
                break;
            default:
                break;
        }
    }

    @RequestMapping(value = "listAssetDiscoveryResults.htm", method = RequestMethod.GET)
    public ModelAndView listAssetDiscoveryResults(HttpServletRequest request, HttpServletResponse response, final RedirectAttributes redirectAttributes) throws BizzyException, ParseException {
        ModelAndView mv = new ModelAndView();
        String scanId = ServletRequestUtils.getStringParameter(request, "scanId", null);
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        AssetDiscovery scan = pentestService.getAssetDiscoveryById(scanId, customerId);

        List<Server> scanEngines = new LinkedList();
        try {
            scanEngines = pentestService.getNetworkScanEngines(customerId);
        } catch (Exception ex) {
            logger.log(LogLevel.ERROR, "Scanner listesi okunamadı.", ex);
        }
        mv.addObject("scanEngines", scanEngines);
        mv.addObject("scanId", scanId);
        mv.addObject("scan", scan);
        mv.addObject(new PentestScan());
        return mv;
    }

    //Ajax tarafından çağrılıyor.
    @RequestMapping(value = "loadAssetDiscoveryResults.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String loadAssetDiscoveryResults(HttpServletRequest request, HttpServletResponse response) throws BizzyException {
        DataTablesRequest dataTablesRequest = DataTablesUtil.getRequest(request);
        String scanId = ServletRequestUtils.getStringParameter(request, "scanId", null);
      
        int[] filterPorts = ServletRequestUtils.getIntParameters(request, "ports[]");
        String filterAsset = ServletRequestUtils.getStringParameter(request, "asset", null);
        String filterOs = ServletRequestUtils.getStringParameter(request, "os", null);
        boolean filterNewAssets = ServletRequestUtils.getBooleanParameter(request, "newAssets", false);
        AssetFilter filter = new AssetFilter(filterAsset, "");
        filter.setPortNumber(filterPorts);
        filter.setOsName(filterOs);
        filter.setNewAsset(filterNewAssets);
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        AssetDiscovery assetDiscovery = pentestService.getAssetDiscoveryById(scanId, customerId);
        String lastScanId = assetDiscovery.getLastScanId();
             
        //Yetkisiz erişim kontrolü
        if (BizzyUtil.hasACustomerRole(user)) {
            if (assetDiscovery == null) {
                logger.log(LogLevel.ERROR, "Böyle bir tarama yok ! Tarama Id: " + scanId);
                throw new BizzyException("Böyle bir tarama yok ! Tarama Id: " + scanId);
            } else if (!assetDiscovery.getCustomer().getCustomerId().equals(customerId)) {
                logger.log(LogLevel.ERROR, "Yetkisiz tarama erişimi ! Tarama Id: " + scanId);
                throw new BizzyException("Yetkisiz tarama erişimi ! Tarama Id: " + scanId);
            }
        }

        try {
            int totalCount = pentestService.getAssetDiscoveryResultCount(scanId, lastScanId, filter);
            List<AssetDiscoveryResult> assetDiscoveryResults = pentestService.getAssetDiscoveryResultsFiltered(filter, dataTablesRequest, scanId, lastScanId,true);
            
            return DataTablesUtil.getResponse(dataTablesRequest.getDraw(), totalCount, totalCount, assetDiscoveryResults);
        } catch (Exception ex) {
            logger.log(LogLevel.ERROR, "Tarama sonuçları alınamadı.", ex);
            throw new BizzyException("Tarama sonuçları alınamadı.", ex);
        }
    }

    @RequestMapping(value = "getHostDiscoveryCsvReport.json", method = RequestMethod.POST)
    @ResponseBody
    public void getHostDiscoveryCsvReport(HttpServletRequest request, HttpServletResponse response) throws BizzyException, ScriptException {
        String[] assetDiscoveryResultIds = ServletRequestUtils.getStringParameters(request, "resultIds[]");
        String reportName = ServletRequestUtils.getStringParameter(request, "reportName", "");
        String scanId = ServletRequestUtils.getStringParameter(request, "scanId", null);
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        tr.biznet.bizzy.report.entity.Report report = new tr.biznet.bizzy.report.entity.Report();
        String[] name = reportName.split("\\.");
        if (name.length > 0) {
            report.setReportName(name[0]);
        } else {
            report.setReportName(reportName);
        }
        report.setReportExtension("csv");
        report.setReportType(ReportTypeEnum.ASSET_CSV_REPORT.getType());
        report.setCustomerId(customerId);
        report.setCreatedBy(user.getUsername());
        report.setCreateDate(new Date());

        List<AssetDiscoveryResult> results = new ArrayList<>();
        //Seçim yapılan sonuçları getir
        if (assetDiscoveryResultIds.length > 0) {
            for (String id : assetDiscoveryResultIds) {
                results.add(pentestService.getAssetDiscoveryResult(id));
            }
        } else { //Bütün asset discovery sonuçlarını getir
            results = pentestService.getAssetDiscoveryResults(null, scanId);
        }
        reportService.generateHostDiscoveryCsvReport(report, results);
    }

    @RequestMapping(value = "getConfiguration.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String getConfiguration(HttpServletRequest request, HttpServletResponse response) {
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        List<String> configurations = configurationService.getByKeyAndVisibilityAndCustomerId("minRiskLevel", "true", customerId);
        if (configurations.isEmpty()) {
            return "{\"hasConfiguration\" : \"false\"}";
        }
        return "{\"hasConfiguration\" : \"true\"," + "\"minRiskLevel\":" + configurations.get(0) + "}";
    }

    //Modal submit edildiğinde bu metod çağırılıyor.
    @RequestMapping(value = "getScanners.json", method = RequestMethod.GET, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public List<PentestScanner> getScanners(HttpServletRequest request, HttpServletResponse response) {
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        
        String serverId = ServletRequestUtils.getStringParameter(request, "serverId", null);
        List<PentestScanner> scanners = new LinkedList();
        try {
            if(!serverId.equals("-1")) {
                Server server = serverService.getServer(serverId, customerId);
                switch (ServerType.findWithType(server.getType())) {
                    case NESSUS:
                        scanners = nessusService.getScanners(server);
                        break;
                    case QUALYS:
                        QualysPlugin qualysPlugin = new QualysPlugin(server);
                        ApplianceListOutput alo = qualysPlugin.listScannerAppliances();
                        scanners = convertQualysScannersToPentestScanners(alo);
                        break;
                    case NEXPOSE:
                        scanners = nexposeService.getScanners(server);
                        break;
                    case OPENVAS:
                        scanners = openVASService.getScanners(server);
                        break;
                    case SECURITY_CENTER:
                        scanners = securityCenterService.getScanners(server);
                        break;
                    default:
                        break;
                }
            }
        } catch (Exception ex) {
            logger.log(LogLevel.ERROR, "Scanner bilgileri alınamadı. Server Id: " + serverId, ex);
        }

        List<PentestScanner> scannerListToSave = new LinkedList();

        for (PentestScanner scanner : scanners) {
            PentestScanner tmp = pentestService.getScannerById(scanner.getId(), serverId);
            if (tmp == null) {
                scanner.setServerId(serverId);
                scannerListToSave.add(scanner);
            }
        }

        pentestService.savePentestScanner(scannerListToSave);

        return scanners;
    }

    //Modal submit edildiğinde bu metod çağırılıyor.
    @RequestMapping(value = "getTimezones.json", method = RequestMethod.GET, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public List<PentestTimezone> getTimezones(HttpServletRequest request, HttpServletResponse response) {
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        
        String serverId = ServletRequestUtils.getStringParameter(request, "serverId", null);
        List<PentestTimezone> timezones = new LinkedList();

        try {
            Server server = serverService.getServer(serverId, customerId);

            switch (ServerType.findWithType(server.getType())) {
                case NESSUS:
                    timezones = nessusService.getTimezones(server);
                    break;
                default:
                    break;
            }

        } catch (Exception ex) {
            logger.log(LogLevel.ERROR, "Scanner bilgileri alınamadı. Server Id: " + serverId, ex);
        }

        return timezones;
    }

    //Modal submit edildiğinde bu metod çağırılıyor.
    @RequestMapping(value = "getPolicies.json", method = RequestMethod.GET, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public List<PentestPolicy> getPolicies(HttpServletRequest request, HttpServletResponse response) {
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        String serverId = ServletRequestUtils.getStringParameter(request, "serverId", null);
        List<PentestPolicy> policies = new LinkedList();

        try {
            Server server = serverService.getServer(serverId, customerId);

            switch (ServerType.findWithType(server.getType())) {
                case NESSUS:
                    policies = nessusService.getScanPolicies(server);
                    break;
                case SECURITY_CENTER:
                    policies = securityCenterService.getPolicies(server);
                    break;
                case NEXPOSE:
                    policies = nexposeService.getScannerTemplates(server);
                    break;
                case OPENVAS:
                    policies = openVASService.getScanConfigs(server);
                    break;
                case NETSPARKERENT:
                    policies = netsparkerService.getScanPolicies(server);
                    break;
                default:
                    break;
            }

        } catch (Exception ex) {
            logger.log(LogLevel.ERROR, "Policy bilgileri alınamadı. Server Id: " + serverId, ex);
        }

        List<PentestPolicy> policyListToSave = new LinkedList<>();

        for (PentestPolicy policy : policies) {
            PentestPolicy tmp = pentestService.getPolicyById(policy.getId(), serverId);
            if (tmp == null) {
                policy.setServerId(serverId);
                policyListToSave.add(policy);
            }
            else {
                String newPolicyName = policy.getName();
                if(!newPolicyName.equals(tmp.getName())) {
                    pentestService.updatePolicyNameById(tmp.getId(),newPolicyName);
                }
                
            }
            
        }

        pentestService.savePentestPolicies(policyListToSave);

        return policies;
    }
    
    @RequestMapping(value = "getSCRepositories.json", method = RequestMethod.GET, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public List<Repository> getSCRepositories(HttpServletRequest request, HttpServletResponse response) {
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        String serverId = ServletRequestUtils.getStringParameter(request, "serverId", null);
        try {
            Server server = serverService.getServer(serverId, customerId);
            return securityCenterService.getRepositories(server);
        } catch (Exception ex) {
            logger.log(LogLevel.ERROR, "SecurityCenter repository bilgileri alınamadı. Server Id: " + serverId, ex);
        }
        return null;
    }

    public List<PentestScanner> convertQualysScannersToPentestScanners(ApplianceListOutput alo) {
        List<PentestScanner> scanners = new LinkedList<>();
        for (Appliance appliance : alo.getApplianceListResponse().getApplianceList().getAppliances()) {
            PentestScanner pentestScanner = new PentestScanner();
            pentestScanner.setName(appliance.getName());
            pentestScanner.setId(appliance.getId());
            scanners.add(pentestScanner);
        }

        return scanners;
    }

    @RequestMapping(value = "getScanAssets.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String getScanAssets(HttpServletRequest request, HttpServletResponse response) {

        String scanId = ServletRequestUtils.getStringParameter(request, "scanId", "");
        String scanAsset = ServletRequestUtils.getStringParameter(request, "scanAsset", "");
        List<AssetAndGroup> scanAssets = pentestService.getScannedAssetsByScanId(scanId, scanAsset);
        return JsonUtil.getResponse(scanAssets);

    }
    
    @RequestMapping(value = "getScanAssetList.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String getScanAssetList(HttpServletRequest request, HttpServletResponse response) {

        String scanId = ServletRequestUtils.getStringParameter(request, "scanId", "");
        List<ScanAsset> scanAssets = pentestService.getScannedAssetsByScanId(scanId);
        return JsonUtil.getResponse(scanAssets);

    }

    /*
    Planlı tarama işlemlerinden 'Hemen Başlat' seçildiğinde çalışır.
    @param request
    @param response
    @return String
     */
    @RequestMapping(value = "startScheduledScanNow.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String startScheduledScanNow(HttpServletRequest request, HttpServletResponse response) {
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        String scanId = ServletRequestUtils.getStringParameter(request, "scanId", "");
        try {
            ScheduledPentestScan scheduledPentestScan = pentestService.getScheduledScanById(scanId);
            PentestScan pentestScan = (PentestScan) Class.forName("tr.biznet.bizzy.service.pentest.domain.PentestScan").cast(scheduledPentestScan);
            pentestScan.setServer(serverService.getServer(pentestScan.getServer().getSettingId(), customerId));
            pentestScan.setPolicy(scheduledPentestScan.getPolicy());
            if (null == pentestScan.getOccurrence()) {
                pentestScan.setOccurrence(OccurrenceType.ON_DEMAND);
            } else switch (pentestScan.getOccurrence()) {
                case DAILY:
                    pentestScan.setOccurrence(OccurrenceType.DAILY);
                    break;
                case WEEKLY:
                    pentestScan.setOccurrence(OccurrenceType.WEEKLY);
                    break;
                case MONTHLY:
                    pentestScan.setOccurrence(OccurrenceType.MONTHLY);
                    break;
                case YEARLY:
                    pentestScan.setOccurrence(OccurrenceType.YEARLY);
                    break;
                default:
                    pentestScan.setOccurrence(OccurrenceType.ON_DEMAND);
                    break;
            }
            // elle tetiklenmişse 1 olarak set ediyoruz, ona göre tamamlanan tarama sayısı değiştirilecek.
            pentestScan.setVulnerabilityCount(1);
            scanTaskExecutor.pushScan(pentestScan);
        } catch (Exception ex) {
            logger.log(LogLevel.ERROR, "Planlı Tarama başlatamada hata! " + ex.getMessage());
            return "{\"status\":\"failed\"}";
        }

        return "{\"status\":\"success\"}";

    }

    /*
    Planlı varlık keşfi işlemlerinden 'Hemen Başlat' seçildiğinde çalışır.
    @param request
    @param response
    @return String
     */
    @RequestMapping(value = "startScheduledHostScanNow.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String startScheduledHostScanNow(HttpServletRequest request, HttpServletResponse response) {

        String scanId = ServletRequestUtils.getStringParameter(request, "scanId", "");
        try {
            User user = HttpUtil.getUser();
            String customerId = BizzyUtil.getCustomerIdByUser(user);
            ScheduledAssetDiscovery scheduledAssetDiscovery = pentestService.getScheduledAssetDiscoveryById(scanId, customerId);
            AssetDiscovery assetDiscovery = (AssetDiscovery) Class.forName("tr.biznet.bizzy.service.pentest.domain.AssetDiscovery").cast(scheduledAssetDiscovery);
            assetDiscovery.setServer(serverService.getServer(assetDiscovery.getServer().getSettingId(), customerId));
            if (scheduledAssetDiscovery.getLaunch() == ScanLaunch.DAILY) {
                scheduledAssetDiscovery.setLaunch(ScanLaunch.DAILY);
            } else if (scheduledAssetDiscovery.getLaunch() == ScanLaunch.WEEKLY) {
                scheduledAssetDiscovery.setLaunch(ScanLaunch.WEEKLY);
            } else if (scheduledAssetDiscovery.getLaunch() == ScanLaunch.MONTHLY) {
                scheduledAssetDiscovery.setLaunch(ScanLaunch.MONTHLY);
            } else if (scheduledAssetDiscovery.getLaunch() == ScanLaunch.YEARLY) {
                scheduledAssetDiscovery.setLaunch(ScanLaunch.YEARLY);
            } else {
                scheduledAssetDiscovery.setLaunch(ScanLaunch.ON_DEMAND);
            }
            assetDiscovery.setActiveHostsCount(1);
            hostScanTaskExecutor.pushHostScan(assetDiscovery);
        } catch (Exception ex) {
            logger.log(LogLevel.ERROR, "Planlı Tarama başlatamada hata! " + ex.getMessage());
            return "{\"status\":\"failed\"}";
        }

        return "{\"status\":\"success\"}";

    }

    /**
     * Varlığa ait portların çekildiği fonksiyon
     *
     * @param request
     * @param response
     * @return String
     * @throws BizzyException
     */
    @RequestMapping(value = "getAssetPorts.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String getAssetPorts(HttpServletRequest request, HttpServletResponse response) throws BizzyException {

        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        String[] assetIp = ServletRequestUtils.getStringParameters(request, "assetId[]");
        String port = ServletRequestUtils.getStringParameter(request, "port", null);
        Integer portValue;
        if (port == null) {
            portValue = null;
        } else {
            portValue = Integer.parseInt(port);
        }
        if (assetIp.length <= 0) {
            return "{}";
        }
        if (assetIp.length > 1) {
            throw new BizzyException("Birden fazla varlık için port getirilmiyor!");
        } else {
            Asset asset = customerService.getAssetByIp(assetIp[0], customerId);
            if (asset == null) {
                List<Port> ports = new LinkedList<>();
                return JsonUtil.getResponse(ports);
            } else {
                List<Port> ports = customerService.getPortsByAssetIdAutoComplete(asset.getAssetId(), portValue);
                return JsonUtil.getResponse(ports);
            }
        }
    }

    /**
     * Varlığa ait virtual hostların çekildiği fonksiyon
     *
     * @param request
     * @param response
     * @return String
     * @throws BizzyException
     */
    @RequestMapping(value = "getAssetVirtualHosts.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String getAssetVirtualHosts(HttpServletRequest request, HttpServletResponse response) throws BizzyException {

        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        String[] assetIp = ServletRequestUtils.getStringParameters(request, "assetId[]");
        String host = ServletRequestUtils.getStringParameter(request, "host", null);
        String virtualHostName;
        if (host == null) {
            virtualHostName = null;
        } else {
            virtualHostName = host;
        }
        if (assetIp.length <= 0) {
            return "{}";
        }
        if (assetIp.length > 1) {
            throw new BizzyException("Birden fazla varlık için virtual host getirilmiyor!");
        } else {
            Asset asset = customerService.getAssetByIp(assetIp[0], customerId);
            if (asset == null) {
                List<VirtualHost> virtualHosts = new LinkedList<>();
                return JsonUtil.getResponse(virtualHosts);
            } else {
                List<VirtualHost> virtualHosts = customerService.getVirtualHostsByAssetIdAutoComplete(asset.getAssetId(), virtualHostName);
                return JsonUtil.getResponse(virtualHosts);
            }
        }
    }

    @RequestMapping(value = "getCustomerAssets.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String getCustomerAssets(HttpServletRequest request, HttpServletResponse response) {
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);

        String scanAsset = ServletRequestUtils.getStringParameter(request, "scanAsset", "");
        List<AssetAndGroup> list = new ArrayList<>();
        list = pentestService.getAssetIpListForStartScanByCustomerId(customerId, scanAsset);

        return JsonUtil.getResponse(list);
    }

    /**
     * Tarama sonuçları sayfası
     *
     * @param request
     * @param response
     * @param redirectAttributes
     * @return mv
     * @throws BizzyException
     * @throws ParseException
     */
    @RequestMapping(value = "viewScanResults.htm", method = RequestMethod.GET)
    public ModelAndView viewScanResults(HttpServletRequest request, HttpServletResponse response, final RedirectAttributes redirectAttributes) throws BizzyException, ParseException {
        Locale locale = RequestContextUtils.getLocale(request);
        ModelAndView mv = new ModelAndView();
        User user = HttpUtil.getUser();
        try {
            String scanId = ServletRequestUtils.getStringParameter(request, "scanId", null);
            PentestScan scan = pentestService.getScanDetailsWithoutAssets(scanId);

            String customerId = BizzyUtil.getCustomerIdByUser(user);

            //Yetkisiz erişimi önlemek için kontroller
            if (scan == null) {
                logger.log(LogLevel.ERROR, "Böyle bir tarama yok ! Tarama Id: " + scanId);
                return HttpUtil.sendRedirect("listScans.htm");
            }
            if (!scan.getCustomer().getCustomerId().equals(customerId)) {
                logger.log(LogLevel.ERROR, "Yetkisiz tarama erişimi ! Tarama Id: " + scanId);
                return HttpUtil.sendRedirect("listScans.htm");
            }

            boolean isCustomerUser = BizzyUtil.hasACustomerRole(HttpUtil.getUser());
            String assetId = ServletRequestUtils.getStringParameter(request, "assetId", null);
//            List<Assignee> assigneeList = null;

            List<Label> labelList = new LinkedList<>();
            if (isCustomerUser) {
//                assigneeList = getAssigneeListForVulnerability(assetId);
                customerId = BizzyUtil.getCustomerIdByUser(user);

                if (!BizzyUtil.isEmpty(assetId)) {
                    Asset asset = assetService.getAssetByIdandCustomerId(assetId, customerId);
                    if (asset == null) {
                        logger.log(LogLevel.ERROR, "Yetkisiz varlık erişimi ! Varlık Id: " + assetId);
//                        assigneeList = null;
                    }
                }
                labelList = customerService.getLabelsForCustomer(customerId);
            } else {
                labelList = customerService.getAllLabels();
            }

            List<String> otherIps = customerService.getDistinctOtherIpsByCustomerId(customerId);
            Set<String> commaSeperatedOtherIps = new HashSet<String>();
            for (String otherIp : otherIps) {
                if (otherIp.contains(",")) {
                    String[] seperated = otherIp.split(", ");
                    for (String item : seperated) {
                        commaSeperatedOtherIps.add(item);
                    }
                } else {
                    commaSeperatedOtherIps.add(otherIp);
                }
            }

            List<Message> sourceList = messageService.getMessages(VULNERABILITY_SOURCE);
         
            mv.addObject("sourceList", sourceList);

            List<TicketStatus> statuses = getStatusList(locale);
            List<TicketStatus> customStatuses = getCustomStatusesFromConfiguration(statuses, customerId);

//            mv.addObject("assigneeList", assigneeList);
            mv.addObject("customerId", customerId);
            mv.addObject("labelList", labelList);
            mv.addObject("isCustomerUser", isCustomerUser);
            mv.addObject("scanId", scanId);
            mv.addObject("scanType", scan.getSource().toString());
            mv.addObject("scan", scan);
            mv.addObject("multiStatusForm", new TicketStatusChangeView());
            mv.addObject("multiAssigneeForm", new TicketAssigneeChangeView());
            mv.addObject("statuses", customStatuses);
            mv.addObject("otherIps", commaSeperatedOtherIps);
          

        } catch (Exception ex) {
            logger.log(LogLevel.ERROR, "Tarama sonuçları alınamadı: " + ex.getMessage(), ex);

            redirectAttributes.addFlashAttribute("error", MessageUtil.getLocaleMessage(locale, "agent.connection.error"));
            return HttpUtil.sendRedirect("listScans.htm");
        }
        return mv;
    }

    @RequestMapping(value = "viewScanAssets.htm", method = RequestMethod.GET)
    public ModelAndView viewScanAssets(HttpServletRequest request, HttpServletResponse response, final RedirectAttributes redirectAttributes) throws BizzyException, ParseException {
        Locale locale = RequestContextUtils.getLocale(request);
        ModelAndView mv = new ModelAndView();
        User user = HttpUtil.getUser();
        try {
            String scanId = ServletRequestUtils.getStringParameter(request, "scanId", null);
            PentestScan scan = pentestService.getScanDetailsWithoutAssets(scanId);

            String customerId = BizzyUtil.getCustomerIdByUser(user);

            //Yetkisiz erişimi önlemek için kontroller
            if (scan == null) {
                logger.log(LogLevel.ERROR, "Böyle bir tarama yok ! Tarama Id: " + scanId);
                return HttpUtil.sendRedirect("listScans.htm");
            }
            if (!scan.getCustomer().getCustomerId().equals(customerId)) {
                logger.log(LogLevel.ERROR, "Yetkisiz tarama erişimi ! Tarama Id: " + scanId);
                return HttpUtil.sendRedirect("listScans.htm");
            }

            boolean isCustomerUser = BizzyUtil.hasACustomerRole(HttpUtil.getUser());
            String assetId = ServletRequestUtils.getStringParameter(request, "assetId", null);
//            List<Assignee> assigneeList = null;

            if (isCustomerUser) {
//                assigneeList = getAssigneeListForVulnerability(assetId);
                customerId = BizzyUtil.getCustomerIdByUser(user);

                if (!BizzyUtil.isEmpty(assetId)) {
                    Asset asset = assetService.getAssetByIdandCustomerId(assetId, customerId);
                    if (asset == null) {
                        logger.log(LogLevel.ERROR, "Yetkisiz varlık erişimi ! Varlık Id: " + assetId);
//                        assigneeList = null;
                    }
                }
            }

            mv.addObject("customerId", customerId);
            mv.addObject("isCustomerUser", isCustomerUser);
            mv.addObject("scanId", scanId);
            mv.addObject("scan", scan);

        } catch (Exception ex) {
            logger.log(LogLevel.ERROR, "Tarama sonuçları alınamadı: " + ex.getMessage(), ex);

            redirectAttributes.addFlashAttribute("error", MessageUtil.getLocaleMessage(locale, "agent.connection.error"));
            return HttpUtil.sendRedirect("listScans.htm");
        }
        return mv;
    }

    @RequestMapping(value = "viewAssetVulnerabilities.htm", method = RequestMethod.GET)
    public ModelAndView viewAssetVulnerabilities(HttpServletRequest request, HttpServletResponse response, final RedirectAttributes redirectAttributes) throws BizzyException, ParseException {
        Locale locale = RequestContextUtils.getLocale(request);
        ModelAndView mv = new ModelAndView();
        User user = HttpUtil.getUser();
        try {
            String scanAssetId = ServletRequestUtils.getStringParameter(request, "scanAssetId", null);
            ScanAsset scanAsset = customerService.getScanAssetById(scanAssetId);

            PentestScan scan = pentestService.getScanDetailsWithoutAssets(scanAsset.getScanId()); //Taramanın kısıtlı içeriğini alır.

            String customerId = BizzyUtil.getCustomerIdByUser(user);

            //Yetkisiz erişimi önlemek için kontroller
            if (scan == null) {
                logger.log(LogLevel.ERROR, "Böyle bir tarama yok ! Tarama Id: " + scanAsset.getScanId());
                return HttpUtil.sendRedirect("listScans.htm");
            }
            if (!scan.getCustomer().getCustomerId().equals(customerId)) {
                logger.log(LogLevel.ERROR, "Yetkisiz tarama erişimi ! Tarama Id: " + scanAsset.getScanId());
                return HttpUtil.sendRedirect("listScans.htm");
            }

            boolean isCustomerUser = BizzyUtil.hasACustomerRole(HttpUtil.getUser());
//            List<Assignee> assigneeList = null;
            Asset asset = assetService.getAssetByIdandCustomerId(scanAsset.getAssetId(), customerId);
            List<Label> labelList = new LinkedList<>();
            if (isCustomerUser) {
                if (!BizzyUtil.isEmpty(scanAsset.getAssetId())) {

                    if (asset == null) {
                        logger.log(LogLevel.ERROR, "Yetkisiz varlık erişimi ! Varlık Id: " + scanAsset.getAssetId());
                    }
                }
                labelList = customerService.getLabelsForCustomer(customerId);
            } else {
                labelList = customerService.getAllLabels();
            }

            List<Message> sourceList = messageService.getMessages(VULNERABILITY_SOURCE);

            mv.addObject("sourceList", sourceList);

            List<TicketStatus> statuses = getStatusList(locale);
            List<TicketStatus> customStatuses = getCustomStatusesFromConfiguration(statuses, customerId);

            mv.addObject("customerId", customerId);
            mv.addObject("labelList", labelList);
            mv.addObject("isCustomerUser", isCustomerUser);
            mv.addObject("scanId", scanAsset.getScanId());
            mv.addObject("assetId", scanAsset.getAssetId());
            mv.addObject("scan", scan);
            mv.addObject("asset", asset);
            mv.addObject("multiStatusForm", new TicketStatusChangeView());
            mv.addObject("multiAssigneeForm", new TicketAssigneeChangeView());
            mv.addObject("statuses", customStatuses);

        } catch (Exception ex) {
            logger.log(LogLevel.ERROR, "Tarama sonuçları alınamadı: " + ex.getMessage(), ex);

            redirectAttributes.addFlashAttribute("error", MessageUtil.getLocaleMessage(locale, "agent.connection.error"));
            return HttpUtil.sendRedirect("listScans.htm");
        }
        return mv;
    }

    /**
     * Zafiyet - Bilgi Bankası Eşleştirme sayfası
     * @return mv
     */
    @RequestMapping(value = "vulnerabilityKbItemMatch.htm", method = RequestMethod.GET)
    public @ResponseBody ModelAndView vulnerabilityKbItemMatch() {
        
        ModelAndView mv = new ModelAndView();
        VulnerabilityFilter filter = new VulnerabilityFilter();
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        filter.setCustomerId(customerId);
        List<ScanVulnerability> vulnerabilities = customerService.getVulnerabilities(null, filter);
        List<VulnerabilityKbItem> matchedIds = customerService.getMatchedVulnerabilityIds(null);
        Map<String, String> hm = new HashMap<String, String>();
        List<String> ids = new LinkedList<>();
        for (ScanVulnerability vuln : vulnerabilities) {
            String source = vuln.getVulnerability().getSource();
            String id = vuln.getVulnerability().getVulnNumber();
            String name = vuln.getVulnerability().getName();
            if (!ids.contains(id) && id != null) {
                if (!matchedIds.stream().anyMatch(item -> id.equals(item.getVulnNumber()) && source.equals(item.getScannerType()))) {
                    ids.add(id);
                    name = name.replace("\"", "\\\"");
                    hm.put(id, name);
                }
            }
        }
        VulnerabilityFilter kbFilter = new VulnerabilityFilter();
        String[] labelFilter = {};
        String[] problemAreaFilter = {};
        String[] rootCauseFilter = {};
        String[] category = {};
        kbFilter.setLabels(labelFilter);
        kbFilter.setProblemAreas(problemAreaFilter);
        kbFilter.setRootCauses(rootCauseFilter);
        kbFilter.setCategories(category);
        List<KBItem> kbList = kBService.getKBItems(null, kbFilter);
        for (KBItem item : kbList) {
            List<VulnerabilityKbItem> list = customerService.getMatchedVulnerabilityIds(item.getId());
            for (VulnerabilityKbItem temp : list) {
                String name = customerService.getVulnerability(null, temp.getVulnNumber(), temp.getScannerType()).getName();
                temp.setId(name);
            }
            item.setMatchedIds(list);
        }
        mv.addObject("kbCategoriesList", kbList);
        mv.addObject("nessusCategoriesList", hm);
        return mv;
        
    }
    
    /**
     * Zafiyet Kategorisi - Bilgi Bankası Kategorisi Eşleştirme sayfası
     * @return mv
     */
    @RequestMapping(value = "vulnerabilityKbCategoryMatch.htm", method = RequestMethod.GET)
    public @ResponseBody ModelAndView vulnerabilityKbCategoryMatch(HttpServletRequest request) {
        
        ModelAndView mv = new ModelAndView();
        VulnerabilityFilter filter = new VulnerabilityFilter();
        User user = HttpUtil.getUser();
        Locale locale = RequestContextUtils.getLocale(request);
        String language = locale.getLanguage();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        filter.setCustomerId(customerId);
        Map<String, String> pluginCategoriesAndSources = customerService.getPluginCategoriesAndSources();
        List<VulnerabilityKbItem> matchedIds = customerService.getCategoryMatchedVulnerabilityIds(null);
        Map<String, String> hm = new HashMap<String, String>();
        List<String> categories = new LinkedList<>();
        for (Map.Entry<String, String> entry : pluginCategoriesAndSources.entrySet()) {
            String source = entry.getValue();
            String category = entry.getKey();
            if (!categories.contains(category) && category != null) {
                if (!matchedIds.stream().anyMatch(item -> category.equals(item.getVulnNumber()) && source.equals(item.getScannerType()))) {
                    categories.add(category);
                    hm.put(category, source);
                }
            }
        }
        List<tr.biznet.bizzy.service.kb.domain.Category> kbList = kBService.getCategories(null);
        
        for (tr.biznet.bizzy.service.kb.domain.Category item : kbList) {
            List<VulnerabilityKbItem> list = customerService.getCategoryMatchedVulnerabilityIds(item.getId());
            for (VulnerabilityKbItem temp : list) {
                String name = customerService.getVulnerability(null, temp.getVulnNumber(), temp.getScannerType()).getName();
                temp.setId(name);
            }
            item.setMatchedIds(list);
        } 
        mv.addObject("kbCategoriesList", kbList);
        mv.addObject("nessusCategoriesList", hm);
        mv.addObject("selectedLanguage", language);
        return mv;
        
    }

    /**
     * Tarama başlatma ekranında taranacak ip ya da varlık grupları alınır.
     * @param request
     * @param response
     * @return String
     */
    @RequestMapping(value = "getAssetAndGroupList.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String getAssetAndGroupList(HttpServletRequest request, HttpServletResponse response) {
        
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        String scanAsset = ServletRequestUtils.getStringParameter(request, "scanAsset", "");
        List<AssetAndGroup> list = pentestService.getAssetGroupListForStartScanByCustomerId(customerId, scanAsset);
        List<AssetAndGroup> ipList = pentestService.getAssetIpListForStartScanByCustomerId(customerId, scanAsset);
        list.addAll(ipList);
        return JsonUtil.getResponse(list);
        
    }

    @RequestMapping(value = "getAppAssets.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String getAppAssetList(HttpServletRequest request, HttpServletResponse response) {
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);

        String scanAsset = ServletRequestUtils.getStringParameter(request, "scanAsset", "");
        List<AssetAndGroup> list = pentestService.getAppAssetListForStartScanByCustomerId(customerId, scanAsset);
        return JsonUtil.getResponse(list);
    }

    /**
     * Önyüzden IP listesi alınır.
     * @param request
     * @param response
     * @return String
     */
    @RequestMapping(value = "getAssetList.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String getAssetList(HttpServletRequest request, HttpServletResponse response) {
        
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        String scanAsset = ServletRequestUtils.getStringParameter(request, "scanAsset", "");
        List<AssetAndGroup> list = new ArrayList<>();
        list = pentestService.getAssetIpListForStartScanByCustomerId(customerId, scanAsset);
        return JsonUtil.getResponse(list);
        
    }
    
    @RequestMapping(value = "getLabelList.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String getLabelList(HttpServletRequest request, HttpServletResponse response) {
        
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        List<Label> labelList = new LinkedList<>();
        labelList = customerService.getLabelsForCustomer(customerId);
        return JsonUtil.getResponse(labelList);
        
    }
    
    

    /**
     * Zafiyet Taraması başlatma sayfası
     * @param request
     * @param response
     * @param pentestScan
     * @param result
     * @param redirectAttributes
     * @return mv
     * @throws BizzySecurityException
     * @throws BizzyException
     * @throws ScriptException 
     */
    @RequestMapping(value = "startScan.htm", method = {RequestMethod.GET})
    public @ResponseBody
    ModelAndView startScanPage(HttpServletRequest request, HttpServletResponse response, PentestScan pentestScan, BindingResult result, final RedirectAttributes redirectAttributes) throws BizzySecurityException, BizzyException, ScriptException {
        
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        ModelAndView mv = new ModelAndView();
        List<AssetAndGroup> assetAndGroupList = new ArrayList<>();
        List<Label> labelList = new LinkedList<>();
        labelList = customerService.getLabelsForCustomer(customerId);
        assetAndGroupList = pentestService.getAssetGroupListForStartScanByCustomerId(customerId, null);
        assetAndGroupList.addAll(pentestService.getAssetIpListForStartScanByCustomerId(customerId, null));
        mv.addObject("assetAndGroupList", assetAndGroupList);
        List<Asset> reCheckAssets = assetService.getRecheckedAssets();
        List<Server> scanEngines = pentestService.getVulnerabilityScanEngines(customerId);
        List<Server> vcsServers = pentestService.getVersionControlServers(customerId);
        List<LanguageType> languages = Arrays.asList(LanguageType.values());
        List<BuildTool> buildTools = Arrays.asList(BuildTool.values());
        OccurrenceType[] scanOccurrenceForScheduled = OccurrenceType.values();
        mv.addObject("scanEngines", scanEngines);
        mv.addObject("vcsServers", vcsServers);
        mv.addObject("languages", languages);
        mv.addObject("buildTools", buildTools);
        mv.addObject("scanOccurrenceForScheduled", scanOccurrenceForScheduled);
        List<PentestScan> scanList = pentestService.getScans(null, customerId, null, "all", false, null);
        List<ScheduledPentestScan> scheduledScanList = pentestService.getScheduledScans(null, customerId, "all", false);
        mv.addObject("scanList", scanList);
        mv.addObject("scheduledScanList", scheduledScanList);
        mv.addObject("labelList", labelList);
        mv.addObject("recheckedAssets", reCheckAssets);
        mv.addObject("addAssetGroupForm", new AssetGroup());
        List<Message> assetSeverities = messageService.getMessages(ASSET_SEVERITY);
        mv.addObject("assetSeverities", assetSeverities);
        List<AssetGroup> parentGroups = customerService.getAssetGroups(null, customerId);
        mv.addObject("parentGroups", parentGroups);
        return mv;
        
    }

    /**
     * Zafiyet Taraması başlatma isteği
     *
     * @param request
     * @param response
     * @param pentestScan
     * @param result
     * @param redirectAttributes
     * @return mv
     * @throws BizzySecurityException
     * @throws BizzyException
     * @throws ScriptException
     */
    @RequestMapping(value = "startScan.htm", headers=("content-type=multipart/*"), method = {RequestMethod.POST})
    public @ResponseBody
    ModelAndView startScanPage(HttpServletRequest request, HttpServletResponse response, PentestScan pentestScan,Label label, BindingResult result, final RedirectAttributes redirectAttributes, @RequestParam("file") MultipartFile file) throws BizzySecurityException, BizzyException, ScriptException {

        ModelAndView mv = new ModelAndView();
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        String[] assetsFromFile = null;

        Iterator<String> itrator = ((MultipartHttpServletRequest) request).getFileNames();
        if (itrator.hasNext()) {
            try {
                ByteArrayInputStream stream = new ByteArrayInputStream(file.getBytes());
                String assetsWithComma = IOUtils.toString(stream, "UTF-8");
                assetsFromFile = assetsWithComma.split(",");

            } catch (IOException ex) {
                Logger.getLogger(PentestController.class.getName()).log(Level.SEVERE, null, ex);
            }

        }
        
        try {
            Date now = new Date();
            pentestScan = pentestService.configureAssets(pentestScan, customerId);
            
            if (pentestService.isScanLimitExceeded(customerId)) { //Tarama limit kontrolü
                logger.log(LogLevel.WARN, "Tarama limiti yetersiz.");
                redirectAttributes.addFlashAttribute("errorMessage", "scan.limit.error");
                return HttpUtil.sendRedirect("listScans.htm");
            }

            PentestScan saved = pentestService.getScanByName(pentestScan.getName());
            if (saved != null) { //Tarama adı kontrolü
                logger.log(LogLevel.ERROR, "Tarama adı kontrolü önyüzde devre dışı bırakıldı!!");
                redirectAttributes.addFlashAttribute("errorMessage", "startAssetDiscovery.sameName");
                return HttpUtil.sendRedirect("listScans.htm");
            }

            if (pentestService.isActiveScanLimitExceeded(customerId)) { //Aktif Tarama limit kontrolü
                logger.log(LogLevel.WARN, "Aktif Tarama limiti yetersiz.");
                redirectAttributes.addFlashAttribute("errorMessage", "activeScan.limit.error");
                return HttpUtil.sendRedirect("listScans.htm");
            }
            if (!pentestScan.isPentestScan()) {
                pentestScan.setServer(serverService.getServer(pentestScan.getServer().getSettingId(), customerId));
            }

            //Default minimum risk level kullanılacaksa konfigurasyondan alınır.
            if (pentestScan.getUseDefaultMinRiskLevel()) {
                List<String> configurations = configurationService.getByKeyAndVisibilityAndCustomerId("minRiskLevel", "true", customerId);
                if (configurations.isEmpty()) {
                    pentestScan.setMinRiskLevel(0);
                } else {
                    pentestScan.setMinRiskLevel(Integer.parseInt(configurations.get(0)));
                }
            }

            if (pentestScan.getOccurrence() == OccurrenceType.ON_DEMAND) {    //ON_DEMAND seçiliyse bi kere çalışacak
                pentestScan.setRecurrence(1);
            }
            if (pentestScan.getRecurrence() == null || pentestScan.getRecurrence() == 0 || pentestScan.getRecurrence() > 100) { // RECCURENCE 1-100 ARASI DEĞİLSE
                pentestScan.setRecurrence(-1);                        // RECCURENCE VERITABANI KAYDI İÇİN -1 OLARAK SET EDİLİR (SÜREKLİ TARAMA)
            }
            //Aynı zamananda başlayacak olan planlı taramaların limitinin kontrolü
            if (pentestScan.isScheduled()) {
                int count = 0;
                //planlı taramamızın bütün çalışma tarihlerinin hesaplanması
                Date dateConversionSupporter2 = pentestScan.getScanDate();
                LocalDateTime scanDate = dateConversionSupporter2.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
                List<LocalDateTime> scanDates = new ArrayList<>();
                int reccurence = pentestScan.getRecurrence();
                scanDates.add(scanDate);
                for (int i = 0; i < reccurence - 1; i++) {
                    switch (pentestScan.getOccurrence()) {
                        case DAILY:
                            scanDate = scanDate.plusDays(1);
                            break;
                        case WEEKLY:
                            scanDate = scanDate.plusWeeks(1);
                            break;
                        case MONTHLY:
                            if(pentestScan.isScanWeekend() == true) {
                                scanDate = scanDate.plusDays(28);
                                break;
                            } else {
                                scanDate = scanDate.plusMonths(1);
                                break;
                            }
                        case QUARTERLY:
                            scanDate = scanDate.plusMonths(3);
                            break;
                        case YEARLY:
                            scanDate = scanDate.plusYears(1);
                            break;
                        default:
                            break;
                    }
                    scanDates.add(scanDate);
                }
                //bütün planlı tarama tarihleri hesaplanması
                List<ScheduledAssetDiscovery> scheduledAssetScans = pentestService.getScheduledHostScans(null, customerId);
                for (ScheduledAssetDiscovery sps : scheduledAssetScans) {
                    List<LocalDateTime> allDates = new ArrayList<>();
                    boolean isBreaked = false;
                    Date dateConversionSupporter = sps.getScanDate();
                    LocalDateTime date = dateConversionSupporter.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
                    reccurence = sps.getRecurrence();

                    if ((sps.getRecurrence() - sps.getCompletedScanCount() != 0 && !(sps.getLaunch().equals(OccurrenceType.ON_DEMAND.toString()) && sps.getCompletedScanCount() == 1))) {
                        allDates.add(date);
                        for (int i = 0; i < reccurence - 1; i++) {
                            switch (sps.getLaunch()) {
                                case DAILY:
                                    date = date.plusDays(1);
                                    break;
                                case WEEKLY:
                                    date = date.plusWeeks(1);
                                    break;
                                case MONTHLY:
                                    if(pentestScan.isScanWeekend() == true) {
                                        date = date.plusDays(28);
                                        break;
                                    } else {
                                        date = date.plusMonths(1);
                                        break;
                                    }
                                case QUARTERLY:
                                    scanDate = scanDate.plusMonths(3);
                                    break;
                                case YEARLY:
                                    date = date.plusYears(1);
                                    break;
                                default:
                                    break;
                            }
                            allDates.add(date);
                        }
                    } else if (reccurence == -1) {
                        allDates.add(date);
                        switch (sps.getLaunch()) {
                            case DAILY:
                                //get hour&minute
                                Calendar calendar = GregorianCalendar.getInstance(); // creates a new calendar instance
                                calendar.setTime(sps.getScanDate());   // assigns calendar to given date 
                                int hourOne = calendar.get(Calendar.HOUR_OF_DAY); // gets hour in 24h format
                                int minuteOne = calendar.get(Calendar.MINUTE);
                                calendar.setTime(pentestScan.getScanDate());   // assigns calendar to given date 
                                int hourTwo = calendar.get(Calendar.HOUR_OF_DAY); // gets hour in 24h format
                                int minuteTwo = calendar.get(Calendar.MINUTE);

                                if (scanDate.isAfter(date) && (hourOne == hourTwo && minuteOne == minuteTwo)) {
                                    count++;
                                    isBreaked = true;
                                    break;
                                }
                            case WEEKLY:
                                for (int i = 0; i < 51; i++) {
                                    date = date.plusWeeks(1);
                                    allDates.add(date);
                                }
                                break;
                            case MONTHLY:
                                if(pentestScan.isScanWeekend() == true) {
                                    for (int i = 0; i < 51; i++) {
                                    date = date.plusWeeks(4);
                                    allDates.add(date);
                                }
                                    break;
                                } else {
                                    for (int i = 0; i < 11; i++) {
                                        date = date.plusMonths(1);
                                        allDates.add(date);
                                    }
                                    break;
                                } 
                            case QUARTERLY:
                                for (int i = 0; i < 11; i++) {
                                    date = date.plusMonths(3);
                                    allDates.add(date);
                                }
                                break;
                            case YEARLY:
                                date = date.plusYears(1);
                                allDates.add(date);
                                break;
                            default:
                                break;
                        }
                    }
                    //Taramanın planlı saatleriyle, mevcut planlı taramaların saatlerinin karşılaştırılması
                    if (!allDates.isEmpty()) {
                        for (LocalDateTime scanDateElement : scanDates) {
                            if (isBreaked) {
                                break;
                            }
                            for (LocalDateTime allDateElement : allDates) {
                                if (scanDateElement.isEqual(allDateElement)) {
                                    count++;
                                    isBreaked = true;
                                    break;
                                }
                            }
                        }
                    }
                }
                List<ScheduledPentestScan> scheduledScans = pentestService.getScheduledScans(null, customerId, "all", false);
                for (ScheduledPentestScan sps : scheduledScans) {
                    List<LocalDateTime> allDates = new ArrayList<>();
                    boolean isBreaked = false;
                    Date dateConversionSupporter = sps.getScanDate();
                    LocalDateTime date = dateConversionSupporter.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
                    reccurence = sps.getRecurrence();

                    if ((sps.getRecurrence() - sps.getCompletedScanCount() != 0 && !(sps.getOccurrence().equals(OccurrenceType.ON_DEMAND) && sps.getCompletedScanCount() == 1))) {
                        allDates.add(date);
                        for (int i = 0; i < reccurence - 1; i++) {
                            switch (sps.getOccurrence()) {
                                case DAILY:
                                    date = date.plusDays(1);
                                    break;
                                case WEEKLY:
                                    date = date.plusWeeks(1);
                                    break;
                                case MONTHLY:
                                    if(pentestScan.isScanWeekend() == true) {
                                        date = date.plusDays(28);
                                        break;
                                    } else {
                                        date = date.plusMonths(1);
                                        break;
                                    }
                                case QUARTERLY:
                                    date = date.plusMonths(3);
                                    break;
                                case YEARLY:
                                    date = date.plusYears(1);
                                    break;
                                default:
                                    break;
                            }
                            allDates.add(date);
                        }
                    } else if (reccurence == -1) {
                        allDates.add(date);
                        switch (sps.getOccurrence()) {
                            case DAILY:
                                //get hour&minute
                                Calendar calendar = GregorianCalendar.getInstance(); // creates a new calendar instance
                                calendar.setTime(sps.getScanDate());   // assigns calendar to given date 
                                int hourOne = calendar.get(Calendar.HOUR_OF_DAY); // gets hour in 24h format
                                int minuteOne = calendar.get(Calendar.MINUTE);
                                calendar.setTime(pentestScan.getScanDate());   // assigns calendar to given date 
                                int hourTwo = calendar.get(Calendar.HOUR_OF_DAY); // gets hour in 24h format
                                int minuteTwo = calendar.get(Calendar.MINUTE);

                                if (scanDate.isAfter(date) && (hourOne == hourTwo && minuteOne == minuteTwo)) {
                                    count++;
                                    isBreaked = true;
                                    break;
                                }
                            case WEEKLY:
                                for (int i = 0; i < 51; i++) {
                                    date = date.plusWeeks(1);
                                    allDates.add(date);
                                }
                                break;
                            case MONTHLY:
                                if(pentestScan.isScanWeekend() == true) {
                                    for (int i = 0; i < 51; i++) {
                                    date = date.plusWeeks(4);
                                    allDates.add(date);
                                }
                                    break;
                                } else {
                                    for (int i = 0; i < 11; i++) {
                                        date = date.plusMonths(1);
                                        allDates.add(date);
                                    }
                                    break;
                                } 
                            case QUARTERLY:
                                for (int i = 0; i < 11; i++) {
                                    date = date.plusMonths(3);
                                    allDates.add(date);
                                }
                                break;
                            case YEARLY:
                                date = date.plusYears(1);
                                allDates.add(date);
                                break;
                            default:
                                break;
                        }
                    }
                    //Taramanın planlı saatleriyle, mevcut planlı taramaların saatlerinin karşılaştırılması
                    if (!allDates.isEmpty()) {
                        for (LocalDateTime scanDateElement : scanDates) {
                            if (isBreaked) {
                                break;
                            }
                            for (LocalDateTime allDateElement : allDates) {
                                if (scanDateElement.isEqual(allDateElement)) {
                                    count++;
                                    isBreaked = true;
                                    break;
                                }
                            }
                        }
                    }
                }
                String scanLimitCount = limitService.getLimitValueByTypeValueAndCustomerId(LimitTypeEnum.SCHEDULED_SCAN.getType(), LimitValueTypeEnum.COUNT.getType(), customerId);
                if (scanLimitCount != null) {
                    if (Integer.parseInt(scanLimitCount) <= count) {
                        logger.log(LogLevel.WARN, "Aynı zamanlı başlangıçlı planlanan tarama limiti yetersiz.");
                        redirectAttributes.addFlashAttribute("errorMessage", "scheduledscan.limit.error");
                        return HttpUtil.sendRedirect("listScans.htm");
                    }
                }
            }
            if(!pentestScan.isSyncScan()) {
                TargetValidator targetValidator = new TargetValidator();
                List<Asset> appAssets = assetService.getAssetsByType("APPLICATION", customerId);
                List<AssetGroup> groupAssets = customerService.getAssetGroups(null, customerId);
                
                if (!pentestScan.isPentestScan()) {   //Manuel tarama ise validate metodundan geçmiyor, tüm formatları kabul ediyoruz.
                    for (ScanAsset target : pentestScan.getScanAssets()) {
                        String errorStr = targetValidator.validate(pentestScan.getServer().getType(), target.getScannedIp(), appAssets, groupAssets);
                        if (errorStr.length() > 0) {
                            redirectAttributes.addFlashAttribute("errorMessage", "targetValidator.error");
                            return HttpUtil.sendRedirect("listScans.htm");
                        }
                    }
                }
                //Dosyadan ip verildiyse onların kontrolü
                for (String target : assetsFromFile) {
                    if (!target.equals("")) {
                        String errorStr = targetValidator.validate(pentestScan.getServer().getType(), target, appAssets, groupAssets);
                        if (errorStr.length() > 0) {
                            redirectAttributes.addFlashAttribute("errorMessage", "targetValidator.error");
                            return HttpUtil.sendRedirect("listScans.htm");
                        }
                    }
                }
            }
            
            pentestScan.setRequestedBy(user.getUsername());
            Customer customer = new Customer();
            customer.setCustomerId(customerId);
            pentestScan.setCustomer(customer);
            pentestScan.setRequestDate(now);
            
            if(!pentestScan.isSyncScan()) {
                if (pentestScan.getProjectDetails().getVcsId().equals("-1")) {
                    String includeIps = pentestService.parseScopeIps(pentestScan); //IP listesi parse ediliyor, aralık ya da virgülle ayrılmış olarak girilebilme durumları handle ediliyor.
                    //Dosyadan alınan hedeflerin parse edilip bunlardan oluşturulan scan assetlerin mevcut pentest scane eklenmesi.
                    List<Object> pscanAndIps = pentestService.parseScopeIpsByString(assetsFromFile, pentestScan.getExcludeIps());
                    String includeIpsFile = (String) pscanAndIps.get(1);
                    if (includeIps.length() > 0) {
                        if (includeIpsFile.length() > 1) {
                            includeIps += ", " + (String) pscanAndIps.get(1);
                        }
                    } else {
                        if (includeIpsFile.length() > 1) {
                            includeIps = (String) pscanAndIps.get(1);
                        } else { //hem text alanından hem de filedan gelen target alanları boş.
                            redirectAttributes.addFlashAttribute("errorMessage", "targetValidator.error");
                            return HttpUtil.sendRedirect("listScans.htm");
                        }
                    }
                    PentestScan pscanFromFile = (PentestScan) pscanAndIps.get(0);
                    if (pentestScan.getScanAssets() != null && pentestScan.getScanAssets().size() > 0) {
                        pentestScan.getScanAssets().addAll(pscanFromFile.getScanAssets());

                    } else {
                        pentestScan.setScanAssets(pscanFromFile.getScanAssets());
                    }
                    pentestScan.setTargets(includeIps);
                    if(pentestScan.getServer().getType() == null || !pentestScan.getServer().getType().equals(ServerType.SECURITY_CENTER.toString())) {
                        pentestScan.setProjectDetails(null);  
                    }
                } else {
                    pentestScan.setTargets(pentestScan.getProjectDetails().getProjectName());
                    pentestScan.setIncludedIps(pentestScan.getProjectDetails().getProjectName());
                }
            }
            
            ScanValidator validator = new ScanValidator();
            validator.validate(pentestScan, result);

            List<String> errorList = new LinkedList();

            //Hata varsa errorList'e ekleyip json ile gönderilir.
            if (result.hasErrors()) {
                for (Object object : result.getAllErrors()) {
                    if (object instanceof FieldError) {
                        FieldError fieldError = (FieldError) object;
                        errorList.add(fieldError.getCode());
                    }
                }
                if (!pentestScan.isPentestScan()) {
                    pentestScan.getServer().setUsername(null);
                    pentestScan.getServer().setPassword(null);
                }
                pentestScan.setErrorList(errorList);
                mv.addObject("errorList", pentestScan);
                List<Asset> ipList = customerService.getAssetsByCustomerId(customerId);
                List<ScanAsset> assetList = new LinkedList<>();
                for (Asset asset : ipList) {
                    ScanAsset scanAsset = new ScanAsset();
                    scanAsset.setScannedIp(asset.getIp());
                    assetList.add(scanAsset);
                }

                List<Server> scanEngines = pentestService.getVulnerabilityScanEngines(customerId);
                mv.addObject("assetList", assetList);
                mv.addObject("scanEngines", scanEngines);
                return mv;
            }
            pentestService.createPentestScan(pentestScan);
            
        } catch (Exception ex) {
            
            logger.log(LogLevel.ERROR, "Yeni tarama başlatılırken hata oluştu.", ex);
            redirectAttributes.addFlashAttribute("errorMessage", "listQualysScans.scan.failed");
            return HttpUtil.sendRedirect("listScans.htm");
            
        }
        
        return new ModelAndView("redirect:" + "listScans.htm");

    }

    /**
     * Tarama başlatma ekranında fortify proje diline göre komut getirir.
     *
     * @param request
     * @return String
     */
    @RequestMapping(value = "getCommand.json", method = RequestMethod.GET)
    @ResponseBody
    public String getFortifyCommand(HttpServletRequest request) {
        String language = ServletRequestUtils.getStringParameter(request, "language", "");
        String command = pentestService.getFortifyCommand(language);
        return command;
    }

    /**
     * "Tekrar Tara" seçeneği seçildiğinde çalışır.
     *
     * @param request
     * @param response
     * @return String
     */
    @RequestMapping(value = "rescan.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String rescan(HttpServletRequest request, HttpServletResponse response) throws BizzySecurityException {
        String oldScanId = ServletRequestUtils.getStringParameter(request, "oldScan", "");
        String newScanName = ServletRequestUtils.getStringParameter(request, "newScan", "");

        if (newScanName.trim().isEmpty()) {
            return "{\"error\": \"empty\"}";
        }

        PentestScan oldScan = pentestService.getScanById(oldScanId);
        if (oldScan.getServer().getSettingId() == null) {
            return "{\"error\": \"nullServer\"}";
        }

        DataTablesRequest dataTablesRequest = DataTablesUtil.getRequest(request);
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        List<PentestScan> scans = pentestService.getScans(dataTablesRequest, customerId, null, "all", false, null);

        for (PentestScan scan : scans) {
            if (newScanName.equals(scan.getName())) {
                return "{\"error\": \"same\"}";
            }
        }

        PentestScan newScan = new PentestScan();
        Date now = new Date();
        newScan.setScanAggregation(oldScan.isScanAggregation());
        newScan.setName(newScanName);
        newScan.setScanAssets(oldScan.getScanAssets());
        newScan.setDescription(oldScan.getDescription());
        newScan.setExcludeIps(oldScan.getExcludeIps());
        newScan.setRequestDate(now);
        newScan.setScheduled(false);
        newScan.setPentestScan(oldScan.isPentestScan());
        newScan.setPolicy(oldScan.getPolicy());
        newScan.setTargets(oldScan.getTargets());
        newScan.setTimezone(oldScan.getTimezone());
        newScan.setMinRiskLevel(oldScan.getMinRiskLevel());
        newScan.setOccurrence(OccurrenceType.ON_DEMAND);
        newScan.setRecurrence(oldScan.getRecurrence());
        newScan.setErrorList(oldScan.getErrorList());
        newScan.setScanner(oldScan.getScanner());
        newScan.setServer(serverService.getServer(oldScan.getServer().getSettingId(), customerId));
        newScan.setCustomer(oldScan.getCustomer());
        newScan.setRequestedBy(user.getUsername());
        newScan.setAutoClose(oldScan.isAutoClose());
        newScan.setMail(oldScan.getMail());
        newScan.setUseDefaultMinRiskLevelAction(oldScan.getUseDefaultMinRiskLevelAction());
        newScan.setUpdateOperatingSystem(oldScan.getUpdateOperatingSystem());
        newScan.setAssetGroupId(oldScan.getAssetGroupId());
        newScan.setProduceSslCertificateResults(oldScan.isProduceSslCertificateResults()); 
        newScan.setScanProscriptiveTimeStart(oldScan.getScanProscriptiveTimeStart());
        newScan.setScanProscriptiveTimeEnd(oldScan.getScanProscriptiveTimeEnd());
        if(oldScan.isSslScan()){
            newScan.setSslScan(true);
            newScan.setSslScanPorts(oldScan.getSslScanPorts());
        } else {
            newScan.setSslScan(false);
        }
        try {
            if(oldScan.isSslScan()){
                if(oldScan.getSource().name().equals("NMAP")){
                    newScan.setScanId(BizzyUtil.generateGUID());
                    newScan.setSource(Source.NMAP);
                    newScan.setScanDate(now);
                    newScan.setStatus(ScanStatus.QUEUED);
                    pentestService.saveScan(newScan);
                 //   pentestService.saveScanAssets(newScan.getScanAssets(), newScan.getScanId());
                    nmapScanService.startSslNmapScan(newScan);
                } else {
                    pentestService.createPentestScan(newScan);
                }
            } else {
                pentestService.createPentestScan(newScan);
            }
        } catch (Exception ex) {
            logger.log(LogLevel.ERROR, "Yeni tarama başlatılırken hata oluştu.", ex);

        }

        return "{}";
    }

    public boolean checkIfDiscoveryAlreadyAdded(List<AssetDiscovery> scanList, List<ScheduledAssetDiscovery> scheduledScanList, String name) {
        if (scanList.stream().anyMatch((ad) -> (ad.getName().equals(name)))) {
            return true;
        }
        return scheduledScanList.stream().anyMatch((sad) -> (sad.getName().equals(name)));
    }

    @RequestMapping(value = "startAssetDiscovery.htm", method = {RequestMethod.GET})
    public @ResponseBody
    ModelAndView startAssetDiscoveryPageGet(HttpServletRequest request, HttpServletResponse response, AssetDiscovery assetDiscovery, BindingResult result, final RedirectAttributes redirectAttributes) throws BizzySecurityException, BizzyException {
        ModelAndView mv = new ModelAndView();
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        List<AssetDiscovery> scanList = pentestService.getHostScans(null, customerId);
        List<ScheduledAssetDiscovery> scheduledScanList = pentestService.getScheduledHostScans(null, customerId);
        List<Message> assetSeverities = messageService.getMessages(ASSET_SEVERITY);
        List<AssetGroup> parentGroups = customerService.getAssetGroups(null, customerId);
        List<Server> scanEngines = new LinkedList();
        List<Server> hostScanEngines = new LinkedList();
        try {
            hostScanEngines = serverService.getHostDiscoveryServers(customerId);
            scanEngines.addAll(serverService.getServerNames(ServerType.NESSUS, customerId));
        } catch (Exception ex) {
            logger.log(LogLevel.ERROR, "Scanner listesi okunamadı.", ex);
        }
        List<AssetGroup> assetGroups = customerService.getAssetGroups(null, customerId);
        mv.addObject("scanEngines", scanEngines);
        mv.addObject("hostScanEngines", hostScanEngines);
        mv.addObject("assetGroups", assetGroups);
        mv.addObject("scanList", scanList);
        mv.addObject("scheduledScanList", scheduledScanList);
        mv.addObject("addAssetGroupForm", new AssetGroup());
        mv.addObject("parentGroups", parentGroups);
        mv.addObject("assetSeverities", assetSeverities);
        return mv;
    }

    /**
     * Varlık Keşfi başlatma sayfası
     *
     * @param request
     * @param response
     * @param assetDiscovery
     * @param result
     * @param redirectAttributes
     * @return mv
     * @throws BizzySecurityException
     * @throws BizzyException
     */
    @RequestMapping(value = "startAssetDiscovery.htm", method = {RequestMethod.POST})
    public @ResponseBody
    ModelAndView startAssetDiscoveryPage(HttpServletRequest request, HttpServletResponse response, AssetDiscovery assetDiscovery, BindingResult result, final RedirectAttributes redirectAttributes, @RequestParam("file") MultipartFile file) throws BizzySecurityException, BizzyException {
        ModelAndView mv = new ModelAndView();
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        List<AssetDiscovery> scanList = pentestService.getHostScans(null, customerId);
        List<ScheduledAssetDiscovery> scheduledScanList = pentestService.getScheduledHostScans(null, customerId);
        String assetsWithComma = null;
        String[] assetsFromFile = null;
        Iterator<String> itrator = ((MultipartHttpServletRequest) request).getFileNames();
        if (itrator.hasNext()) {
            try {
                ByteArrayInputStream stream = new ByteArrayInputStream(file.getBytes());
                assetsWithComma = IOUtils.toString(stream, "UTF-8");
                assetsFromFile = assetsWithComma.split(",");

            } catch (IOException ex) {
                Logger.getLogger(PentestController.class.getName()).log(Level.SEVERE, null, ex);
            }
        }

        try {
            Date now = new Date();
            assetDiscovery.setRequestDate(now);

            if (pentestService.isActiveScanLimitExceeded(customerId)) { //Aktif Tarama limit kontrolü
                logger.log(LogLevel.WARN, "Aktif Tarama limiti yetersiz.");
                redirectAttributes.addFlashAttribute("errorMessage", "activeScan.limit.error");
                return HttpUtil.sendRedirect("listAssetDiscoveries.htm");
            }

            //Aynı tarama kayıtlı mı kontrolü
            if (checkIfDiscoveryAlreadyAdded(scanList, scheduledScanList, assetDiscovery.getName())) {
                logger.log(LogLevel.ERROR, "Tarama adı kontrolü önyüzde devre dışı bırakıldı!!");
                redirectAttributes.addFlashAttribute("errorMessage", "startAssetDiscovery.sameName");
                return HttpUtil.sendRedirect("listAssetDiscoveries.htm");
            }

            if (!assetDiscovery.getServer().getSettingId().equals("-1")) {
                assetDiscovery.setServer(serverService.getServer(assetDiscovery.getServer().getSettingId(), customerId));
            }
            assetDiscovery.setCustomer(user.getCustomer());
            assetDiscovery.setRequestedBy(user.getUsername());

            if (assetDiscovery.getLaunch() == ScanLaunch.ON_DEMAND) {
                //ON_DEMAND seçildiyse 1 defa çalışacak.
                assetDiscovery.setRecurrence(1);
            }
            if (assetDiscovery.getRecurrence() == null || assetDiscovery.getRecurrence() == 0 || assetDiscovery.getRecurrence() > 100) {
                //Tekrar Sayısı 1-100 arası değilse sınırısız tarama olarak set edilir.
                assetDiscovery.setRecurrence(-1);
            }
            //Aynı zamananda başlayacak olan planlı taramaların limitinin kontrolü
            if (assetDiscovery.isScheduled()) {
                int count = 0;
                //planlı taramamızın bütün çalışma tarihlerinin hesaplanması
                Date dateConversionSupporter2 = assetDiscovery.getScanDate();
                LocalDateTime scanDate = dateConversionSupporter2.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
                List<LocalDateTime> scanDates = new ArrayList<>();
                int reccurence = assetDiscovery.getRecurrence();
                scanDates.add(scanDate);
                for (int i = 0; i < reccurence - 1; i++) {
                    switch (assetDiscovery.getLaunch()) {
                        case DAILY:
                            scanDate = scanDate.plusDays(1);
                            break;
                        case WEEKLY:
                            scanDate = scanDate.plusWeeks(1);
                            break;
                        case MONTHLY:
                            scanDate = scanDate.plusMonths(1);
                            break;
                        case QUARTERLY:
                            scanDate = scanDate.plusMonths(3);
                            break;
                        case YEARLY:
                            scanDate = scanDate.plusYears(1);
                            break;
                        default:
                            break;
                    }
                    scanDates.add(scanDate);
                }
                //bütün planlı tarama tarihleri hesaplanması
                List<ScheduledAssetDiscovery> scheduledAssetScans = pentestService.getScheduledHostScans(null, customerId);
                for (ScheduledAssetDiscovery sps : scheduledAssetScans) {
                    List<LocalDateTime> allDates = new ArrayList<>();
                    boolean isBreaked = false;
                    Date dateConversionSupporter = sps.getScanDate();
                    LocalDateTime date = dateConversionSupporter.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
                    reccurence = sps.getRecurrence();

                    if ((sps.getRecurrence() - sps.getCompletedScanCount() != 0 && !(sps.getLaunch().equals(OccurrenceType.ON_DEMAND.toString()) && sps.getCompletedScanCount() == 1))) {
                        allDates.add(date);
                        for (int i = 0; i < reccurence - 1; i++) {
                            switch (sps.getLaunch()) {
                                case DAILY:
                                    date = date.plusDays(1);
                                    break;
                                case WEEKLY:
                                    date = date.plusWeeks(1);
                                    break;
                                case MONTHLY:
                                    date = date.plusMonths(1);
                                    break;
                                case QUARTERLY:
                                    date = date.plusMonths(3);
                                    break;
                                case YEARLY:
                                    date = date.plusYears(1);
                                    break;
                                default:
                                    break;
                            }
                            allDates.add(date);
                        }
                    } else if (reccurence == -1) {
                        allDates.add(date);
                        switch (sps.getLaunch()) {
                            case DAILY:
                                //get hour&minute
                                Calendar calendar = GregorianCalendar.getInstance(); // creates a new calendar instance
                                calendar.setTime(sps.getScanDate());   // assigns calendar to given date 
                                int hourOne = calendar.get(Calendar.HOUR_OF_DAY); // gets hour in 24h format
                                int minuteOne = calendar.get(Calendar.MINUTE);
                                calendar.setTime(assetDiscovery.getScanDate());   // assigns calendar to given date 
                                int hourTwo = calendar.get(Calendar.HOUR_OF_DAY); // gets hour in 24h format
                                int minuteTwo = calendar.get(Calendar.MINUTE);

                                if (scanDate.isAfter(date) && (hourOne == hourTwo && minuteOne == minuteTwo)) {
                                    count++;
                                    isBreaked = true;
                                    break;
                                }
                            case WEEKLY:
                                for (int i = 0; i < 51; i++) {
                                    date = date.plusWeeks(1);
                                    allDates.add(date);
                                }
                                break;
                            case MONTHLY:
                                for (int i = 0; i < 11; i++) {
                                    date = date.plusMonths(1);
                                    allDates.add(date);
                                }
                                break;
                            case QUARTERLY:
                                for (int i = 0; i < 11; i++) {
                                    date = date.plusMonths(3);
                                    allDates.add(date);
                                }
                                break;
                            case YEARLY:
                                date = date.plusYears(1);
                                allDates.add(date);
                                break;
                            default:
                                break;
                        }
                    }
                    //Taramanın planlı saatleriyle, mevcut planlı taramaların saatlerinin karşılaştırılması
                    if (!allDates.isEmpty()) {
                        for (LocalDateTime scanDateElement : scanDates) {
                            if (isBreaked) {
                                break;
                            }
                            for (LocalDateTime allDateElement : allDates) {
                                if (scanDateElement.isEqual(allDateElement)) {
                                    count++;
                                    isBreaked = true;
                                    break;
                                }
                            }
                        }
                    }
                }
                List<ScheduledPentestScan> scheduledScans = pentestService.getScheduledScans(null, customerId, "all", false);
                for (ScheduledPentestScan sps : scheduledScans) {
                    List<LocalDateTime> allDates = new ArrayList<>();
                    boolean isBreaked = false;
                    Date dateConversionSupporter = sps.getScanDate();
                    LocalDateTime date = dateConversionSupporter.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
                    reccurence = sps.getRecurrence();

                    if ((sps.getRecurrence() - sps.getCompletedScanCount() != 0 && !(sps.getOccurrence().equals(OccurrenceType.ON_DEMAND) && sps.getCompletedScanCount() == 1))) {
                        allDates.add(date);
                        for (int i = 0; i < reccurence - 1; i++) {
                            switch (sps.getOccurrence()) {
                                case DAILY:
                                    date = date.plusDays(1);
                                    break;
                                case WEEKLY:
                                    date = date.plusWeeks(1);
                                    break;
                                case MONTHLY:
                                    date = date.plusMonths(1);
                                    break;
                                case QUARTERLY:
                                    date = date.plusMonths(3);
                                    break;
                                case YEARLY:
                                    date = date.plusYears(1);
                                    break;
                                default:
                                    break;
                            }
                            allDates.add(date);
                        }
                    } else if (reccurence == -1) {
                        allDates.add(date);
                        switch (sps.getOccurrence()) {
                            case DAILY:
                                //get hour&minute
                                Calendar calendar = GregorianCalendar.getInstance(); // creates a new calendar instance
                                calendar.setTime(sps.getScanDate());   // assigns calendar to given date 
                                int hourOne = calendar.get(Calendar.HOUR_OF_DAY); // gets hour in 24h format
                                int minuteOne = calendar.get(Calendar.MINUTE);
                                calendar.setTime(assetDiscovery.getScanDate());   // assigns calendar to given date 
                                int hourTwo = calendar.get(Calendar.HOUR_OF_DAY); // gets hour in 24h format
                                int minuteTwo = calendar.get(Calendar.MINUTE);

                                if (scanDate.isAfter(date) && (hourOne == hourTwo && minuteOne == minuteTwo)) {
                                    count++;
                                    isBreaked = true;
                                    break;
                                }
                            case WEEKLY:
                                for (int i = 0; i < 51; i++) {
                                    date = date.plusWeeks(1);
                                    allDates.add(date);
                                }
                                break;
                            case MONTHLY:
                                for (int i = 0; i < 11; i++) {
                                    date = date.plusMonths(1);
                                    allDates.add(date);
                                }
                                break;
                            case QUARTERLY:
                                for (int i = 0; i < 11; i++) {
                                    date = date.plusMonths(3);
                                    allDates.add(date);
                                }
                                break;
                            case YEARLY:
                                date = date.plusYears(1);
                                allDates.add(date);
                                break;
                            default:
                                break;
                        }
                    }
                    //Taramanın planlı saatleriyle, mevcut planlı taramaların saatlerinin karşılaştırılması
                    if (!allDates.isEmpty()) {
                        for (LocalDateTime scanDateElement : scanDates) {
                            if (isBreaked) {
                                break;
                            }
                            for (LocalDateTime allDateElement : allDates) {
                                if (scanDateElement.isEqual(allDateElement)) {
                                    count++;
                                    isBreaked = true;
                                    break;
                                }
                            }
                        }
                    }
                }
                String scanLimitCount = limitService.getLimitValueByTypeValueAndCustomerId(LimitTypeEnum.SCHEDULED_SCAN.getType(), LimitValueTypeEnum.COUNT.getType(), customerId);
                if (scanLimitCount != null) {
                    if (Integer.parseInt(scanLimitCount) <= count) {
                        logger.log(LogLevel.WARN, "Aynı zamanlı başlangıçlı planlanan tarama limiti yetersiz.");
                        redirectAttributes.addFlashAttribute("errorMessage", "scheduledscan.limit.error");
                        return HttpUtil.sendRedirect("listAssetDiscoveries.htm");
                    }
                }
            }
            TargetValidator targetValidator = new TargetValidator();
            List<Asset> appAssets = assetService.getAssetsByType("APPLICATION", customerId);
            List<AssetGroup> groupAssets = customerService.getAssetGroups(null, customerId);
            if (assetDiscovery.getTarget() != null) {
                String[] splittedIps = assetDiscovery.getTarget().split(",");
                for (String target : splittedIps) {
                    String errorStr = targetValidator.validate(assetDiscovery.getServer().getType(), target.trim(), appAssets, groupAssets);
                    if (errorStr.length() > 0) {
                        redirectAttributes.addFlashAttribute("errorMessage", "targetValidator.error");
                        return HttpUtil.sendRedirect("listAssetDiscoveries.htm");
                    }
                }
            }
            //Dosyadan ip verildiyse onların kontrolü
            for (String target : assetsFromFile) {
                if (!target.equals("")) {
                    String errorStr = targetValidator.validate(assetDiscovery.getServer().getType(),target.trim(), appAssets, groupAssets);
                    if (errorStr.length() > 0) {
                        redirectAttributes.addFlashAttribute("errorMessage", "targetValidator.error");
                        return HttpUtil.sendRedirect("listScans.htm");
                    }
                }
            }
            StringBuilder allTarget = new StringBuilder();
            boolean textInputExist = false;
            if (assetDiscovery.getTarget() != null && !assetDiscovery.getTarget().equals("") && !assetDiscovery.getTarget().equals(" ")) {
                allTarget.append(assetDiscovery.getTarget());
                textInputExist = true;
            }
            if (assetsWithComma != null && !assetsWithComma.equals("") && !assetsWithComma.equals(" ")) {
                if (textInputExist) {
                    allTarget.append(",");
                }
                allTarget.append(assetsWithComma);
            }
            StringBuilder cleaned = new StringBuilder();
            String[] seperated = allTarget.toString().split(",");
            for (int i = 0; i < seperated.length; i++) {
                if (!BizzyUtil.isEmpty(seperated[i].trim())) {
                    if (i != 0) {
                        cleaned.append(",");
                    }
                    cleaned.append(seperated[i].trim());
                }
            }
            assetDiscovery.setTarget(cleaned.toString());
            HostScanValidator validator = new HostScanValidator();
            validator.validate(assetDiscovery, result);

            //Hata varsa errorList'e ekleyip json ile gönderilir.
            if (result.hasErrors()) {
                List<String> errorList = new LinkedList();
                for (Object object : result.getAllErrors()) {
                    if (object instanceof FieldError) {
                        FieldError fieldError = (FieldError) object;
                        errorList.add(fieldError.getCode());
                    }

                }
                if (!assetDiscovery.getServer().getSettingId().equals("-1")) {
                    assetDiscovery.getServer().setUsername(null);
                    assetDiscovery.getServer().setPassword(null);
                }                
                assetDiscovery.setErrorList(errorList);
                mv.addObject("errorList", assetDiscovery);
                List<Server> scanEngines = new LinkedList();
                try {
                    scanEngines = serverService.getHostDiscoveryServers(customerId);
                } catch (Exception ex) {
                    logger.log(LogLevel.WARN, "Scanner listesi okunamadı.", ex);
                }
                List<AssetGroup> assetGroups = customerService.getAssetGroups(null, customerId);
                mv.addObject("scanEngines", scanEngines);
                mv.addObject("assetGroups", assetGroups);
                return mv;
            }

            createHostScan(assetDiscovery); //Keşif başlatma işlemleri
        } catch (Exception ex) {
            logger.log(LogLevel.ERROR, "Keşif taraması başlatılırken hata oluştu.", ex);
            redirectAttributes.addFlashAttribute("errorMessage", "discovery.error");
            return HttpUtil.sendRedirect("listAssetDiscoveries.htm");
        }

        return new ModelAndView("redirect:" + "listAssetDiscoveries.htm");

    }

    /**
     * Zafiyet - Bilgi Bankası Zafiyeti, eşleşen zafiyetleri çekme
     * @param request
     * @param response
     * @return String
     */
    @RequestMapping(value = "getMatchedItems.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String getMatchedItems(HttpServletRequest request, HttpServletResponse response) {

        String id = ServletRequestUtils.getStringParameter(request, "kbId", null);
        List<VulnerabilityKbItem> matchedIds = customerService.getMatchedVulnerabilityIds(id);
        List<Vulnerability> vulnerabilities = new LinkedList<>();
        for (VulnerabilityKbItem item : matchedIds) {
            String vulnNumber = item.getVulnNumber();
            String scanner = item.getScannerType();
            Vulnerability vuln = customerService.getVulnerability(null, vulnNumber, scanner);
            if (vuln.getVulnerabilityId() != null) {
                vulnerabilities.add(vuln);
            }
        }
        return JsonUtil.getResponse(vulnerabilities);
    }
    
    /**
     * Zafiyet Kategorisi - Bilgi Bankası Kategorisi, eşleşen zafiyetleri çekme
     * @param request
     * @param response
     * @return String
     */
    @RequestMapping(value = "getMatchedCategories.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String getMatchedCategories(HttpServletRequest request, HttpServletResponse response) {

        String id = ServletRequestUtils.getStringParameter(request, "kbId", null);
        List<VulnerabilityKbItem> matchedIds = customerService.getCategoryMatchedVulnerabilityIds(id);
        List<String> vulnerabilities = new LinkedList<>();
        for (VulnerabilityKbItem item : matchedIds) {
            String category = customerService.getPluginCategoryByName(item.getVulnNumber());
            if (category != null) {
                vulnerabilities.add(category);
            }
        }
        return JsonUtil.getResponse(vulnerabilities);
    }

    /**
     * Zafiyet - Bilgi Bankası Zafiyeti, eşleştirmeyi kaldırma
     * @param request
     * @param response
     * @return String
     */
    @RequestMapping(value = "removeMatchedItems.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String removeMatchedItems(HttpServletRequest request, HttpServletResponse response) {

        String id = ServletRequestUtils.getStringParameter(request, "kbId", null);
        String[] removedIds = ServletRequestUtils.getStringParameters(request, "removedIds[]");

        for (int x = 0; x < removedIds.length; x++) {
            Vulnerability vuln = customerService.getVulnerability(removedIds[x], null, null);
            customerService.removeMatch(id, vuln.getVulnNumber(), vuln.getSource());
        }
        return "";
    }
    
    @RequestMapping(value = "removeMatchedCategories.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String removeMatchedCategories(HttpServletRequest request, HttpServletResponse response) {

        String id = ServletRequestUtils.getStringParameter(request, "kbId", null);
        String[] removedIds = ServletRequestUtils.getStringParameters(request, "removedIds[]");

        for (int x = 0; x < removedIds.length; x++) {
            String category = customerService.getPluginCategoryByName(removedIds[x]);
            customerService.removeCategoryMatch(id, category, null);
        }
        return "";
    }

    /**
     * Zafiyet - Bilgi Bankası Zafiyeti, eşleştirme
     * @param request
     * @param response
     * @param matches
     * @return String
     * @throws BizzyException 
     */
    @RequestMapping(value = "matchVulnerabilities.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String matchVulnerabilities(HttpServletRequest request, HttpServletResponse response, @RequestParam(value = "matches[][]") String[][] matches) throws BizzyException {
        String[] scannerIds = matches[0];
        String kbId = matches[1][0];

        VulnerabilityFilter filter = new VulnerabilityFilter();
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        filter.setCustomerId(customerId);
        List<ScanVulnerability> vulnerabilities = customerService.getVulnerabilities(null, filter);
        List<String> vulnNumbers = new LinkedList<>();

        if (scannerIds.length != 0 && kbId != null) {
            for (ScanVulnerability vuln : vulnerabilities) {
                String pluginId = vuln.getVulnerability().getVulnNumber();
                String type = vuln.getVulnerability().getSource();
                if (pluginId != null && Arrays.asList(scannerIds).contains(pluginId) && !vulnNumbers.contains(pluginId)) {
                    vulnNumbers.add(pluginId);
                    customerService.matchVulnerabilities(pluginId, kbId, type);
                }
            }
        }
        List<String> matched = new LinkedList<String>();
        matched.add("matched");
        return JsonUtil.getResponse(matched);
    }

    @RequestMapping(value = "matchVulnerabilitiesWithCategory.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String matchVulnerabilitiesWithCategory(HttpServletRequest request, HttpServletResponse response, @RequestParam(value = "matches[][]") String[][] matches) throws BizzyException {
        
        String[] scannerIds = matches[0];
        String kbId = matches[1][0];
        VulnerabilityFilter filter = new VulnerabilityFilter();
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        filter.setCustomerId(customerId);
        Map<String,String> categories = customerService.getPluginCategoriesAndSources();
        List<String> vulnNumbers = new LinkedList<>();

        if (scannerIds.length != 0 && kbId != null) {
            for (Map.Entry<String, String> entry : categories.entrySet()) {
                String category = entry.getKey();
                String type = entry.getValue();
                if (category != null && Arrays.asList(scannerIds).contains(category) && !vulnNumbers.contains(category)) {
                    vulnNumbers.add(category);
                    customerService.matchVulnerabilitiesWithCategory(category, kbId, type);
                }
            }
        }
        List<String> matched = new LinkedList<String>();
        matched.add("matched");
        return JsonUtil.getResponse(matched);
    }

    /**
     * Import sayfası
     *
     * @param request
     * @return mv
     */
    @RequestMapping(value = "importFromOutput.htm", method = RequestMethod.GET)
    public @ResponseBody
    ModelAndView importFromOutputPage(HttpServletRequest request) {

        ModelAndView mv = new ModelAndView();
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        List<AssetGroup> assetGroups = customerService.getAssetGroups(null, customerId);
        mv.addObject("assetGroups", assetGroups);
        List<PentestScan> pentestScans = pentestService.getPentestScansByCustomerId(customerId);
        mv.addObject("pentestScans", pentestScans);
        String isAggregationActive = configurationService.getByKeyAndCustomerId("aggregationActive", customerId).get(0);
        mv.addObject("isAggregationActive", isAggregationActive);
        mv.addObject("fileAdded", false);
        mv.addObject("error", "none");
        return mv;

    }

    /**
     * Import sırasında dosya türü kontrolü yapılır (Bu kontrol wizard için,
     * sonraki aşamada bir kontrol daha yapılacak).
     *
     * @param request
     * @param response
     * @return String
     */
    @RequestMapping(value = "checkImportFile.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    public @ResponseBody
    String checkImportFile(HttpServletRequest request, HttpServletResponse response) {

        String importType = ServletRequestUtils.getStringParameter(request, "importType", null);
        String fileExt = ServletRequestUtils.getStringParameter(request, "extension", null);
        switch (importType) {
            case "NESSUS":
                if (fileExt.equalsIgnoreCase("nessus") || fileExt.equalsIgnoreCase("zip") || fileExt.equalsIgnoreCase("rar")) {
                    return "true";
                } else {
                    return "false";
                }
            case "WEBINSPECT":
            case "FORTIFY":
                if (fileExt.equals("fpr")) {
                    return "true";
                } else {
                    return "false";
                }
            case "PENTEST":
                if (fileExt.equals("json")) {
                    return "true";
                } else {
                    return "false";
                }
            case "BURP":
            case "QUALYS":
            case "APPSCAN":
            case "NETSPARKERENT":
            case "ARACHNI":
            case "NETSPARKER":
            case "CHECKMARX":
            case "OWAPS":
                if (fileExt.equals("xml")) {
                    return "true";
                } else {
                    return "false";
                }
            case "WAPITI":
                if (fileExt.equals("xml")) {
                    return "true";
                } else {
                    return "false";
                }
            case "ACUNETIX":
                if (fileExt.equals("xml") || fileExt.equals("html") || fileExt.equals("htm")) {
                    return "true";
                } else {
                    return "false";
                }
            case "EXCEL":
                if (fileExt.equals("xlsx")) {
                    return "true";
                } else {
                    return "false";
                }
            default:
                return "false";
        }

    }

    /**
     * Import onayından önce burada da uzantı kontrol edilir. Ek olarak dosyanın
     * parse edilip edilemediğinin kontrolü (uygun içerik mi?) ve boyut kontrolü
     * yapılır. Ardından verilen parametrelere göre filtreleme yapılır (Şu kadar
     * varlıkta şu kadar zafiyet içeri aktarılacak şeklinde). Ayrıca zafiyet -
     * bilgi bankası eşleştirme modülü açık ise, import içeriğine göre
     * eşleştirme ekranı oluşturulur.
     *
     * @param request
     * @param response
     * @param pentestScan
     * @param result
     * @param file
     * @param scanSource
     * @param minRiskLevel
     * @param pentestScanId
     * @param scanName
     * @throws InvalidFormatException
     * @return String
     */
    @RequestMapping(value = "importFromOutput.htm", method = {RequestMethod.POST})
    public @ResponseBody
    ModelAndView importFromOutput(HttpServletRequest request, HttpServletResponse response, PentestScan pentestScan, BindingResult result,
            @RequestParam("file") MultipartFile file,
            @RequestParam("sourceType") String scanSource,
            @RequestParam("level") String minRiskLevel,
            @RequestParam("pentestScans") String pentestScanId,
            @RequestParam("scanName") String scanName) throws InvalidFormatException, ServletRequestBindingException, XMLStreamException, JSONException {

        List<ScanAsset> filteredResults = new LinkedList<>();
        // "Şu kadar varlığa şu kadar zafiyet eklenecek" uyarısı için kullanılacak.

        ModelAndView mv = new ModelAndView();
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        String isAggregationActive = configurationService.getByKeyAndCustomerId("aggregationActive", customerId).get(0);
        mv.addObject("isAggregationActive", isAggregationActive);
        String fileName = file.getOriginalFilename();
        String fileExt = BizzyUtil.getFileExtension(fileName);
        ImportObject importObject = new ImportObject();
        request.getSession().setAttribute("fileType", scanSource);
        request.getSession().setAttribute("scanName", scanName);
        request.getSession().setAttribute("pentestScanId", pentestScanId);
        if (file.getSize() > 209715200) {
            mv.addObject("error", "sizeError");
            mv.addObject("fileAdded", false);
            return mv;
        }
        String checkScan = pentestService.getScanByName(scanName, customerId);

        if (checkScan != null) {
            mv.addObject("error", "sameNameAlreadyExist");
            mv.addObject("fileAdded", false);
            return mv;
        }
        // Dosyanın uzantı ve içerik kontrolü yapılır, parse edilip edilememediğine bakılır.
        // Filtreleme için import sonucu ScanAsset listesine dönüştürülür.
        Source importSource = Source.valueOf(scanSource);
        Integer level = Integer.valueOf(minRiskLevel);
        request.getSession().setAttribute("levelFilter", level);
        String[] assetGroup = ServletRequestUtils.getStringParameters(request, "assetGroup[]");

        //Qualys zafiyet türlerine göre import için gerekli parametreler, hiçbir checkbox seçilmemişse hepsi import edilir.
        String qualysPotential = ServletRequestUtils.getStringParameter(request, "qualysPotential");
        String qualysConfirmed = ServletRequestUtils.getStringParameter(request, "qualysConfirmed");
        String qualysInformational = ServletRequestUtils.getStringParameter(request, "qualysInformational");
        if (qualysPotential == null && qualysConfirmed == null && qualysInformational == null) {
            qualysPotential = "Potential";
            qualysConfirmed = "Confirmed";
            qualysInformational = "Informational";
        }
        
        String excelKb = ServletRequestUtils.getStringParameter(request, "excelKb", "");
        request.getSession().setAttribute("excelKb", excelKb);

        request.getSession().setAttribute("assetGroupFilter", assetGroup);
        List<VulnerabilityKbItem> matchedIds = customerService.getMatchedVulnerabilityIds(null);
        List<ScanAsset> results = null;
        try {
            switch (importSource) {
                case NESSUS:
                    if (!(fileExt.equals("nessus") || fileExt.equals("rar") || fileExt.equals("zip"))) {
                        result.rejectValue("name", "importFromNessusOutput.formatError", "Lütfen Nessus uzantılı bir dosya ya da Nessus uzantılı dosya içeren bir ZIP-RAR dosyası seçiniz.");
                        return mv;
                    } else {
                        NessusXmlParser nessusXmlParser = new NessusXmlParser();
                        NessusClientData_v2 data;
                        if (fileExt.equals("nessus")) {
                            data = nessusXmlParser.parseNessusOutput(file.getInputStream());

                        } else {
                            data = nessusXmlParser.parseNessusOutputFromZip(file.getInputStream());
                        }
                        logger.log(LogLevel.INFO, "Nessus dosyası parse işlemi başarılı!");
                        file.getInputStream().close();
                        importObject.setNessus(data);
                        PentestScan scan = new PentestScan();
                        results = nessusService.parseNessusClientDataToScanAssetListSimpleModify(data, customerId, scan);
                        
                        logger.log(LogLevel.INFO, "Nessus verisi ScanAsset listesine dönüştürüldü!");
                        ArrayList<String> oldScanIds = pentestService.getOldScanIds();
                        List<Preference> importedPrefs = data.getPolicy().getPreferences().getServerPreferences().getPreferences();
                        String newScanId = "";
                        for (Preference prf : importedPrefs) {
                            if (prf.getName().equals("report_task_id")) {
                                newScanId = prf.getValue();
                            }
                        }
                        for (String oldid : oldScanIds) {
                            if (oldid != null && oldid.equals(newScanId)) {
                                mv.addObject("error", "sameNessusAlreadyExist");
                                mv.addObject("fileAdded", true);
                                return mv;
                            }
                        }
                        request.getSession().setAttribute("importObject", importObject);
                    }
                    break;
                case BURP:
                    if (!fileExt.equals("xml")) {
                        result.rejectValue("name", "importFromOutput.formatError", "Lütfen xml uzantılı bir Burp dosyası seçiniz.");
                        return mv;
                    } else {
                        BurpXmlParser burpXmlParser = new BurpXmlParser();
                        Issues data = burpXmlParser.parseBurpOutput(file.getInputStream());
                        file.getInputStream().close();
                        List<String> uniqueIpList = new LinkedList<>();
                        String ip;
                        for (Issue issue : data.getIssue()) {
                            ip = issue.getHost().getIp();
                            if (!uniqueIpList.contains(ip)) {
                                uniqueIpList.add(ip);
                            }
                        }
                        results = parseBurpDataToScanAssetListSimpleModify(data, uniqueIpList);
                        importObject.setBurp(data);
                        request.getSession().setAttribute("importObject", importObject);
                    }
                    break;
                case QUALYS:
                    if (!fileExt.equals("xml")) {
                        result.rejectValue("name", "importFromOutput.formatError", "Lütfen xml uzantılı bir Qualys dosyası seçiniz.");
                        return mv;
                    } else {
                        QualysXmlParser qualysXmlParser = new QualysXmlParser();
                        Scan data = qualysXmlParser.parseFetchReportOutput(file.getInputStream());
                        data.setImportVulnTypes(Arrays.asList(qualysConfirmed, qualysInformational, qualysPotential));
                        file.getInputStream().close();
                        importObject.setQualys(data);
                        results = parseQualysDataToScanAssetListSimpleModify(data);
                        request.getSession().setAttribute("importObject", importObject);
                    }
                    break;
                case APPSCAN:
                    if (!fileExt.equals("xml")) {
                        result.rejectValue("name", "importFromOutput.formatError", "Lütfen xml uzantılı bir AppScan dosyası seçiniz.");
                        return mv;
                    } else {
                        AppScanXmlParser appScanXmlParser = new AppScanXmlParser();
                        AppScanReport data = appScanXmlParser.parseAppScanOutput(file.getInputStream());
                        file.getInputStream().close();
                        importObject.setAppScan(data);
                        PentestScan scan = new PentestScan();
                        results = appScanService.parseAppScanDataToScanAssetListSimpleModify(data, customerId, scan);
                        request.getSession().setAttribute("importObject", importObject);
                    }
                    break;
                case FORTIFY:
                    if (!fileExt.equals("fpr")) {
                        result.rejectValue("name", "importFromOutput.formatError", "Lütfen fpr uzantılı bir dosya seçiniz.");
                        return mv;
                    } else {
                        importObject.setFileStream(file.getInputStream());
                        importObject.setFinalFileStream(file.getInputStream());
                        FortifyXmlParser fortifyXmlParser = new FortifyXmlParser();
                        FortifyReport data = fortifyXmlParser.parseFortifyOutput(importObject.getFileStream());
                        importObject.setFortify(data);
                        PentestScan scan = new PentestScan();
                        results = (List<ScanAsset>) fortifyService.parseFortifyDataToScanAssetListSimpleModify(data, customerId, scan, true).get(0);
                        request.getSession().setAttribute("importObject", importObject);
                    }
                    break;
                case ARACHNI:
                    if (!fileExt.equals("xml")) {
                        result.rejectValue("name", "importFromOutput.formatError", "Lütfen xml uzantılı bir Arachni dosyası seçiniz.");
                        return mv;
                    } else {
                        importObject.setFileStream(file.getInputStream());
                        importObject.setFinalFileStream(file.getInputStream());
                        ArachniXmlParser arachniXmlParser = new ArachniXmlParser();
                        PentestScan scan = new PentestScan();
                        ArachniReport arachniData = arachniXmlParser.parseArachniOutput(importObject.getFileStream());
                        importObject.setArachni(arachniData);
                        results = arachniService.parseArachniDataToScanAssetListSimpleModify(arachniData, customerId, scan);
                        request.getSession().setAttribute("importObject", importObject);
                    }
                    break;
                case WEBINSPECT:
                    if (!fileExt.equals("fpr")) {
                        result.rejectValue("name", "importFromOutput.formatError", "Lütfen fpr uzantılı bir dosya seçiniz.");
                        return mv;
                    } else {
                        importObject.setFileStream(file.getInputStream());
                        importObject.setFinalFileStream(file.getInputStream());
                        WebinspectXmlParser webinspectXmlParser = new WebinspectXmlParser();
                        List<Object> list = webinspectXmlParser.parseWebinspectOutput(importObject.getFileStream());

                        importObject.setWebinspect((WebinspectReport) list.get(0));
                        importObject.setWebinspectInfo((WebinspectInfo) list.get(1));
                        PentestScan scan = new PentestScan();
                        results = webinspectService.parseWebinspectDataToScanAssetListSimpleModify((WebinspectReport) list.get(0), (WebinspectInfo) list.get(1), customerId, scan);
                        request.getSession().setAttribute("importObject", importObject);
                    }
                    break;
                case CHECKMARX:
                    if (!fileExt.equals("xml")) {
                        result.rejectValue("name", "importFromOutput.formatError", "Lütfen xml uzantılı bir Checkmarx dosyası seçiniz.");
                        return mv;
                    } else {
                        importObject.setFileStream(file.getInputStream());
                        importObject.setFinalFileStream(file.getInputStream());
                        CheckmarxXmlParser checkmarxXmlParser = new CheckmarxXmlParser();
                        PentestScan scan = new PentestScan();
                        CheckmarxReport checkmarxData = checkmarxXmlParser.parseCheckmarxOutput(importObject.getFileStream());
                        importObject.setCheckmarxReport(checkmarxData);
                        results = (List<ScanAsset>)checkmarxService.parseCheckmarxDataToScanAssetListSimpleModify(checkmarxData, customerId, scan, true).get(0);
                        request.getSession().setAttribute("importObject", importObject);
                    }
                    break;
                case WAPITI:
                    if (!fileExt.equals("xml")) {
                        result.rejectValue("name", "importFromOutput.formatError", "Lütfen xml uzantılı bir Wapiti dosyası seçiniz.");
                        return mv;
                    } else {
                        importObject.setFileStream(file.getInputStream());
                        importObject.setFinalFileStream(file.getInputStream());
                        WapitiXmlParser wapitiXmlParser = new WapitiXmlParser();
                        WapitiReport data = wapitiXmlParser.parseWapitiOutput(importObject.getFileStream());
                        importObject.setWapiti(data);
                        String ip = null;
                        for (WapitiInfo winfo : data.getInfo()) {
                            if (winfo.getName().equals("target")) {
                                ip = winfo.getValue();
                            }
                        }
                        List<String> uniqueIpList = new LinkedList<>();
                        uniqueIpList.add(ip);
                        results = parseWapitiDataToScanAssetListSimpleModify(data, uniqueIpList);
                        request.getSession().setAttribute("importObject", importObject);
                    }
                    break;
                case ACUNETIX:
                    if (fileExt.equals("xml") || fileExt.equals("html") || fileExt.equals("htm")) {
                        importObject.setFileStream(file.getInputStream());
                        importObject.setFinalFileStream(file.getInputStream());
                        AcunetixReport data;
                        if (fileExt.equals("xml")) {
                            AcunetixXmlParser acunetixXmlParser = new AcunetixXmlParser();
                            data = acunetixXmlParser.parseAcunetixOutput(importObject.getFileStream());
                        } else {
                            AcunetixHtmlParser acunetixHtmlParser = new AcunetixHtmlParser();
                            data = acunetixHtmlParser.parseAcunetixOutput(importObject.getFileStream());
                        }
                        importObject.setAcunetix(data);
                        PentestScan scan = new PentestScan();
                        results = acunetixService.parseAcunetixDataToScanAssetListSimpleModify(data, customerId, scan);
                        request.getSession().setAttribute("importObject", importObject);
                    } else {
                        result.rejectValue("name", "importFromOutput.formatError", "Lütfen xml ya da html uzantılı bir acunetix dosyası seçiniz.");
                        return mv;
                    }

                    break;
                case NETSPARKER:
                    if (!fileExt.equals("xml")) {
                        result.rejectValue("name", "importFromOutput.formatError", "Lütfen xml uzantılı bir Netsparker dosyası seçiniz.");
                        return mv;
                    } else {
                        importObject.setFileStream(file.getInputStream());
                        importObject.setFinalFileStream(file.getInputStream());
                        NetsparkerXmlParser netsparkerXmlParser = new NetsparkerXmlParser();
                        NetsparkerReport data = netsparkerXmlParser.parseNetsparkerOutput(importObject.getFileStream());
                        importObject.setNetsparker(data);
                        PentestScan scan = new PentestScan();
                        results = netsparkerService.parseNetsparkerDataToScanAssetListSimpleModify(data, customerId, scan);
                        request.getSession().setAttribute("importObject", importObject);
                    }
                    break;
                case NETSPARKERENT:
                    if (!fileExt.equals("xml")) {
                        result.rejectValue("name", "importFromOutput.formatError", "Lütfen xml uzantılı bir Netsparker dosyası seçiniz.");
                        return mv;
                    } else {
                        importObject.setFileStream(file.getInputStream());
                        importObject.setFinalFileStream(file.getInputStream());
                        NetsparkerEntXmlParser netsparkerXmlParser = new NetsparkerEntXmlParser();
                        NetsparkerEntReport data = netsparkerXmlParser.parseNetsparkerOutput(importObject.getFileStream());
                        importObject.setNetsparkerEnt(data);
                        PentestScan scan = new PentestScan();
                        results = netsparkerService.parseNetsparkerEntDataToScanAssetList(data, customerId, scan);
                        request.getSession().setAttribute("importObject", importObject);
                    }
                    break;
                case PENTEST:
                    if (!fileExt.equals("json")) {
                        result.rejectValue("name", "importFromOutput.formatError", "Lütfen json uzantılı bir dosya seçiniz.");
                        return mv;
                    } else {
                        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(file.getInputStream(), "UTF-8"));
                        String line = "";
                        String jsonString = "";
                        while ((line = bufferedReader.readLine()) != null) {
                            jsonString += line;
                        }
                        String wellFormedJson = JsonSanitizer.sanitize(jsonString);
                        ScanAsset[] scanAssets = gson.fromJson(wellFormedJson, ScanAsset[].class);
                        results = Arrays.asList(scanAssets);
                        request.getSession().setAttribute("finalPentest", jsonString);
                    }
                    break;
                case OWAPS:
                    if (!fileExt.equals("xml")) {
                        result.rejectValue("name", "importFromOutput.formatError", "Lütfen xml uzantılı bir Owaps dosyası seçiniz.");
                        return mv;
                    } else {
                        importObject.setFileStream(file.getInputStream());
                        importObject.setFinalFileStream(file.getInputStream());
                        OwapsXmlParser owapsXmlParser = new OwapsXmlParser();
                        OwapsReport data;
                        data = owapsXmlParser.parseOwapsOutput(importObject.getFileStream());
                        importObject.setOwapsReport(data);
                        PentestScan scan = new PentestScan();
                        results = owapsService.parseOwapsataToScanAssetListSimpleModify(data, customerId, scan);
                        request.getSession().setAttribute("importObject", importObject);
                    }
                    break;
                case EXCEL:
                    if (!fileExt.equals("xlsx")) {
                        result.rejectValue("name", "importFromOutput.formatError", "Lütfen xlsx uzantılı bir dosya seçiniz.");
                        return mv;
                    } else {
                        File excelFile = multipartToFile(file, fileName);
                        results = excelService.parseExcelFile(excelFile, customerId ,excelKb);
                        request.getSession().setAttribute("finalExcel", results);
                    }
                    break;
                default:
                    break;
            }
        } catch (Exception ex) {
            ex.printStackTrace();
            logger.log(LogLevel.ERROR, "Import dosyası işlemede hata!" + ex);
            mv.addObject("fileAdded", false);
            mv.addObject("error", "parseError");
            return mv;
        }
        if (!importSource.equals(Source.APPSCAN)) {
            // Appscanda istisnalar olduğu için fonksiyonu ayrı
            filterImportResults(results, filteredResults, level, customerId, assetGroup, mv, null, importSource);
        } else {
            ImportObject temp = (ImportObject) request.getSession().getAttribute("importObject");
            filterAppscanResults(results, filteredResults, level, customerId, assetGroup, mv, null, temp.getAppScan());
        }

        if (isAggregationActive.equals("true")) {
            getToolVulnerabilitiesAndKbVulnerabilitiesForAggregation(filteredResults, matchedIds, importObject);
        }
        mv.addObject("fileAdded", true);
        mv.addObject("error", "none");
        return mv;

    }

    /**
     * Import filtresi onaylandıktan sonra kaydetme işlemi yapılır. Aggregation
     * aktif ise ve yapılmışsa onun sonuçları da kaydedilir.
     *
     * @param request
     * @param response
     * @param matches
     * @throws JAXBException
     * @throws ParseException
     * @throws Exception
     * @return
     */
    @RequestMapping(value = "importFromOutputFilterConfirm.json", method = {RequestMethod.POST, RequestMethod.GET})
    public @ResponseBody
    ModelAndView importFromOutputFilterConfirm(HttpServletRequest request, HttpServletResponse response, @RequestParam(value = "matches[][]", required = false) String[][] matches) throws JAXBException, ParseException, Exception {

        Locale locale = RequestContextUtils.getLocale(request);
        Integer level = (Integer) request.getSession().getAttribute("levelFilter");
        String[] assetGroup = (String[]) request.getSession().getAttribute("assetGroupFilter");
        List<AssetGroup> groups = new LinkedList<>();
        for (String item : assetGroup) {
            AssetGroup group = customerService.getAssetGroupById(item);
            groups.add(group);
        }
        String fileFormat = (String) request.getSession().getAttribute("fileType");
        String newScanName = (String) request.getSession().getAttribute("scanName");
        String pentestScanId = (String) request.getSession().getAttribute("pentestScanId");
        String excelKb = (String) request.getSession().getAttribute("excelKb");
        Source importSource = Source.valueOf(fileFormat);

        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        try {
            List<ScanAsset> results = new LinkedList<>();
            List<ScanAsset> filteredResults = new LinkedList<>();
            PentestScan scan = new PentestScan();
            //Import edilen tarama özellikleri 
            String scanId = BizzyUtil.generateGUID();
            scan.setScanId(scanId);
            scan.setStatus(ScanStatus.IMPORTING);
            scan.setRequestedBy(user.getUsername());
            scan.setCustomer(user.getCustomer());
            scan.setResultsSaved(true);
            scan.setOccurrence(OccurrenceType.ON_DEMAND);
            scan.setScheduled(false);
            scan.setRequestDate(new Date());
            scan.setExcelKb(excelKb);
            switch (importSource) {
                case NESSUS: {
                    scan.setSource(Source.NESSUS);
                    String newScanId = "";
                    ImportObject importObject = (ImportObject) request.getSession().getAttribute("importObject");
                    NessusClientData_v2 data = importObject.getNessus();
                    Report report = data.getReport();
                    if (newScanName != null && !"".equals(newScanName)) {
                        scan.setName(newScanName);
                    } else {
                        scan.setName(report.getName());
                    }
                    List<Preference> importedPrefs = data.getPolicy().getPreferences().getServerPreferences().getPreferences();
                    for (Preference prf : importedPrefs) {
                        if (prf.getName().equals("report_task_id")) {
                            newScanId = prf.getValue();
                        }
                    }
                    scan.setReportId(newScanId);
                    ReportHost first = report.getReportHost().get(0);
                    for (Tag tag : first.getHostProperties().getTags()) {
                        if (tag.getName().equals("HOST_START")) {
                            String scanDate = tag.getValue();
                            //Rapordaki tarih formatına uygun olarak alıp tarama tarihi olarak verdik.
                            //PostgreSQL için date formatı (timestamp with time zone)
                            DateFormat format = new SimpleDateFormat("EEE MMM d HH:mm:ss yyyy", Locale.ENGLISH);
                            Date date = format.parse(scanDate);
                            scan.setScanDate(date);
                        }
                    }
                    results = nessusService.parseNessusClientDataToScanAssetList(data, customerId, scan);
                    break;
                }
                case BURP: {
                    scan.setSource(Source.BURP);
                    ImportObject importObject = (ImportObject) request.getSession().getAttribute("importObject");
                    Issues data = importObject.getBurp();
                    String scanDate = data.getExportTime();
                    DateFormat format = new SimpleDateFormat("EEE MMM d HH:mm:ss z yyyy", Locale.ENGLISH);
                    Date date = format.parse(scanDate);
                    scan.setScanDate(date);
                    String scanName = "BURP_" + date;
                    if (newScanName != null && !"".equals(newScanName)) {
                        scan.setName(newScanName);
                    } else {
                        scan.setName(scanName);
                    }
                    List<String> uniqueIpList = new LinkedList<>();
                    String ip;
                    for (Issue issue : data.getIssue()) {
                        ip = issue.getHost().getIp();
                        if (!uniqueIpList.contains(ip)) {
                            uniqueIpList.add(ip);
                        }
                    }
                    results = parseBurpDataToScanAssetList(data, uniqueIpList);
                    break;
                }
                case QUALYS: {
                    scan.setSource(Source.QUALYS);
                    ImportObject importObject = (ImportObject) request.getSession().getAttribute("importObject");
                    Scan data = importObject.getQualys();
                    String newScanId = "";
                    scan.setReportId(newScanId);
                    String scanDate = "";
                    boolean dateSet = false, nameSet = false;
                    for (Key key : data.getHeader().getKeys()) {
                        if (key.getKey().equals("DATE")) {
                            scanDate = key.getValue();
                            //Rapordaki tarih formatına uygun olarak alıp tarama tarihi olarak verdik.
                            //PostgreSQL için date formatı (timestamp with time zone)
                            // QUALYS: 2017-06-03T17:01:16Z
                            DateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.ENGLISH);
                            Date date = format.parse(scanDate);
                            scan.setScanDate(date);
                            dateSet = true;
                        }
                        if (key.getKey().equals("TITLE")) {
                            scan.setName(key.getValue());
                            nameSet = true;
                        }
                        if (newScanName != null && !"".equals(newScanName)) {
                            scan.setName(newScanName);
                        }
                        if (dateSet && nameSet) {
                            break;
                        }
                    }
                    results = parseQualysDataToScanAssetList(data);
                    break;
                }
                case APPSCAN: {
                    scan.setSource(Source.APPSCAN);
                    String newScanId = "";
                    ImportObject importObject = (ImportObject) request.getSession().getAttribute("importObject");
                    AppScanReport data = importObject.getAppScan();
                    if (newScanName != null && !"".equals(newScanName)) {
                        scan.setName(newScanName);
                    } else {
                        scan.setName(data.getScanInfo().getName());
                    }
                    scan.setReportId(newScanId);
                    DateFormat format = new SimpleDateFormat("MM/dd/yyyy hh:mm:ss a", Locale.ENGLISH);
                    Date date = format.parse(data.getScanInfo().getScanDate());
                    scan.setScanDate(date);
                    results = appScanService.parseAppScanDataToScanAssetList(data, customerId, scan);
                    break;
                }
                case FORTIFY: {
                    scan.setSource(Source.FORTIFY);
                    String newScanId = "";
                    ImportObject importObject = (ImportObject) request.getSession().getAttribute("importObject");
                    FortifyReport data = importObject.getFortify();
                    if (newScanName != null && !"".equals(newScanName)) {
                        scan.setName(newScanName);
                    } else {
                        scan.setName(data.getBuild().getId() + "_Fortify");
                    }
                    newScanId = data.getReportId();
                    scan.setReportId(newScanId);
                    DateFormat format = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss", Locale.ENGLISH);
                    Date date = format.parse(data.getCreatedTS().getDate() + " " + data.getCreatedTS().getTime());
                    scan.setScanDate(date);
                    results = (List<ScanAsset>) fortifyService.parseFortifyDataToScanAssetList(data, customerId, scan, true).get(0);
                    break;
                }
                case WEBINSPECT: {
                    scan.setSource(Source.WEBINSPECT);
                    String newScanId = "";
                    ImportObject importObject = (ImportObject) request.getSession().getAttribute("importObject");
                    WebinspectReport data = importObject.getWebinspect();
                    if (newScanName != null && !"".equals(newScanName)) {
                        scan.setName(newScanName);
                    } else {
                        scan.setName(data.getAppVersion() + "_Webinspect");
                    }
                    newScanId = BizzyUtil.generateGUID();
                    scan.setReportId(newScanId);

                    WebinspectInfo data2 = importObject.getWebinspectInfo();

                    DateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSSSSSXXX", Locale.ENGLISH);
                    Date date = format.parse(data2.getInfo().getDate());
                    scan.setScanDate(date);
                    results = webinspectService.parseWebinspectDataToScanAssetList(data, data2, customerId, scan);
                    break;
                }
                case ARACHNI: {
                    scan.setSource(Source.ARACHNI);
                    ImportObject importObject = (ImportObject) request.getSession().getAttribute("importObject");
                    ArachniReport data = importObject.getArachni();
                    // ARACHNI:   2019-01-22T11:40:27+03:00
                    String scanDate = data.getFinishDatetime();
                    //Rapordaki tarih formatına uygun olarak alıp tarama tarihi olarak verdik.
                    //PostgreSQL için date formatı (timestamp with time zone)
                    DateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssXXX", Locale.ENGLISH);
                    Date date = format.parse(scanDate);
                    scan.setScanDate(date);
                    String scanName = "ARACHNI_" + date;
                    if (newScanName != null && !"".equals(newScanName)) {
                        scan.setName(newScanName);
                    } else {
                        scan.setName(scanName);
                    }
                    results = arachniService.parseArachniDataToScanAssetList(data, customerId, scan);
                    break;
                }
                case CHECKMARX: {
                    scan.setSource(Source.CHECKMARX);
                    ImportObject importObject = (ImportObject) request.getSession().getAttribute("importObject");
                    CheckmarxReport data = importObject.getCheckmarxReport();
                    // Checkmarx:   Friday, November 22, 2019 3:32:24 PM
                    String scanDate = data.getReportCreationTime();
                    //Rapordaki tarih formatına uygun olarak alıp tarama tarihi olarak verdik.
                    //PostgreSQL için date formatı (timestamp with time zone)
                    DateFormat format = new SimpleDateFormat("EEEEE, MMMMM d, yyyy HH:mm:ss aaa", Locale.ENGLISH);
                    Date date = format.parse(scanDate);
                    scan.setScanDate(date);
                    String scanName = "CHECKMARX_" + date;
                    if (newScanName != null && !"".equals(newScanName)) {
                        scan.setName(newScanName);
                    } else {
                        scan.setName(scanName);
                    }
                    results = (List<ScanAsset>) checkmarxService.parseCheckmarxDataToScanAssetList(data, customerId, scan, true).get(0);
                    break;
                }
                case WAPITI: {
                    scan.setSource(Source.WAPITI);
                    ImportObject importObject = (ImportObject) request.getSession().getAttribute("importObject");
                    WapitiReport data = importObject.getWapiti();
                    String scanDate = null;
                    String ip = null;
                    // WAPITI: Wed, 30 Jan 2019 13:36:47 +0000
                    for (WapitiInfo winfo : data.getInfo()) {
                        if (winfo.getName().equals("dateOfScan")) {
                            scanDate = winfo.getValue();
                        }
                        if (winfo.getName().equals("target")) {
                            ip = winfo.getValue();
                        }
                    }       //Rapordaki tarih formatına uygun olarak alıp tarama tarihi olarak verdik.
                    //PostgreSQL için date formatı (timestamp with time zone)
                    DateFormat format = new SimpleDateFormat("EEE, d MMM yyyy HH:mm:ss Z", Locale.ENGLISH);
                    Date date = format.parse(scanDate);
                    scan.setScanDate(date);
                    scan.setCompletionDate(date);
                    String scanName = "WAPITI_" + date;
                    if (newScanName != null && !"".equals(newScanName)) {
                        scan.setName(newScanName);
                    } else {
                        scan.setName(scanName);
                    }
                    List<String> uniqueIpList = new LinkedList<>();
                    uniqueIpList.add(ip);
                    results = parseWapitiDataToScanAssetList(data, uniqueIpList);
                    break;
                }
                case NETSPARKER: {
                    scan.setSource(Source.NETSPARKER);
                    ImportObject importObject = (ImportObject) request.getSession().getAttribute("importObject");
                    NetsparkerReport data = importObject.getNetsparker();
                    // NETSPARKER DATE FORMAT : 2/5/2019 9:42:13 AM
                    String scanDate = data.getScanDate();
                    //Rapordaki tarih formatına uygun olarak alıp tarama tarihi olarak verdik.
                    //PostgreSQL için date formatı (timestamp with time zone)
                    Date date;
                    try {
                        DateFormat format = new SimpleDateFormat("M/d/yyyy H:m:s a", Locale.ENGLISH);
                        date = format.parse(scanDate);
                    } catch (ParseException ex) {
                        logger.log(LogLevel.WARN, scanDate + "tarihi M/d/yyyy H:m:s patternden farklı!", ex);
                        DateFormat format = new SimpleDateFormat("M/d/yyyy H:m:s", Locale.ENGLISH);
                        date = format.parse(scanDate);
                    }
                    scan.setScanDate(date);
                    String scanName = "NETSPARKER_" + date;
                    if (newScanName != null && !"".equals(newScanName)) {
                        scan.setName(newScanName);
                    } else {
                        scan.setName(scanName);
                    }
                    results = netsparkerService.parseNetsparkerDataToScanAssetList(data, customerId, scan);
                    break;
                }
                case NETSPARKERENT: {
                    scan.setSource(Source.NETSPARKERENT);
                    ImportObject importObject = (ImportObject) request.getSession().getAttribute("importObject");
                    NetsparkerEntReport data = importObject.getNetsparkerEnt();
                    // NETSPARKER DATE FORMAT : 2/5/2019 9:42:13 AM
                    String scanDate = data.getTarget().getInitiated();
                    //Rapordaki tarih formatına uygun olarak alıp tarama tarihi olarak verdik.
                    //PostgreSQL için date formatı (timestamp with time zone)
                    Date date;
                    try {
                        DateFormat format = new SimpleDateFormat("dd/MM/yyyy HH:mm a", Locale.ENGLISH);
                        date = format.parse(scanDate);
                    } catch (ParseException ex) {
                        logger.log(LogLevel.WARN, scanDate + "tarihi M/d/yyyy H:m:s patternden farklı!", ex);
                        DateFormat format = new SimpleDateFormat("dd/MM/yyyy HH:mm", Locale.ENGLISH);
                        date = format.parse(scanDate);
                    }
                    scan.setScanDate(date);
                    String scanName = "NETSPARKER_" + date;
                    if (newScanName != null && !"".equals(newScanName)) {
                        scan.setName(newScanName);
                    } else {
                        scan.setName(scanName);
                    }
                    results = netsparkerService.parseNetsparkerEntDataToScanAssetList(data, customerId, scan);
                    break;
                }
                case ACUNETIX: {
                    scan.setSource(Source.ACUNETIX);
                    ImportObject importObject = (ImportObject) request.getSession().getAttribute("importObject");
                    AcunetixReport data = importObject.getAcunetix();
                    // ACUNETIX DATE FORMAT : 20/02/2019, 09:51:11
                    String scanDate = data.getScanDate();
                    //Rapordaki tarih formatına uygun olarak alıp tarama tarihi olarak verdik.
                    //PostgreSQL için date formatı (timestamp with time zone)
                    Date date;
                    try {
                        DateFormat format = new SimpleDateFormat("dd/MM/yyyy, HH:mm:ss");
                        date = format.parse(scanDate);
                    } catch (Exception e) {
                        date = new Date();
                        logger.log(LogLevel.ERROR, "Acunetix import tarih parse etme problemi");
                    }
                    scan.setScanDate(date);
                    String scanName = "ACUNETIX_" + date;
                    if (newScanName != null && !"".equals(newScanName)) {
                        scan.setName(newScanName);
                    } else {
                        scan.setName(scanName);
                    }
                    results = acunetixService.parseAcunetixDataToScanAssetList(data, customerId, scan);
                    break;
                }
                case PENTEST:
                    String jsonString = "";
                    jsonString = (String) request.getSession().getAttribute("finalPentest");
                    String wellFormedJson = JsonSanitizer.sanitize(jsonString);
                    ScanAsset[] scanAssets = gson.fromJson(wellFormedJson, ScanAsset[].class);
                    results = Arrays.asList(scanAssets);
                    if (pentestScanId.equals("none")) {
                        //Yeni bir pentest taraması oluşturulacaksa
                        scan.setSource(Source.PENTEST);
                        if (newScanName != null && !"".equals(newScanName)) {
                            scan.setName(newScanName);
                        } else {
                            scan.setName("Imported Pentest Scan");
                        }
                        scan.setScanDate(new Date());
                    } else {
                        PentestScan existingPentestScan = pentestService.getScanById(pentestScanId);
                        // Mevcut pentest taraması kapsamına eklenecekse
                        filterImportResults(results, filteredResults, level, customerId, assetGroup, null, scan, Source.PENTEST);
                        for (ScanAsset result : filteredResults) {
                            List<ScanVulnerability> list = result.getScanVulnerabilityList();
                            String ip = result.getScannedIp();
                            Asset asset = customerService.getAssetByIp(ip, customerId);
                            if (asset == null) {
                                // eklenen taramada yeni varlık varsa
                                Asset newAsset = new Asset();
                                newAsset.setIp(ip);
                                newAsset.setCustomerId(customerId);
                                String newAssetId = assetService.saveAsset(newAsset);
                                Asset temp = assetService.getAssetByIdandCustomerId(newAssetId, customerId);
                                List<Asset> existingAssets = new LinkedList<>();
                                existingAssets.add(temp);
                                customerService.addAssetToScan(existingPentestScan.getScanId(), existingAssets, "NULL");
                                String newScanAssetId = pentestService.getScanAssetIdByIp(temp.getIp(), existingPentestScan.getScanId());
                                for (ScanVulnerability item : list) {
                                    item.getVulnerability().setKbItemId(null);
                                    Category cat = new Category();
                                    item.getVulnerability().setCategory(cat);
                                    String sv = customerService.saveVulnerabilityToExistingScan(item, newScanAssetId, customerId);
                                    if (item.getVulnerability().getFileList() != null) {
                                        if (!item.getVulnerability().getFileList().isEmpty()) {
                                            List<tr.biznet.bizzy.service.file.entity.File> listFiles = item.getVulnerability().getFileList();
                                            for (tr.biznet.bizzy.service.file.entity.File file : listFiles) {
                                                file.setFileTableId(item.getVulnerability().getVulnerabilityId());
                                                file.setCustomerId(customerId);
                                            }
                                            List<String> fileIds = fileService.saveFileList(listFiles);
                                            fileService.updateFileTableIdByFileIdAndCustomerIdList(customerId, fileIds, item.getVulnerability().getVulnerabilityId());
                                        }
                                    }
                                    if (item.getProofFileList() != null) {
                                        if (!item.getProofFileList().isEmpty()) {
                                            List<ProofFile> listProofs = item.getProofFileList();
                                            for (ProofFile file : listProofs) {
                                                file.setFileTableId(item.getVulnerability().getVulnerabilityId());
                                                file.setCustomerId(customerId);
                                            }
                                            List<String> fileIds = fileService.saveProofFileList(listProofs);
                                            fileService.updateProofFileTableIdByFileIdAndCustomerIdList(customerId, fileIds, sv);
                                        }
                                    }
                                    if (item.getImages() != null) {
                                        if (!item.getImages().isEmpty()) {
                                            List<ImageFile> listImages = item.getImages();
                                            for (ImageFile file : listImages) {
                                                file.setFileTableId(item.getScanVulnerabilityId());
                                                file.setCustomerId(customerId);
                                            }
                                            List<String> fileIds = fileService.saveImageFileList(listImages);
                                            fileService.updateImageFileTableIdByFileIdAndCustomerIdList(customerId, fileIds, sv);
                                        }
                                    }
                                    if (item.getWebApps() != null) {
                                        if (!item.getWebApps().isEmpty()) {
                                            for (WebApp webApp : item.getWebApps()) {
                                                String id = customerService.saveWebApp(webApp);
                                                customerService.updateWebAppScanVulnerabilityIdByWebAppId(id, sv);
                                            }
                                        }
                                    }
                                }
                            } else {
                                // eklenen taramadaki varlık mevcutsa
                                String scanAssetId = pentestService.getScanAssetIdByIp(asset.getIp(), existingPentestScan.getScanId());
                                if (scanAssetId == null) {
                                    //varlık mevcut fakat kapsamda değilse
                                    List<Asset> existingAssets = new LinkedList<>();
                                    existingAssets.add(asset);
                                    customerService.addAssetToScan(existingPentestScan.getScanId(), existingAssets, "NULL");
                                    String newScanAssetId = pentestService.getScanAssetIdByIp(asset.getIp(), existingPentestScan.getScanId());
                                    for (ScanVulnerability item : list) {
                                        item.getVulnerability().setKbItemId(null);
                                        Category cat = new Category();
                                        item.getVulnerability().setCategory(cat);
                                        String sv = customerService.saveVulnerabilityToExistingScan(item, newScanAssetId, customerId);
                                        if (item.getVulnerability().getFileList() != null) {
                                            if (!item.getVulnerability().getFileList().isEmpty()) {
                                                List<tr.biznet.bizzy.service.file.entity.File> listFiles = item.getVulnerability().getFileList();
                                                for (tr.biznet.bizzy.service.file.entity.File file : listFiles) {
                                                    file.setFileTableId(item.getVulnerability().getVulnerabilityId());
                                                    file.setCustomerId(customerId);
                                                }
                                                List<String> fileIds = fileService.saveFileList(listFiles);
                                                fileService.updateFileTableIdByFileIdAndCustomerIdList(customerId, fileIds, item.getVulnerability().getVulnerabilityId());
                                            }
                                        }
                                        if (item.getProofFileList() != null) {
                                            if (!item.getProofFileList().isEmpty()) {
                                                List<ProofFile> listProofs = item.getProofFileList();
                                                for (ProofFile file : listProofs) {
                                                    file.setFileTableId(item.getVulnerability().getVulnerabilityId());
                                                    file.setCustomerId(customerId);
                                                }
                                                List<String> fileIds = fileService.saveProofFileList(listProofs);
                                                fileService.updateProofFileTableIdByFileIdAndCustomerIdList(customerId, fileIds, sv);
                                            }
                                        }
                                        if (item.getImages() != null) {
                                            if (!item.getImages().isEmpty()) {
                                                List<ImageFile> listImages = item.getImages();
                                                for (ImageFile file : listImages) {
                                                    file.setFileTableId(item.getScanVulnerabilityId());
                                                    file.setCustomerId(customerId);
                                                }
                                                List<String> fileIds = fileService.saveImageFileList(listImages);
                                                fileService.updateImageFileTableIdByFileIdAndCustomerIdList(customerId, fileIds, sv);
                                            }
                                        }
                                        if (item.getWebApps() != null) {
                                            if (!item.getWebApps().isEmpty()) {
                                                for (WebApp webApp : item.getWebApps()) {
                                                    String id = customerService.saveWebApp(webApp);
                                                    customerService.updateWebAppScanVulnerabilityIdByWebAppId(id, sv);
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    //varlık mevcut ve kapsamda ise
                                    for (ScanVulnerability item : list) {
                                        item.getVulnerability().setKbItemId(null);
                                        Category cat = new Category();
                                        item.getVulnerability().setCategory(cat);
                                        String sv = customerService.saveVulnerabilityToExistingScan(item, scanAssetId, customerId);
                                        if (item.getVulnerability().getFileList() != null) {
                                            if (!item.getVulnerability().getFileList().isEmpty()) {
                                                List<tr.biznet.bizzy.service.file.entity.File> listFiles = item.getVulnerability().getFileList();
                                                for (tr.biznet.bizzy.service.file.entity.File file : listFiles) {
                                                    file.setFileTableId(item.getVulnerability().getVulnerabilityId());
                                                    file.setCustomerId(customerId);
                                                }
                                                List<String> fileIds = fileService.saveFileList(listFiles);
                                                fileService.updateFileTableIdByFileIdAndCustomerIdList(customerId, fileIds, item.getVulnerability().getVulnerabilityId());
                                            }
                                        }
                                        if (item.getProofFileList() != null) {
                                            if (!item.getProofFileList().isEmpty()) {
                                                List<ProofFile> listProofs = item.getProofFileList();
                                                for (ProofFile file : listProofs) {
                                                    file.setFileTableId(item.getVulnerability().getVulnerabilityId());
                                                    file.setCustomerId(customerId);
                                                }
                                                List<String> fileIds = fileService.saveProofFileList(listProofs);
                                                fileService.updateProofFileTableIdByFileIdAndCustomerIdList(customerId, fileIds, sv);
                                            }
                                        }
                                        if (item.getImages() != null) {
                                            if (!item.getImages().isEmpty()) {
                                                List<ImageFile> listImages = item.getImages();
                                                for (ImageFile file : listImages) {
                                                    file.setFileTableId(item.getScanVulnerabilityId());
                                                    file.setCustomerId(customerId);
                                                }
                                                List<String> fileIds = fileService.saveImageFileList(listImages);
                                                fileService.updateImageFileTableIdByFileIdAndCustomerIdList(customerId, fileIds, sv);
                                            }
                                        }
                                        if (item.getWebApps() != null) {
                                            if (!item.getWebApps().isEmpty()) {
                                                for (WebApp webApp : item.getWebApps()) {
                                                    String id = customerService.saveWebApp(webApp);
                                                    customerService.updateWebAppScanVulnerabilityIdByWebAppId(id, sv);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    break;
                case EXCEL: {
                    scan.setSource(Source.EXCEL);
                    scan.setScanDate(new Date());
                    String scanName = "EXCEL_" + new Date();
                    if (newScanName != null && !"".equals(newScanName)) {
                        scan.setName(newScanName);
                    } else {
                        scan.setName(scanName);
                    }
                    results = (List<ScanAsset>) request.getSession().getAttribute("finalExcel");
                    break;
                }
                default:
                    break;
                case OWAPS:{
                    scan.setSource(Source.OWAPS);
                    ImportObject importObject = (ImportObject) request.getSession().getAttribute("importObject");
                    OwapsReport data = importObject.getOwapsReport();
                    // OWAPS DATE FORMAT : 20/02/2019, 09:51:11
                    String scanDate = data.getScanDate();
                    //Rapordaki tarih formatına uygun olarak alıp tarama tarihi olarak verdik.
                    //PostgreSQL için date formatı (timestamp with time zone)
                    Date date;
                    try {
                        DateFormat format = new SimpleDateFormat("dd/MM/yyyy, HH:mm:ss");
                        date = format.parse(scanDate);
                    } catch (Exception e) {
                        date = new Date();
                        logger.log(LogLevel.ERROR, "OWAPS import tarih parse etme problemi");
                    }
                    scan.setScanDate(date);
                    String scanName = "OWAPS" + date;
                    if (newScanName != null && !"".equals(newScanName)) {
                        scan.setName(newScanName);
                    } else {
                        scan.setName(scanName);
                    }
                    results = owapsService.parseOwapsDataToScanAssetList(data, customerId, scan);
                    break;
                }
            }

            if (importSource == Source.PENTEST && !pentestScanId.equals("none")) {
                return new ModelAndView("redirect:" + "listScans.htm");
            }

            if (!importSource.equals(Source.APPSCAN)) {
                // Appscanda istisnalar olduğu için fonksiyonu ayrı
                filterImportResults(results, filteredResults, level, customerId, assetGroup, null, scan, importSource);
            } else {
                ImportObject temp = (ImportObject) request.getSession().getAttribute("importObject");
                filterAppscanResults(results, filteredResults, level, customerId, assetGroup, null, scan, temp.getAppScan());
            }
            // filtreye göre filteredResults listesine sonuçlar doldurulur.

            scan.setScanAssets(filteredResults);
            if (matches != null) {
                aggregationOnImport(filteredResults, matches);
            }

            pentestService.saveScan(scan); //Tarama ve taranan asset bilgileri veritabanına kaydedilir.
            importService.saveAndSetActivenessScanImportResults(locale, scan, filteredResults, customerId, level, user);//Tüm tarama sonuçlarının kaydedilir.
            
            request.getSession().setAttribute("importObject", null);
            // Import tamamlandıktan sonra session'da tutulan import içeriği ve diğer bilgiler temizlenir.

        } catch (Exception ex) {

            logger.log(LogLevel.ERROR, "Import kaydedilemedi!", ex);
            return new ModelAndView("importError" + "error");

        }
        return new ModelAndView("redirect:" + "listScans.htm");
    }
          
    @RequestMapping(value = "clearImportData.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public void clearImportData(HttpServletRequest request, HttpServletResponse response) {
        request.getSession().setAttribute("importObject", null);
        // import süreci başlayıp daha sonra iptal edilirse  
        //session'da tutulan import içeriği ve diğer bilgiler temizlenir
    }

    public List<ScanAsset> parseBurpDataToScanAssetList(Issues data, List<String> uniqueIpList) {
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);

        List<ScanAsset> assetList = new LinkedList<>(); //Tüm verinin yer aldığı list

        for (String uniqueIp : uniqueIpList) {
            ScanAsset scanAsset = new ScanAsset();
            List<ScanVulnerability> vulnList = new LinkedList();

            Asset asset = customerService.getAssetByIp(uniqueIp, customerId);
            //Asset zaten kayıtlı
            if (asset != null) {
                scanAsset.setAssetId(asset.getAssetId());
                scanAsset.setScannedIp(uniqueIp);
            } else {
                scanAsset.setScannedIp(uniqueIp);
            }
            HashMap<String, ArrayList<WebApp>> map = new HashMap<>();
            for (Issue issue : data.getIssue()) {
                if (map.containsKey(issue.getHost().getHostname() + issue.getName())) {
                    WebApp webapp = new WebApp();
                    webapp.setApplication(issue.getPath());
                    webapp.setDescription(issue.getIssueBackground());
                    webapp.setParameter(issue.getLocation());
                    List<RequestResponse> rr = issue.getRequestresponse();
                    if (rr != null && !rr.isEmpty()) {
                        for (RequestResponse reqres : rr) {
                            if (webapp.getResponse() != null) {
                                webapp.setResponse(webapp.getResponse() + reqres.getResponse() + " |");
                            } else {
                                webapp.setResponse(reqres.getResponse() + " |");
                            }
                            if (webapp.getRequest() != null) {
                                webapp.setRequest(webapp.getRequest() + reqres.getRequest() + " |");
                            } else {
                                webapp.setRequest(reqres.getRequest() + " |");
                            }
                        }
                    }
                    map.get(issue.getHost().getHostname() + issue.getName()).add(webapp);
                } else {
                    ArrayList list = new ArrayList<>();
                    map.put(issue.getHost().getHostname() + issue.getName(), list);
                }
            }
            HashMap<String, Integer> issueCount = new HashMap<>();
            for (Issue issue : data.getIssue()) {
                if (!issueCount.containsKey(issue.getHost().getHostname() + issue.getName())) {
                    issueCount.put(issue.getHost().getHostname() + issue.getName(), 1);
                    if (issue.getHost().getIp().equals(uniqueIp)) {

                        ScanVulnerability scanVulnerability = new ScanVulnerability();
                        Vulnerability vuln = new Vulnerability();

                        //port
                        vuln.setVulnNumber(issue.getSerialNumber());
                        vuln.setName(issue.getName());

                        String issueDescription = "";

                        if (issue.getIssueDetail() != null) {
                            issueDescription = issue.getIssueDetail() + " ";
                        }
                        if (issue.getIssueBackground() != null) {
                            issueDescription += issue.getIssueBackground();
                        }
                        vuln.setDescription(issueDescription);
                        vuln.setSource(Source.BURP.toString());
                        //vuln.setDiagnosis();

                        //vuln.setResult(item.getOutput());
                        String solution = "";

                        if (issue.getRemediationDetail() != null) {
                            solution = issue.getRemediationDetail() + " ";
                        }
                        if (issue.getRemediationBackground() != null) {
                            solution += issue.getRemediationBackground();
                        }
                        vuln.setSolution(solution);

                        if (!BizzyUtil.isEmpty(issue.getSeverity())) {
                            switch (issue.getSeverity()) {
                                case "Low":
                                    vuln.setRiskLevel(1);
                                    break;
                                case "Medium":
                                    vuln.setRiskLevel(2);
                                    break;
                                case "High":
                                    vuln.setRiskLevel(3);
                                    break;
                                case "Information":
                                    vuln.setRiskLevel(0);
                                    break;
                                default:
                                    break;
                            }
                        }

                        Category category = new Category();
                        category.setName(issue.getType());
                        vuln.setCategory(category);
                        VirtualHost host = new VirtualHost();
                        host.setName(issue.getHost().getHostname());
                        scanVulnerability.setHost(host);
                        scanVulnerability.setVulnerability(vuln);
                        scanVulnerability.setWebApps(map.get(issue.getHost().getHostname() + issue.getName()));
                        //scanVulnerability.setResult();
                        //   scanVulnerability.setSource(Source.NESSUS);
                        scanVulnerability.setSource(Source.BURP.toString());

                        scanVulnerability.setActive(true);//Her yeni zafiyet active olarak belirlenir. Eski zafiyetlerin durumuna göre controller'da bu değişebilir.

                        vulnList.add(scanVulnerability);
                    }
                }
            }
            scanAsset.setScanVulnerabilityList(vulnList);
            assetList.add(scanAsset);

        }

        return assetList;
    }
    
    
     public List<ScanAsset> parseBurpDataToScanAssetListSimpleModify(Issues data, List<String> uniqueIpList) {
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);

        List<ScanAsset> assetList = new LinkedList<>(); 

        for (String uniqueIp : uniqueIpList) {
            ScanAsset scanAsset = new ScanAsset();
            List<ScanVulnerability> vulnList = new LinkedList();

            Asset asset = customerService.getAssetByIp(uniqueIp, customerId);
            if (asset != null) {
                scanAsset.setAssetId(asset.getAssetId());
            } else {
                scanAsset.setScannedIp(uniqueIp);
            }
            
         
            HashMap<String, Integer> issueCount = new HashMap<>();
            for (Issue issue : data.getIssue()) {
                if (!issueCount.containsKey(issue.getHost().getHostname() + issue.getName())) {
                    issueCount.put(issue.getHost().getHostname() + issue.getName(), 1);
                    if (issue.getHost().getIp().equals(uniqueIp)) {

                        ScanVulnerability scanVulnerability = new ScanVulnerability();
                        Vulnerability vuln = new Vulnerability();
                        vuln.setVulnNumber(issue.getSerialNumber());
                        vuln.setName(issue.getName());


                        if (!BizzyUtil.isEmpty(issue.getSeverity())) {
                            switch (issue.getSeverity()) {
                                case "Low":
                                    vuln.setRiskLevel(1);
                                    break;
                                case "Medium":
                                    vuln.setRiskLevel(2);
                                    break;
                                case "High":
                                    vuln.setRiskLevel(3);
                                    break;
                                case "Information":
                                    vuln.setRiskLevel(0);
                                    break;
                                default:
                                    break;
                            }
                        }                  
                        Category category = new Category();
                        category.setName(issue.getType());
                        vuln.setCategory(category);
                        scanVulnerability.setVulnerability(vuln);
                        scanVulnerability.setSource(Source.BURP.toString());
                        scanVulnerability.setActive(true);
                        vulnList.add(scanVulnerability);
                    }
                }
            }
            scanAsset.setScanVulnerabilityList(vulnList);
            assetList.add(scanAsset);

        }

        return assetList;
    }

    public List<ScanAsset> parseWapitiDataToScanAssetList(WapitiReport data, List<String> uniqueIpList) {
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);

        List<ScanAsset> assetList = new LinkedList<>(); //Tüm verinin yer aldığı list

        for (String uniqueIp : uniqueIpList) {
            ScanAsset scanAsset = new ScanAsset();
            List<ScanVulnerability> vulnList = new LinkedList();

            Asset asset = customerService.getAssetByIp(uniqueIp, customerId);
            //Asset zaten kayıtlı
            if (asset != null) {
                scanAsset.setAssetId(asset.getAssetId());
                scanAsset.setScannedIp(uniqueIp);
            } else {
                scanAsset.setScannedIp(uniqueIp);
            }
            HashMap<String, Integer> issueCount = new HashMap<>();
            for (WapitiVulnerability vulnerability : data.getVulnerabilities()) {
                HashMap<String, ArrayList<WebApp>> map = new HashMap<>();
                List<WapitiReference> references = vulnerability.getReferences();
                String referenceText = "";
                for (WapitiReference reference : references) {
                    referenceText += reference.getUrl() + " \n";
                }
                if (!vulnerability.getEntries().isEmpty()) {
                    for (WapitiEntry entry : vulnerability.getEntries()) {

                        WebApp webapp = new WebApp();
                        webapp.setApplication(entry.getPath());
                        webapp.setDescription(entry.getInfo());
                        webapp.setParameter(entry.getParameter());
                        webapp.setRequest(entry.getHttp_request());
                        String replacedInfo = entry.getInfo().replace(" " + entry.getParameter(), "");
                        if (map.containsKey(replacedInfo)) {
                            map.get(replacedInfo).add(webapp);
                        } else {
                            ArrayList<WebApp> list = new ArrayList<>();
                            list.add(webapp);
                            map.put(replacedInfo, list);
                            issueCount.put(replacedInfo, 1);

                            ScanVulnerability scanVulnerability = new ScanVulnerability();
                            Vulnerability vuln = new Vulnerability();

                            String url = "";
                            for (WapitiInfo element : data.getInfo()) {
                                if (element.getName().equals("target")) {
                                    url = element.getValue();
                                }
                            }
                            Port port = new Port();
                            if (url.contains("https:")) {
                                port.setPortNumber(443);
                                port.setProtocol("TCP");
                                port.setService("https");
                            } else if (url.contains("http:")) {
                                port.setPortNumber(80);
                                port.setProtocol("TCP");
                                port.setService("http");
                            }
                            scanVulnerability.setPort(port);
                            //TODO
                            vuln.setReferences(referenceText);
                            pentestService.setOwaspCategoryByReference(referenceText, vuln);
                            vuln.setVulnNumber(String.valueOf(replacedInfo.hashCode()));
                            vuln.setName(vulnerability.getName());

                            vuln.setDescription(vulnerability.getDescription());
                            vuln.setSource(Source.WAPITI.toString());

                            vuln.setSolution(vulnerability.getSolution());

                            switch (entry.getLevel()) {
                                case 1:
                                    vuln.setRiskLevel(1);
                                    break;
                                case 2:
                                    vuln.setRiskLevel(3);
                                    break;
                                case 3:
                                    vuln.setRiskLevel(5);
                                    break;
                                default:
                                    break;
                            }

                            /*Category category = new Category();
                            category.setName(issue.getType());
                            vuln.setCategory(category);
                            VirtualHost host = new VirtualHost();
                            host.setName(data.getInfo());
                            scanVulnerability.setHost(host);*/
                            scanVulnerability.setVulnerability(vuln);
                            scanVulnerability.setWebApps(map.get(replacedInfo));
                            scanVulnerability.setSource(Source.WAPITI.toString());

                            scanVulnerability.setActive(true);//Her yeni zafiyet active olarak belirlenir. Eski zafiyetlerin durumuna göre controller'da bu değişebilir.

                            vulnList.add(scanVulnerability);
                        }
                    }
                }
            }

            scanAsset.setScanVulnerabilityList(vulnList);
            assetList.add(scanAsset);

        }

        return assetList;
    }
    
    
    public List<ScanAsset> parseWapitiDataToScanAssetListSimpleModify(WapitiReport data, List<String> uniqueIpList) {
   
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);

        List<ScanAsset> assetList = new LinkedList<>(); 

        for (String uniqueIp : uniqueIpList) {
            ScanAsset scanAsset = new ScanAsset();
            List<ScanVulnerability> vulnList = new LinkedList();

            Asset asset = customerService.getAssetByIp(uniqueIp, customerId);

            if (asset != null) {
                scanAsset.setAssetId(asset.getAssetId());
            } else {
                scanAsset.setScannedIp(uniqueIp);
            }
            HashMap<String, Integer> issueCount = new HashMap<>();
            for (WapitiVulnerability vulnerability : data.getVulnerabilities()) {
                HashMap<String, ArrayList<WebApp>> map = new HashMap<>();
                List<WapitiReference> references = vulnerability.getReferences();
              
                if (!vulnerability.getEntries().isEmpty()) {
                    for (WapitiEntry entry : vulnerability.getEntries()) {

                       
                        String replacedInfo = entry.getInfo().replace(" " + entry.getParameter(), "");
                        if (map.containsKey(replacedInfo)) {
                            
                        } else {
                            ArrayList<WebApp> list = new ArrayList<>();
                            map.put(replacedInfo, list);
                            issueCount.put(replacedInfo, 1);

                            ScanVulnerability scanVulnerability = new ScanVulnerability();
                            Vulnerability vuln = new Vulnerability();
       
                            vuln.setVulnNumber(String.valueOf(replacedInfo.hashCode()));
                            vuln.setName(vulnerability.getName());
                            vuln.setSource(Source.WAPITI.toString());

                            switch (entry.getLevel()) {
                                case 1:
                                    vuln.setRiskLevel(1);
                                    break;
                                case 2:
                                    vuln.setRiskLevel(3);
                                    break;
                                case 3:
                                    vuln.setRiskLevel(5);
                                    break;
                                default:
                                    break;
                            }
                            scanVulnerability.setVulnerability(vuln);
                            scanVulnerability.setSource(Source.WAPITI.toString());
                            scanVulnerability.setActive(true);
                            vulnList.add(scanVulnerability);
                        }
                    }
                }
            }

            scanAsset.setScanVulnerabilityList(vulnList);
            assetList.add(scanAsset);
        }
        return assetList;
    }

    public List<ScanAsset> parseQualysDataToScanAssetList(Scan data) {

        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);

        List<ScanAsset> assetList = new LinkedList<>(); //Tüm verinin yer aldığı list

        for (Ip ip : data.getIps()) {

            ScanAsset scanAsset = new ScanAsset();
            List<ScanVulnerability> vulnList = new LinkedList();

            Asset asset = customerService.getAssetByIp(ip.getValue(), customerId);

            if (asset != null) {
                scanAsset.setAssetId(asset.getAssetId());
                scanAsset.setScannedIp(ip.getValue());
            } else {
                scanAsset.setScannedIp(ip.getValue());
            }
            //Asset zaten kayıtlı

            //VULNS
            if (data.getImportVulnTypes().contains("Confirmed") && ip.getVulns() != null) {
                for (tr.biznet.bizzy.plugins.qualys.domain.report.fetch.Category cat : ip.getVulns().getCategories()) {
                    //VULN
                    for (tr.biznet.bizzy.plugins.qualys.domain.report.fetch.Vulnerability vulnerability : cat.getVulnerabilities()) {

                        ScanVulnerability scanVulnerability = new ScanVulnerability();

                        Vulnerability vuln = new Vulnerability();

                    

                        //port.setService(item.getService());
                        vuln.setVulnNumber(vulnerability.getNumber());
                        vuln.setName(vulnerability.getTitle());

                        vuln.setDescription(vulnerability.getDiagnosis());

                        vuln.setResult(vulnerability.getResult());
                        vuln.setSolution(vulnerability.getSolution());
                        vuln.setSource(Source.QUALYS.toString());

                        //PCI status değeri
                        if (vulnerability.getPciFlag().equals("0")) {
                            vuln.setPciStatus(PCIStatus.PASS);
                        } else {
                            vuln.setPciStatus(PCIStatus.FAIL);
                        }
                        //CVSS değerleri
                        if (vulnerability.getCvssBase() != null) {
                            vuln.setCvssBaseScore(vulnerability.getCvssBase());
                        }
                        if (vulnerability.getCvssTemporal() != null) {
                            vuln.setCvssTemporalScore(vulnerability.getCvssTemporal());
                        }
                        //CVSS3 değerleri
                        if (vulnerability.getCvss3Base() != null) {
                            vuln.setCvss3BaseScore(vulnerability.getCvss3Base());
                        }
                        if (vulnerability.getCvss3Temporal() != null) {
                            vuln.setCvss3TemporalScore(vulnerability.getCvss3Temporal());
                        }

                        if (vulnerability.getCorrrelation() != null) {
                            vuln.setHasPublicExploit(true);
                        } else {
                            vuln.setHasPublicExploit(false);
                        }

                        switch (vulnerability.getSeverity()) {
                            case 0:
                                vuln.setRiskLevel(0);
                                break;
                            case 1:
                                vuln.setRiskLevel(1);
                                break;
                            case 2:
                                vuln.setRiskLevel(2);
                                break;
                            case 3:
                                vuln.setRiskLevel(3);
                                break;
                            case 4:
                                vuln.setRiskLevel(4);
                                break;
                            case 5:
                                vuln.setRiskLevel(5);
                                break;
                            default:
                                break;
                        }

                        //Category category = new Category();
                        //category.setName(item.getPluginFamily());
                        //vuln.setCategory(category);
                        scanVulnerability.setVulnerability(vuln);
//                    scanVulnerability.setSource(Source.QUALYS);
                        scanVulnerability.setSource("QUALYS");
                        scanVulnerability.setActive(true);//Her yeni zafiyet active olarak belirlenir. Eski zafiyetlerin durumuna göre controller'da bu değişebilir.
                        vulnList.add(scanVulnerability);
                    }
                }
            }
            //INFOS
            if (data.getImportVulnTypes().contains("Informational") && ip.getInfos() != null) {
                for (tr.biznet.bizzy.plugins.qualys.domain.report.fetch.Category cat : ip.getInfos().getCategories()) {
                    //INFO
                    for (tr.biznet.bizzy.plugins.qualys.domain.report.fetch.Vulnerability vulnerability : cat.getInfos()) {

                        ScanVulnerability scanVulnerability = new ScanVulnerability();

                        Vulnerability vuln = new Vulnerability();

                  

                        vuln.setVulnNumber(vulnerability.getNumber());
                        vuln.setName(vulnerability.getTitle());

                        //Description'a diagnosisi girdik. Description icin ayrilmis alan yoktu.
                        vuln.setDescription(vulnerability.getDiagnosis());

                        vuln.setResult(vulnerability.getResult());
                        vuln.setSolution(vulnerability.getSolution());
                        vuln.setSource(Source.QUALYS.toString());

                        //PCI status değeri
                        if (vulnerability.getPciFlag().equals("0")) {
                            vuln.setPciStatus(PCIStatus.PASS);
                        } else {
                            vuln.setPciStatus(PCIStatus.FAIL);
                        }
                        //CVSS değerleri
                        if (vulnerability.getCvssBase() != null) {
                            vuln.setCvssBaseScore(vulnerability.getCvssBase());
                        }
                        if (vulnerability.getCvssTemporal() != null) {
                            vuln.setCvssTemporalScore(vulnerability.getCvssTemporal());
                        }
                        //CVSS3 değerleri
                        if (vulnerability.getCvss3Base() != null) {
                            vuln.setCvss3BaseScore(vulnerability.getCvss3Base());
                        }
                        if (vulnerability.getCvss3Temporal() != null) {
                            vuln.setCvss3TemporalScore(vulnerability.getCvss3Temporal());
                        }
                        //INFO'ların tamamının risk seviyesini 0 olarak belirliyoruz. Diğer zafiyetlerde severity neyse o.
                        vuln.setRiskLevel(0);

                        scanVulnerability.setVulnerability(vuln);
                        scanVulnerability.setSource("QUALYS");
                        scanVulnerability.setActive(true);//Her yeni zafiyet active olarak belirlenir. Eski zafiyetlerin durumuna göre controller'da bu değişebilir.
                        vulnList.add(scanVulnerability);
                    }
                }
            }
            //SERVICES
            if (data.getImportVulnTypes().contains("Informational") && ip.getServices() != null) {
                for (tr.biznet.bizzy.plugins.qualys.domain.report.fetch.Category cat : ip.getServices().getCategories()) {
                    //SERVICE
                    for (tr.biznet.bizzy.plugins.qualys.domain.report.fetch.Vulnerability vulnerability : cat.getServices()) {

                        ScanVulnerability scanVulnerability = new ScanVulnerability();

                        Vulnerability vuln = new Vulnerability();

                    

                        vuln.setVulnNumber(vulnerability.getNumber());
                        vuln.setName(vulnerability.getTitle());

                        vuln.setDescription(vulnerability.getDiagnosis());

                        vuln.setResult(vulnerability.getResult());
                        vuln.setSolution(vulnerability.getSolution());
                        vuln.setSource(Source.QUALYS.toString());

                        //PCI status değeri
                        if (vulnerability.getPciFlag().equals("0")) {
                            vuln.setPciStatus(PCIStatus.PASS);
                        } else {
                            vuln.setPciStatus(PCIStatus.FAIL);
                        }
                        //CVSS değerleri
                        if (vulnerability.getCvssBase() != null) {
                            vuln.setCvssBaseScore(vulnerability.getCvssBase());
                        }
                        if (vulnerability.getCvssTemporal() != null) {
                            vuln.setCvssTemporalScore(vulnerability.getCvssTemporal());
                        }
                        //CVSS3 değerleri
                        if (vulnerability.getCvss3Base() != null) {
                            vuln.setCvss3BaseScore(vulnerability.getCvss3Base());
                        }
                        if (vulnerability.getCvss3Temporal() != null) {
                            vuln.setCvss3TemporalScore(vulnerability.getCvss3Temporal());
                        }
                        //SERVICE'lerın tamamının risk seviyesini 0 olarak belirliyoruz.
                        vuln.setRiskLevel(0);

                        scanVulnerability.setVulnerability(vuln);
                        scanVulnerability.setSource("QUALYS");
                        scanVulnerability.setActive(true);//Her yeni zafiyet active olarak belirlenir. Eski zafiyetlerin durumuna göre controller'da bu değişebilir.
                        vulnList.add(scanVulnerability);
                    }
                }
            }

            //PRACTICES
            if (data.getImportVulnTypes().contains("Potential") && ip.getPractices() != null) {
                for (tr.biznet.bizzy.plugins.qualys.domain.report.fetch.Category cat : ip.getPractices().getCategories()) {
                    //PRACTICE
                    for (tr.biznet.bizzy.plugins.qualys.domain.report.fetch.Vulnerability vulnerability : cat.getPractices()) {

                        ScanVulnerability scanVulnerability = new ScanVulnerability();

                        Vulnerability vuln = new Vulnerability();

                   

                        //port.setService(item.getService());
                        vuln.setVulnNumber(vulnerability.getNumber());
                        vuln.setName(vulnerability.getTitle());

                        vuln.setDescription(vulnerability.getDiagnosis());

                        //vuln.setDiagnosis(item.getSynopsis());
                        vuln.setResult(vulnerability.getResult());
                        vuln.setSolution(vulnerability.getSolution());
                        vuln.setSource(Source.QUALYS.toString());

                        //PCI status değeri
                        if (vulnerability.getPciFlag().equals("0")) {
                            vuln.setPciStatus(PCIStatus.PASS);
                        } else {
                            vuln.setPciStatus(PCIStatus.FAIL);
                        }
                        //CVSS değerleri
                        if (vulnerability.getCvssBase() != null) {
                            vuln.setCvssBaseScore(vulnerability.getCvssBase());
                        }
                        if (vulnerability.getCvssTemporal() != null) {
                            vuln.setCvssTemporalScore(vulnerability.getCvssTemporal());
                        }
                        //CVSS3 değerleri
                        if (vulnerability.getCvss3Base() != null) {
                            vuln.setCvss3BaseScore(vulnerability.getCvss3Base());
                        }
                        if (vulnerability.getCvss3Temporal() != null) {
                            vuln.setCvss3TemporalScore(vulnerability.getCvss3Temporal());
                        }
                        switch (vulnerability.getSeverity()) {
                            case 0:
                                vuln.setRiskLevel(0);
                                break;
                            case 1:
                                vuln.setRiskLevel(1);
                                break;
                            case 2:
                                vuln.setRiskLevel(2);
                                break;
                            case 3:
                                vuln.setRiskLevel(3);
                                break;
                            case 4:
                                vuln.setRiskLevel(4);
                                break;
                            case 5:
                                vuln.setRiskLevel(5);
                                break;
                            default:
                                break;
                        }

                        //Category category = new Category();
                        //category.setName(item.getPluginFamily());
                        //vuln.setCategory(category);
                        scanVulnerability.setVulnerability(vuln);
                        scanVulnerability.setSource("QUALYS");
                        scanVulnerability.setActive(true);//Her yeni zafiyet active olarak belirlenir. Eski zafiyetlerin durumuna göre controller'da bu değişebilir.
                        vulnList.add(scanVulnerability);
                    }
                }
            }

            scanAsset.setScanVulnerabilityList(vulnList);
            assetList.add(scanAsset);
        }
        return assetList;
    }
    
    
    public List<ScanAsset> parseQualysDataToScanAssetListSimpleModify(Scan data) {

        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);

        List<ScanAsset> assetList = new LinkedList<>(); 

        for (Ip ip : data.getIps()) {

            ScanAsset scanAsset = new ScanAsset();
            List<ScanVulnerability> vulnList = new LinkedList();

            Asset asset = customerService.getAssetByIp(ip.getValue(), customerId);

            if (asset != null) {
                scanAsset.setAssetId(asset.getAssetId());
                scanAsset.setScannedIp(ip.getValue());
            } else {
                scanAsset.setScannedIp(ip.getValue());
            }
     
            if (data.getImportVulnTypes().contains("Confirmed") && ip.getVulns() != null) {
                for (tr.biznet.bizzy.plugins.qualys.domain.report.fetch.Category cat : ip.getVulns().getCategories()) {
          
                    for (tr.biznet.bizzy.plugins.qualys.domain.report.fetch.Vulnerability vulnerability : cat.getVulnerabilities()) {

                        ScanVulnerability scanVulnerability = new ScanVulnerability();

                        Vulnerability vuln = new Vulnerability();

                    
                        vuln.setVulnNumber(vulnerability.getNumber());
                        vuln.setName(vulnerability.getTitle());
                        vuln.setResult(vulnerability.getResult());
                        vuln.setSource(Source.QUALYS.toString());

                       

                        switch (vulnerability.getSeverity()) {
                            case 0:
                                vuln.setRiskLevel(0);
                                break;
                            case 1:
                                vuln.setRiskLevel(1);
                                break;
                            case 2:
                                vuln.setRiskLevel(2);
                                break;
                            case 3:
                                vuln.setRiskLevel(3);
                                break;
                            case 4:
                                vuln.setRiskLevel(4);
                                break;
                            case 5:
                                vuln.setRiskLevel(5);
                                break;
                            default:
                                break;
                        }

                        scanVulnerability.setVulnerability(vuln);
                        scanVulnerability.setSource("QUALYS");
                        scanVulnerability.setActive(true);
                        vulnList.add(scanVulnerability);
                    }
                }
            }
         
            if (data.getImportVulnTypes().contains("Informational") && ip.getInfos() != null) {
                for (tr.biznet.bizzy.plugins.qualys.domain.report.fetch.Category cat : ip.getInfos().getCategories()) {
                    //INFO
                    for (tr.biznet.bizzy.plugins.qualys.domain.report.fetch.Vulnerability vulnerability : cat.getInfos()) {

                        ScanVulnerability scanVulnerability = new ScanVulnerability();

                        Vulnerability vuln = new Vulnerability();

                  

                        vuln.setVulnNumber(vulnerability.getNumber());
                        vuln.setName(vulnerability.getTitle());
                        vuln.setResult(vulnerability.getResult());
                        vuln.setSource(Source.QUALYS.toString());
                        vuln.setRiskLevel(0);

                        scanVulnerability.setVulnerability(vuln);
                        scanVulnerability.setSource("QUALYS");
                        scanVulnerability.setActive(true);
                        vulnList.add(scanVulnerability);
                    }
                }
            }
            if (data.getImportVulnTypes().contains("Informational") && ip.getServices() != null) {
                for (tr.biznet.bizzy.plugins.qualys.domain.report.fetch.Category cat : ip.getServices().getCategories()) {
                    //SERVICE
                    for (tr.biznet.bizzy.plugins.qualys.domain.report.fetch.Vulnerability vulnerability : cat.getServices()) {

                        ScanVulnerability scanVulnerability = new ScanVulnerability();

                        Vulnerability vuln = new Vulnerability();

                    

                        vuln.setVulnNumber(vulnerability.getNumber());
                        vuln.setName(vulnerability.getTitle());
                        vuln.setResult(vulnerability.getResult());
                        vuln.setSource(Source.QUALYS.toString());
                        vuln.setRiskLevel(0);
                        
                        scanVulnerability.setVulnerability(vuln);
                        scanVulnerability.setSource("QUALYS");
                        scanVulnerability.setActive(true);
                        vulnList.add(scanVulnerability);
                    }
                }
            }

            if (data.getImportVulnTypes().contains("Potential") && ip.getPractices() != null) {
                for (tr.biznet.bizzy.plugins.qualys.domain.report.fetch.Category cat : ip.getPractices().getCategories()) {
                 
                    for (tr.biznet.bizzy.plugins.qualys.domain.report.fetch.Vulnerability vulnerability : cat.getPractices()) {

                        ScanVulnerability scanVulnerability = new ScanVulnerability();

                        Vulnerability vuln = new Vulnerability();
                        vuln.setVulnNumber(vulnerability.getNumber());
                        vuln.setName(vulnerability.getTitle());
                        vuln.setResult(vulnerability.getResult());
                        vuln.setSource(Source.QUALYS.toString());

                     
                        switch (vulnerability.getSeverity()) {
                            case 0:
                                vuln.setRiskLevel(0);
                                break;
                            case 1:
                                vuln.setRiskLevel(1);
                                break;
                            case 2:
                                vuln.setRiskLevel(2);
                                break;
                            case 3:
                                vuln.setRiskLevel(3);
                                break;
                            case 4:
                                vuln.setRiskLevel(4);
                                break;
                            case 5:
                                vuln.setRiskLevel(5);
                                break;
                            default:
                                break;
                        }

                        scanVulnerability.setVulnerability(vuln);
                        scanVulnerability.setSource("QUALYS");
                        scanVulnerability.setActive(true);
                        vulnList.add(scanVulnerability);
                    }
                }
            }

            scanAsset.setScanVulnerabilityList(vulnList);
            assetList.add(scanAsset);
        }
        return assetList;
    }

    /**
     * Tarama sonuçları sayfası datatable (viewScanResults)
     *
     * @param request
     * @param response
     * @param scanResultsFilter
     * @return String
     */
    @RequestMapping(value = "loadScanResults.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String loadScanResults(HttpServletRequest request, HttpServletResponse response, ScanResultsFilter scanResultsFilter) {
        Locale locale = RequestContextUtils.getLocale(request);
        DataTablesRequest dataTablesRequest = DataTablesUtil.getRequest(request);
        scanResultsFilter = loadScanResultsFilter(scanResultsFilter);
        scanResultsFilter.setDateRangeMap(DaoUtil.getInstance().stringConvertToDateRange(scanResultsFilter.getDaterange()));
        scanUnauthorizedAccessControl(scanResultsFilter.getScanId());
        int totalCount = pentestService.getScanResultsCount(scanResultsFilter);
        List<ScanVulnerability> scanVulnerabilityList = pentestService.getScanResults(dataTablesRequest, scanResultsFilter);
        //TODO: Burada ticketları çekerken 25 kayıt için fazla zaman harcıyor. Burayı iyileştirmek gerekir.
        for (ScanVulnerability sv : scanVulnerabilityList) {
            sv.getVulnerability().setRiskDescription(MessageUtil.getLocaleMessage(locale, "dashboard.level" + sv.getVulnerability().getRiskLevel()));
            setTicketWithScanVulnerability(sv, locale);
        }
        return DataTablesUtil.getResponse(dataTablesRequest.getDraw(), totalCount, totalCount, scanVulnerabilityList);
    }
    
    private ScanResultsFilter loadScanResultsFilter(ScanResultsFilter filter) {
      
        if (!BizzyUtil.isEmpty(filter.getState())) {
            if (filter.getState().equals("active")) {
                filter.setActive(false);
            }
            if (filter.getState().equals("passive")) {
                filter.setActive(true);
            }
        }
        return filter;
    }


    /**
     * Tarama sonuçları sayfası datatable (viewScanAssets)
     *
     * @param request
     * @param response
     * @return String
     */
    @RequestMapping(value = "loadScanAssets.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String loadScanAssets(HttpServletRequest request, HttpServletResponse response) {
        
        DataTablesRequest dataTablesRequest = DataTablesUtil.getRequest(request);
        
        String scanId = ServletRequestUtils.getStringParameter(request, "scanId", null);
        scanUnauthorizedAccessControl(scanId);
        int totalCount = pentestService.getScanAssetsCount(scanId);
        List<ScanAsset> scanAssets = pentestService.getScanAssets(dataTablesRequest, scanId);
        int maxVulnCount = pentestService.getMaxVulnCountByScanAssets(scanId);
        scanAssets = pentestService.getRiskDistributionOfScanAssets(scanAssets, maxVulnCount);
        return DataTablesUtil.getResponse(dataTablesRequest.getDraw(), totalCount, totalCount, scanAssets);
        
    }

    /**
     * Tarama sonuçları sayfası datatable (viewAssetVulnerabilities)
     *
     * @param request
     * @param response
     * @param scanResultsFilter
     * @return String
     */
    @RequestMapping(value = "loadAssetVulnerabilities.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String loadAssetVulnerabilities(HttpServletRequest request, HttpServletResponse response, ScanResultsFilter scanResultsFilter) {
        Locale locale = RequestContextUtils.getLocale(request);
        DataTablesRequest dataTablesRequest = DataTablesUtil.getRequest(request);
        scanResultsFilter = loadScanResultsFilter(scanResultsFilter);
        scanResultsFilter.setDateRangeMap(DaoUtil.getInstance().stringConvertToDateRange(scanResultsFilter.getDaterange()));
        scanUnauthorizedAccessControl(scanResultsFilter.getScanId());
        int totalCount = pentestService.getAssetVulnerabilitiesCount(scanResultsFilter);
        List<AssetVulnerability> assetVulnerabilityList = pentestService.getAssetVulnerabilities(dataTablesRequest, scanResultsFilter);
        for (AssetVulnerability av : assetVulnerabilityList) {
            av.getVulnerability().setRiskDescription(MessageUtil.getLocaleMessage(locale, "dashboard.level" + av.getVulnerability().getRiskLevel()));
            av.getVulnerability().setEffect(MessageUtil.getLocaleMessage(locale, av.getVulnerability().getEffect()));
            av.getVulnerability().setRootCause(MessageUtil.getLocaleMessage(locale, av.getVulnerability().getRootCause()));
            av.getVulnerability().setProblemArea(MessageUtil.getLocaleMessage(locale, av.getVulnerability().getProblemArea()));
        }
        return DataTablesUtil.getResponse(dataTablesRequest.getDraw(), totalCount, totalCount, assetVulnerabilityList);
    }

    //TODO : sorgular ticket yapısına geçtikten sonra bu metod kullanılacak.
    private ScanResultsFilter loadFilter(ScanResultsFilter filter) {
        try {
            if (!BizzyUtil.isEmpty(filter.getUpdateDateRange())) {
                String[] dates = filter.getUpdateDateRange().split("-");
                SimpleDateFormat formatter = new SimpleDateFormat("dd.MM.yyyy");

                filter.setUpdateDateStart(formatter.parse(dates[0].trim()));
                filter.setUpdateDateEnd(formatter.parse(dates[1].trim()));
            }
        } catch (Exception ex) {
            logger.log(LogLevel.ERROR, "Güncelleme tarihi filtresi parse edilemedi.", ex);
        }

        return filter;
    }
    
    

    private void scanUnauthorizedAccessControl(String scanId) {
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        //Yetkisiz erişim kontrolü
        if (BizzyUtil.hasACustomerRole(user)) {
            PentestScan pentestScan = pentestService.getScanDetailsWithoutAssets(scanId);
            if (pentestScan == null) {
                logger.log(LogLevel.ERROR, "Böyle bir tarama yok ! Tarama Id: " + scanId);
            } else if (!pentestScan.getCustomer().getCustomerId().equals(customerId)) {
                logger.log(LogLevel.ERROR, "Yetkisiz tarama erişimi ! Tarama Id: " + scanId);
            }
        }
    }

    /**
     * startScan.htm sayfasında birden fazla IP bilgisini String yerine
     * AssetAndGroup olarak almak için Binder kullandık. tarama tarihi null
     * olduğunda parse edememe hatasını da CustomDateEditor ile giderdik.
     *
     * @param binder
     * @throws java.lang.Exception
     */
    @InitBinder
    protected void initBinder(WebDataBinder binder) throws Exception {
        binder.registerCustomEditor(List.class, "assetAndGroup", new CustomCollectionEditor(List.class) {
            @Override
            protected Object convertElement(Object element) {
                if (element instanceof AssetAndGroup) {
                    return element;
                }
                if (element instanceof String) {
                    AssetAndGroup aag = new AssetAndGroup();
                    aag.setId(element.toString());
                    return aag;
                }
                return null;
            }
        });
        binder.registerCustomEditor(Date.class, "scanDate", new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd HH:mm"), true) {
            protected Object convertElement(Object element) {
                if (element instanceof String) {
                    return new Date();
                }
                return null;
            }
        });
        binder.registerCustomEditor(Date.class,
                new CustomDateEditor(new SimpleDateFormat("dd/MM/yyyy"), true, 10));

    }

//    public List<Assignee> getAssigneeListForVulnerability(String assetId) {
//        User session = HttpUtil.getUser();
//        String customerId = BizzyUtil.getCustomerIdByUser(session);
//
//        if (BizzyUtil.isEmpty(customerId)) {
//            Asset asset = assetService.getAssetById(assetId);
//            customerId = asset.getCustomerId();
//        }
//
//        List<Assignee> assigneeList = new LinkedList<>();
//
//        List<User> users = aaService.getUsersByCustomerId(null, customerId);
//        assigneeList.add(new Assignee());
//
//        for (User user : users) {
//            Assignee assignee = new Assignee();
//            assignee.setAssigneeId(user.getUserId());
//            assignee.setName(user.getUsername());
//            assignee.setType(AssigneeTypeEnum.USER);
//            assigneeList.add(assignee);
//        }
//
//        List<Group> groups = aaService.getGroupsByCustomerId(null, customerId);
//
//        for (Group group : groups) {
//            Assignee assignee = new Assignee();
//            assignee.setAssigneeId(group.getId());
//            assignee.setName(group.getName());
//            assignee.setType(AssigneeTypeEnum.GROUP);
//            assigneeList.add(assignee);
//        }
//
//        return assigneeList;
//    }
    // TODO: MK
    @RequestMapping(value = "addAssetToScan.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String addAssetToScan(HttpServletRequest request, HttpServletResponse response) {
        List<Asset> assets = new ArrayList<>();
        List<Asset> removedAssets = new ArrayList<>();
        String[] ips = request.getParameter("ip").split(",");
        String[] removedIps = request.getParameter("removedIp").split(",");
        Iterator<String> itrator = ((MultipartHttpServletRequest) request).getFileNames();
        if (itrator.hasNext()) {
            MultipartFile file = ((MultipartHttpServletRequest) request).getFile(itrator.next());
            String[] assetsFromFile = null;
            try {
                ByteArrayInputStream stream = new ByteArrayInputStream(file.getBytes());
                String assetsWithComma = IOUtils.toString(stream, "UTF-8");
                assetsFromFile = assetsWithComma.split(",");

            } catch (IOException ex) {
                Logger.getLogger(PentestController.class.getName()).log(Level.SEVERE, null, ex);
            }
            ips = (String[]) ArrayUtils.addAll(ips, assetsFromFile);
        }

        for (String ip : ips) {
            if (!BizzyUtil.isEmpty(ip)) {
                if (ip.contains(",")) {
                    List<String> ipAll = BizzyUtil.parseCommaSeparatedStringAsList(ip);
                    for (String item : ipAll) {
                        Asset a = new Asset();
                        a.setIp(item);
                        assets.add(a);
                    }
                } else if (ip.contains("-") && BizzyUtil.isIpRange(ip)) {
                    List<String> ipAll = BizzyUtil.parseIpRange(ip);
                    for (String item : ipAll) {
                        Asset a = new Asset();
                        a.setIp(item);
                        assets.add(a);
                    }
                } else if (ip.contains("/")) {
                    SubnetUtils utils = new SubnetUtils(ip);
                    String[] allIps = utils.getInfo().getAllAddresses();
                    for (String item : allIps) {
                        Asset a = new Asset();
                        a.setIp(item);
                        assets.add(a);
                    }
                } else {
                    Asset a = new Asset();
                    a.setIp(ip);
                    assets.add(a);
                }
            }
        }
        for (String removedIp : removedIps) {
            if (!BizzyUtil.isEmpty(removedIp)) {
                if (removedIp.contains(",")) {
                    List<String> ipAll = BizzyUtil.parseCommaSeparatedStringAsList(removedIp);
                    for (String item : ipAll) {
                        Asset a = new Asset();
                        a.setIp(item);
                        removedAssets.add(a);
                    }
                } else if (removedIp.contains("-")) {
                    List<String> ipAll = BizzyUtil.parseIpRange(removedIp);
                    for (String item : ipAll) {
                        Asset a = new Asset();
                        a.setIp(item);
                        removedAssets.add(a);
                    }
                } else if (removedIp.contains("/")) {
                    SubnetUtils utils = new SubnetUtils(removedIp);
                    String[] allIps = utils.getInfo().getAllAddresses();
                    for (String item : allIps) {
                        Asset a = new Asset();
                        a.setIp(item);
                        removedAssets.add(a);
                    }
                } else {
                    Asset a = new Asset();
                    a.setIp(removedIp);
                    removedAssets.add(a);
                }
            }
        }
        String resultSame = "{\"same\": [";
        String resultDifferent;

        List<List<String>> resultList = new ArrayList<>();
        String scanid = ServletRequestUtils.getStringParameter(request, "selectedscan", null);
        resultList = customerService.addAssetToScan(scanid, assets, "NULL");

        int counter = 0;
        if (resultList.get(0).size() > 0) {
            counter += 1;
        }

        if (counter > 0) { //Eğer aynı varlıklar varsa
            for (int i = 0; i < resultList.get(0).size(); i++) {
                resultSame += "\"" + resultList.get(0).get(i) + "\"" + ", ";
            }
            resultSame = resultSame.substring(0, resultSame.length() - 2) + "], ";
            if (resultList.get(1).size() > 0) //Eğer eklenen varlıklar varsa
            {
                resultDifferent = "\"different\": [" + "\"" + resultList.get(1).get(0) + "\"";
                for (int i = 1; i < resultList.get(1).size(); i++) {
                    resultDifferent += ", " + "\"" + resultList.get(1).get(i) + "\"";
                }
                resultDifferent += "], \"check\": 1}";
            } else {
                resultDifferent = "\"different\": [], \"check\": 1}";
            }
            return resultSame + resultDifferent;
        } else {                                                                                    // Varlık ekleme ile igili problem yoksa varlık kaldırmaya geçilir.
            String removedResult = customerService.removeAssetFromScan(scanid, removedAssets);
            if (removedResult.equals("vulnerabilityExist")) {
                return "{\"check\":2}";
            }
            return "{\"check\":0}";
        }

    }

    @RequestMapping(value = "renameScan.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String renameScan(HttpServletRequest request, HttpServletResponse response) {
        String scanId = ServletRequestUtils.getStringParameter(request, "scanId", null);
        String scanName = ServletRequestUtils.getStringParameter(request, "scanName", null);
        PentestScan scan = pentestService.getScanByName(scanName);

        if (scan != null) {
            return "{\"alreadyAdded\":1}";
        } else {
            pentestService.updateScanName(scanName, scanId);
            return "{}";
        }
    }

    /**
     * Tarama sonuçları sayfası (viewScanResults) zafiyet detayı modal'ı
     * @param request
     * @param response
     * @return sv
     * @throws IOException 
     */
    @RequestMapping(value = "getDetails.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public ScanVulnerability getDetails(HttpServletRequest request, HttpServletResponse response) throws IOException {
        Locale locale = RequestContextUtils.getLocale(request);
        String id = ServletRequestUtils.getStringParameter(request, "vulnid", null);
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        ScanVulnerability vuln = customerService.getVulnerabilityById(id);
        if (!vuln.isActive()) {
            // pasif zafiyet için, aktifine bağlantı linki verilecek ve tarama history'si oluşturulacak.
            setPassiveVulnerabilitySpecificDetails(vuln, customerId);
        } else {
            vuln.setScanName(vuln.getScanVulnerabilityId());
        }
        
        List<AssetGroup> assetGroups = assetService.getAssetGroupsByAssetId(vuln.getVulnerability().getAsset().getAssetId());
        vuln.getVulnerability().getAsset().setGroups(assetGroups);

        if (!vuln.getSource().equals(Source.PENTEST.toString())) {
            if (!BizzyUtil.isEmpty(vuln.getVulnerability().getDescription())) {
                vuln.getVulnerability().setDescription(BizzyUtil.replaceEscapeCode(vuln.getVulnerability().getDescription()));
            }
            if (!BizzyUtil.isEmpty(vuln.getVulnerability().getResult())) {
                vuln.getVulnerability().setResult(BizzyUtil.replaceEscapeCode(vuln.getVulnerability().getResult()));
            }
            if (!BizzyUtil.isEmpty(vuln.getVulnerability().getSolution())) {
                vuln.getVulnerability().setSolution(BizzyUtil.replaceEscapeCode(vuln.getVulnerability().getSolution()));
            }
        }
        if (vuln.getVulnerability().getReferences() != null) {
            vuln.getVulnerability().setReferences(EscapeUtil.escapeForHtml(vuln.getVulnerability().getReferences()));
        }
        if (vuln.getVulnerability().getAsset().getHostname() != null) {
            vuln.getVulnerability().getAsset().setHostname(EscapeUtil.escapeForHtml(vuln.getVulnerability().getAsset().getHostname()));
        }
        vuln.getVulnerability().setEffect(messageSource.getMessage(vuln.getVulnerability().getEffect(), locale));
        vuln.getVulnerability().setRootCause(messageSource.getMessage(vuln.getVulnerability().getRootCause(), locale));
        vuln.getVulnerability().setProblemArea(messageSource.getMessage(vuln.getVulnerability().getProblemArea(), locale));
        vuln.setLikelihood(messageSource.getMessage(vuln.getLikelihood(), locale));
        vuln.setSocialImpact(messageSource.getMessage(vuln.getSocialImpact(), locale));
        vuln.getVulnerability().setName(EscapeUtil.escapeForHtml(vuln.getVulnerability().getName()));
        vuln.getVulnerability().getAsset().setIp(EscapeUtil.escapeForHtml(vuln.getVulnerability().getAsset().getIp()));
        vuln.getVulnerability().setRiskDescription(MessageUtil.getLocaleMessage(locale, "dashboard.level" + vuln.getVulnerability().getRiskLevel()));
        vuln.setWebApps(customerService.getWebApps(null, id));
        vuln.setImages(fileService.getImageFileListByDataTypeAndTableIdAndCustomerIdWithData(vuln.getVulnerability().getAsset().getCustomerId(), id, FileDataTypeEnum.VULNERABILITY.getType()));
        for (ImageFile image : vuln.getImages()) {
            byte[] imageBytes = javax.xml.bind.DatatypeConverter.parseBase64Binary(image.getTextData());
            BufferedImage img = ImageIO.read(new ByteArrayInputStream(imageBytes));
            Image tmp = img.getScaledInstance(120, 120, Image.SCALE_SMOOTH);
            BufferedImage dimg = new BufferedImage(120, 120, img.getType());

            Graphics2D g2d = dimg.createGraphics();
            g2d.drawImage(tmp, 0, 0, null);
            g2d.dispose();

            ByteArrayOutputStream out = new ByteArrayOutputStream();
            ImageIO.write(dimg, image.getFileExtension(), out);
            byte[] bytes = out.toByteArray();

            image.setTextData(Base64.encodeBase64String(bytes));
        }
        try {
            float score = vuln.getRiskScore() * 10;
            score = Math.round(score);
            score = score / 10;
            vuln.setRiskScore(score);
        } catch (Exception ex) {
            logger.log(LogLevel.INFO, "Zafiyet risk skorunu almada hata!");
        }
        String performanceScoreActive = configurationService.getByKeyAndCustomerId("performanceScoreActive", customerId).get(0);
        if(performanceScoreActive.equals("true")) {
            String performanceLevel = configurationService.getByKeyAndCustomerId("performanceLevelFilter", customerId).get(0);
            String[] performanceLevelFilter = performanceLevel.split(",");
            List<String> performanceLevelFilterList = Arrays.asList(performanceLevelFilter);
            if(vuln.getPerformanceScore() != null && !performanceLevelFilterList.contains(vuln.getPluginLevel())) {
                vuln.setPerformanceScore(0f);
            }
        }
       if (!vuln.getVulnerability().getSource().equals("FORTIFY") && !vuln.getVulnerability().getSource().equals("CHECKMARX")) {
            String pluginId = vuln.getVulnerability().getVulnNumber();
            String port = vuln.getVulnerability().getPort().getPortId();
            String protocol = vuln.getVulnerability().getPort().getProtocol();
            String scannedIp = EscapeUtil.escapeForHtml(vuln.getVulnerability().getAsset().getIp());
            PassiveScanVulnerabilityInfo passiveVuln = customerService.getActiveVulnerabilityInfo(customerId,scannedIp, port, protocol,pluginId);
            vuln.setPassiveScanVulnerabilityInfo(passiveVuln);
        }
      
        return vuln;
    }

    @RequestMapping(value = "getAssetVulnerabilityDetails.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public List<ScanVulnerability> getAssetVulnerabilityDetails(HttpServletRequest request, HttpServletResponse response, ScanResultsFilter scanResultsFilter) throws IOException {
        Locale locale = RequestContextUtils.getLocale(request);
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        List<ScanVulnerability> vulnList = customerService.getScanVulnerabilityByFilter(scanResultsFilter);
        for (ScanVulnerability sv : vulnList) {
            
            if (!sv.isActive()) {
                // pasif zafiyet için, aktifine bağlantı linki verilecek ve tarama history'si oluşturulacak.
                setPassiveVulnerabilitySpecificDetails(sv, customerId);
            }
            
            List<AssetGroup> assetGroups = assetService.getAssetGroupsByAssetId(sv.getVulnerability().getAsset().getAssetId());
            sv.getVulnerability().getAsset().setGroups(assetGroups);
            
            if (!sv.getSource().equals(Source.PENTEST.toString())) {
                if (!BizzyUtil.isEmpty(sv.getVulnerability().getDescription())) {
                    sv.getVulnerability().setDescription(BizzyUtil.replaceEscapeCode(sv.getVulnerability().getDescription()));
                }
                if (!BizzyUtil.isEmpty(sv.getVulnerability().getResult())) {
                    sv.getVulnerability().setResult(BizzyUtil.replaceEscapeCode(sv.getVulnerability().getResult()));
                }
                if (!BizzyUtil.isEmpty(sv.getVulnerability().getSolution())) {
                    sv.getVulnerability().setSolution(BizzyUtil.replaceEscapeCode(sv.getVulnerability().getSolution()));
                }
            }
            if(sv.getVulnerability().getReferences() != null){
                sv.getVulnerability().setReferences(EscapeUtil.escapeForHtml(sv.getVulnerability().getReferences()));
            }
            if(sv.getVulnerability().getAsset().getHostname() != null){
                sv.getVulnerability().getAsset().setHostname(EscapeUtil.escapeForHtml(sv.getVulnerability().getAsset().getHostname()));
            }
            sv.getVulnerability().setName(EscapeUtil.escapeForHtml(sv.getVulnerability().getName()));
            sv.setLikelihood(messageSource.getMessage(sv.getLikelihood(), locale));
            sv.setSocialImpact(messageSource.getMessage(sv.getSocialImpact(), locale));
            sv.getVulnerability().getAsset().setIp(EscapeUtil.escapeForHtml(sv.getVulnerability().getAsset().getIp()));
            sv.getVulnerability().setRiskDescription(MessageUtil.getLocaleMessage(locale, "dashboard.level" + sv.getVulnerability().getRiskLevel()));

            sv.setWebApps(customerService.getWebApps(null, sv.getScanVulnerabilityId()));
            sv.setImages(fileService.getImageFileListByDataTypeAndTableIdAndCustomerIdWithData(sv.getVulnerability().getAsset().getCustomerId(), sv.getScanVulnerabilityId(), FileDataTypeEnum.VULNERABILITY.getType()));      
            
            for (ImageFile image : sv.getImages()) {
                byte[] imageBytes = javax.xml.bind.DatatypeConverter.parseBase64Binary(image.getTextData());
                BufferedImage img = ImageIO.read(new ByteArrayInputStream(imageBytes));
                Image tmp = img.getScaledInstance(120, 120, Image.SCALE_SMOOTH);
                BufferedImage dimg = new BufferedImage(120, 120, img.getType());

                Graphics2D g2d = dimg.createGraphics();
                g2d.drawImage(tmp, 0, 0, null);
                g2d.dispose();

                ByteArrayOutputStream out = new ByteArrayOutputStream();
                ImageIO.write(dimg, image.getFileExtension(), out);
                byte[] bytes = out.toByteArray();

                image.setTextData(Base64.encodeBase64String(bytes));
            }
        }
        setTicketListWithScanVulnerability(vulnList, locale);
        return vulnList;
    }
    @RequestMapping(value = "getAssetVulnerabilityDetailImageFile.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public ImageFile getAssetVulnerabilityDetailImageFile(HttpServletRequest request, HttpServletResponse response) throws IOException {
        String fileId = ServletRequestUtils.getStringParameter(request, "fileId", null);
        User user = HttpUtil.getUser();
        String customerId;
        ImageFile file;
        if(user.getCustomer() != null) {
            customerId = BizzyUtil.getCustomerIdByUser(user);
            file = fileService.getImageFileByKeyAndCustomerId(customerId, fileId);
        } else {
            file = fileService.getImageFileByKey(fileId);
        }
        return file;
    }

    /**
     * Taramalar sayfasında "Tarama Raporu" PDF seçilirse grafik verisi bu
     * fonksiyonla çekilir.
     *
     * @param request
     * @param response
     * @return String
     * @throws BizzyException
     */
    @RequestMapping(value = "loadVulnerabilityStatusGraph.json", method = RequestMethod.POST)
    @ResponseBody
    public String loadVulnerabilityStatusGraph(HttpServletRequest request, HttpServletResponse response) throws BizzyException {

        String scan = ServletRequestUtils.getStringParameter(request, "scan", null);
        boolean state = ServletRequestUtils.getBooleanParameter(request, "state", false);
        VulnerabilityFilter filter = new VulnerabilityFilter();
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        filter.setCustomerId(customerId);
        filter.setActive(state);
        filter.setScan(new String[]{scan});
        List<Integer> vulnCountsByStatuses = reportService.getStatusCountForScanReport(filter);
        return JsonUtil.getResponse(vulnCountsByStatuses);

    }

    /**
     * Taramalar sayfasında "Tarama Raporu" PDF seçilirse grafik verisi bu
     * fonksiyonla çekilir.
     *
     * @param request
     * @param response
     * @return String
     * @throws BizzyException
     */
    @RequestMapping(value = "loadVulnerabilityRiskLevelGraph.json", method = RequestMethod.POST)
    @ResponseBody
    public String loadVulnerabilityRiskLevelGraph(HttpServletRequest request, HttpServletResponse response) throws BizzyException {

        String scan = ServletRequestUtils.getStringParameter(request, "scan", null);
        boolean state = ServletRequestUtils.getBooleanParameter(request, "state", false);
        VulnerabilityFilter filter = new VulnerabilityFilter();
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        filter.setCustomerId(customerId);
        filter.setActive(state);
        filter.setScan(new String[]{scan});
        List<Integer> vulnCountsByStatuses = reportService.getRiskLevelCountForScanReport(filter);
        return JsonUtil.getResponse(vulnCountsByStatuses);

    }

    /**
     * Taramalar sayfasında "Tarama Raporu" PDF seçilirse grafik verisi bu
     * fonksiyonla çekilir.
     *
     * @param request
     * @param response
     * @return String
     * @throws ParseException
     */
    @RequestMapping(value = "loadAssetVulnerabilityCountGraph.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String loadAssetVulnerabilityCountGraph(HttpServletRequest request, HttpServletResponse response) throws ParseException {

        String scan = ServletRequestUtils.getStringParameter(request, "scan", null);
        boolean state = ServletRequestUtils.getBooleanParameter(request, "state", false);
        VulnerabilityFilter filter = new VulnerabilityFilter();
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        filter.setCustomerId(customerId);
        filter.setActive(state);
        filter.setScan(new String[]{scan});
        List<Asset> assetGraphData = customerService.getAssetsWithVulnLevelCounts(filter, null, null);
        return JsonUtil.getResponse(assetGraphData);

    }

    /**
     * Taramalar sayfasından "Tarama Raporu" üretildiğinde çalışır.
     *
     * @param request
     * @param response
     * @return String
     * @throws BizzyException
     */
    @RequestMapping(value = "getScanReport.json", method = RequestMethod.POST)
    @ResponseBody
    public String getScanReport(HttpServletRequest request, HttpServletResponse response) throws BizzyException {

        VulnerabilityReportStatistics stats = new VulnerabilityReportStatistics();
        HashMap<String, String> distinctIps = new HashMap<String, String>();
        Locale locale = RequestContextUtils.getLocale(request);
        String reportType = ServletRequestUtils.getStringParameter(request, "reportType", null);
        String reportName = ServletRequestUtils.getStringParameter(request, "reportName", null);
        String scan = ServletRequestUtils.getStringParameter(request, "scan", null);
        boolean state = ServletRequestUtils.getBooleanParameter(request, "state", false);
        List<Message> effects = kBService.getMessages(VULNERABILITY_EFFECT);
        List<Message> problemAreas = kBService.getMessages(PROBLEM_AREA);
        List<Message> rootCauses = kBService.getMessages(ROOT_CAUSE);

        VulnerabilityFilter filter = new VulnerabilityFilter();
        List<String> scanAssetIds = pentestService.getScanAssetsByScanId(scan);
        String[] saIds = new String[scanAssetIds.size()];
        filter.setScanAssets(scanAssetIds.toArray(saIds));
        stats.setTotalScannedAssetCount(scanAssetIds.size());
        int activeVulnCount = 0;
        int passiveVulnCount = 0;
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        filter.setCustomerId(customerId);
        //Rapor için zafiyetler çekilirken zafiyet aktif pasif durum da filtreye aklendi, gürkan 11.06.2018
        filter.setActive(state);
        List<ScanVulnerability> vulnerabilities = customerService.getVulnerabilityDetailsForScanReport(filter);
        try {
            if (vulnerabilities.isEmpty()) {
                response.setStatus(204);
                return "{}";
            }
        } catch (Exception ex) {
            logger.log(LogLevel.ERROR, "Dosya okunurken hata oluştu.", ex);
            throw new BizzyException("Dosya okunurken hata oluştu.", ex);
        }

        filter.setScan(new String[]{scan});
        List<Vulnerability> statusGraphData = new LinkedList<>();
        if (reportType.equals("Html") || reportType.equals("Word")) {
            if (filter.isActive()) {
                for (String statusItem : ALL_STATUS) {
                    Vulnerability data = new Vulnerability();
                    data.setStatus(messageSource.getMessage("genericdb." + statusItem, locale));
                    filter.setStatuses(new String[]{statusItem});
                    data.setCount(customerService.getVulnerabilityCountForScanReport(filter));
                    switch (statusItem) {
                        case "OPEN":
                            data.setColor("#67B7DC");
                            break;
                        case "CLOSED":
                            data.setColor("#FDD400");
                            break;
                        case "RISK_ACCEPTED":
                            data.setColor("#84B761");
                            break;
                        case "RECHECK":
                            data.setColor("#CC4748");
                            break;
                        case "ON_HOLD":
                            data.setColor("#CD82AD");
                            break;
                        case "IN_PROGRESS":
                            data.setColor("#2F4074");
                            break;
                        case "FALSE_POSITIVE":
                            data.setColor("#CF8B07");
                            break;     
                        default:
                            break;
                    }
                    statusGraphData.add(data);
                }
            }
        }
        List<Vulnerability> riskLevelGraphData = new LinkedList<>();
        if (reportType.equals("Html") || reportType.equals("Word")) {
            for (int i = 1; i < 6; i++) {
                Vulnerability data = new Vulnerability();
                data.setName(messageSource.getMessage("dashboard.level" + i, locale));
                filter.setStatuses(null);
                filter.setRiskLevels(new int[]{i});
                data.setCount(customerService.getVulnerabilityCountForScanReport(filter));
                switch (i) {
                    case 1:
                        data.setColor("#F9FABB");
                        break;
                    case 2:
                        data.setColor("#FEFE60");
                        break;
                    case 3:
                        data.setColor("#F8C508");
                        break;
                    case 4:
                        data.setColor("#F88008");
                        break;
                    case 5:
                        data.setColor("#D91E18");
                        break;
                    default:
                        break;
                }
                riskLevelGraphData.add(data);
            }
        }

        for (int k = 0; k < vulnerabilities.size(); k++) {
            if (vulnerabilities.get(k).isActive() == true) {
                activeVulnCount += 1;
            } else if (vulnerabilities.get(k).isActive() == false) {
                passiveVulnCount += 1;
            }

            String lang = locale.getLanguage();
            if (lang.equals("en")) {
                if (vulnerabilities.get(k).getVulnerability().getCategory() != null) {
                    if (vulnerabilities.get(k).getVulnerability().getCategory().getSecondaryName() != null && !vulnerabilities.get(k).getVulnerability().getCategory().getSecondaryName().equals("")) {
                        vulnerabilities.get(k).getVulnerability().getCategory().setName(vulnerabilities.get(k).getVulnerability().getCategory().getSecondaryName());
                    }
                }
            }

            String tempIp = vulnerabilities.get(k).getVulnerability().getAsset().getIp();
            distinctIps.put(tempIp, tempIp);
            String valueproblem = vulnerabilities.get(k).getVulnerability().getProblemArea();
            if (valueproblem == null || "".equals(valueproblem)) {
                vulnerabilities.get(k).getVulnerability().setProblemArea("-");
            } else {
                for (Message problemArea : problemAreas) {
                    if (valueproblem.equals(problemArea.getName())) {
                        String value = problemArea.getValue();
                        vulnerabilities.get(k).getVulnerability().setProblemArea(value);
                    }
                }
            }
            String valueroot = vulnerabilities.get(k).getVulnerability().getRootCause();
            if (valueroot == null || "".equals(valueroot)) {
                vulnerabilities.get(k).getVulnerability().setRootCause("-");
            } else {
                for (Message rootCause : rootCauses) {
                    if (valueroot.equals(rootCause.getName())) {
                        String value = rootCause.getValue();
                        vulnerabilities.get(k).getVulnerability().setRootCause(value);
                    }
                }
            }

            String valueeffect = vulnerabilities.get(k).getVulnerability().getEffect();
            if (valueeffect == null || "".equals(valueeffect)) {
                vulnerabilities.get(k).getVulnerability().setEffect("-");
            } else {
                for (Message effect : effects) {
                    if (valueeffect.equals(effect.getName())) {
                        String value = effect.getValue();
                        vulnerabilities.get(k).getVulnerability().setEffect(value);
                    }
                }
            }
            String valuefqdn = vulnerabilities.get(k).getVulnerability().getAsset().getHostname();
            if (valuefqdn == null || "".equals(valuefqdn)) {
                vulnerabilities.get(k).getVulnerability().getAsset().setHostname("-");
            }
            String virtualHost = vulnerabilities.get(k).getVulnerability().getHost().getName();
            if (virtualHost == null || "".equals(virtualHost)) {
                vulnerabilities.get(k).getVulnerability().getHost().setName("-");
            }
            String category = vulnerabilities.get(k).getVulnerability().getCategory().getName();
            if (category == null || "".equals(category)) {
                vulnerabilities.get(k).getVulnerability().getCategory().setName("-");
            }
            Integer riskLevel = vulnerabilities.get(k).getVulnerability().getRiskLevel();
            vulnerabilities.get(k).getVulnerability().setRiskDescription(MessageUtil.getLocaleMessage(locale, "dashboard.level" + riskLevel));
            
            vulnerabilities.get(k).setWebApps(customerService.getWebApps(null, vulnerabilities.get(k).getScanVulnerabilityId()));
            vulnerabilities.get(k).setImages(fileService.getImageFileListByDataTypeAndTableIdAndCustomerIdWithData(customerId, vulnerabilities.get(k).getScanVulnerabilityId(), FileDataTypeEnum.VULNERABILITY.getType()));
        }

        tr.biznet.bizzy.report.entity.Report report = new tr.biznet.bizzy.report.entity.Report();
        String[] name = reportName.split("\\.");
        if (name.length > 0) {
            report.setReportName(name[0]);
        } else {
            report.setReportName(reportName);
        }
        report.setReportType(ReportTypeEnum.SCAN_REPORT.getType());
        report.setCustomerId(customerId);
        report.setCreatedBy(user.getUsername());
        report.setCreateDate(new Date());

        if ("PDF".equals(reportType)) {

            String statusGraph = ServletRequestUtils.getStringParameter(request, "statusGraphData", "");
            vulnerabilities.get(0).setStatusGraphData(statusGraph);

            String riskLevelGraph = ServletRequestUtils.getStringParameter(request, "riskLevelGraphData", "");
            vulnerabilities.get(0).setRiskLevelGraphData(riskLevelGraph);

            String assetGraph = ServletRequestUtils.getStringParameter(request, "assetLevelGraphData", "");
            vulnerabilities.get(0).setAssetLevelGraphData(assetGraph);
            report.setReportExtension("pdf");
        }
        if ("Html".equals(reportType)) {
            vulnerabilities.get(0).setStatusGraphData(statusGraphData);
            vulnerabilities.get(0).setRiskLevelGraphData(riskLevelGraphData);
            report.setReportExtension("html");
        }
        if ("Word".equals(reportType)) {
            vulnerabilities.get(0).setStatusGraphData(statusGraphData);
            vulnerabilities.get(0).setRiskLevelGraphData(riskLevelGraphData);
            report.setReportExtension("docx");
        }
        if ("CSV".equals(reportType)) {
            setTicketListWithScanVulnerability(vulnerabilities, locale);
            report.setReportExtension("csv");
        }
        stats.setTotalAssetCountWithVulnerability(distinctIps.size());
        stats.setTotalActiveVulnerabilityCount(activeVulnCount);
        stats.setTotalPassiveVulnerabilityCount(passiveVulnCount);
        stats.setScanName(pentestService.getScanNameByScanId(scan));
        stats.setScanDate(pentestService.getScanDetailsWithoutAssets(scan).getScanDate());
        if (state == true) {
            stats.setListedVulns(messageSource.getMessage("dashboard.activeScansCount", locale));
        } else if (state == false) {
            stats.setListedVulns(messageSource.getMessage("dashboard.activeScansCount", locale) + " + " + messageSource.getMessage("viewScanResults.passive", locale));
        }
        scanReport = reportService.generateReport(report, reportType, vulnerabilities, "listScans", stats);
        return "{}";
    }

    @RequestMapping(value = "getBDDKReport.json", method = RequestMethod.POST)
    @ResponseBody
    public String getBDDKReport(HttpServletRequest request, HttpServletResponse response) throws BizzyException {
        User user = HttpUtil.getUser();
        // Tüm işlemler aşağıdaki async metodda yapılıyor.
        String reportName = ServletRequestUtils.getStringParameter(request, "reportName", null);
        String scanId = ServletRequestUtils.getStringParameter(request, "scan", null);
            
        bddkReport = reportService.generateBDDKReport(user, scanId, reportName);
        return "{}";
    }

    private void setTicketListWithScanVulnerability(List<ScanVulnerability> scanVulnerabilityList, Locale locale) {
        TicketLink ticketLink = null;
        for (ScanVulnerability scanVulnerability : scanVulnerabilityList) {
            ticketLink = ticketExternalService.findTicketLinkWithTypeIdAndLinkValue(TicketLinkTypeEnum.VULNERABILITY.getType(), scanVulnerability.getScanVulnerabilityId());
            if (ticketLink != null) {
                scanVulnerability.setTicket(ticketExternalService.getTicket(ticketLink.getTicketId(), locale));
            }
        }
    }

    private ScanVulnerability setTicketWithScanVulnerability(ScanVulnerability scanVulnerability, Locale locale) {
        TicketLink ticketLink = ticketExternalService.findTicketLinkWithTypeIdAndLinkValue(TicketLinkTypeEnum.VULNERABILITY.getType(), scanVulnerability.getScanVulnerabilityId());
        if (ticketLink != null) {
            scanVulnerability.setTicket(ticketExternalService.getTicket(ticketLink.getTicketId(), locale));
        }
        return scanVulnerability;
    }

    //ticketExternalcontroller uzerinden statusları ceker
    private List<TicketStatus> getStatusList(Locale locale) {
        return ticketExternalService.getStatusList(locale);
    }

    private List<User> getCustomerUser() {
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        List<User> users = aaService.getUsersByCustomerId(customerId);
        return users;
    }

    private List<Group> getCustomerGroup() {
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        return aaService.getGroupsByCustomerId(customerId);
    }

    private List<ScanDiff> setDiffTableView(boolean onlyDiff, List<ScanDiff> scanDiff, String scan1, String scan2) {
        List<ScanDiff> tempList = new LinkedList<>();
        String firstScanName = pentestService.getScanDetailsWithoutAssets(scan1).getName();
        String secondScanName = pentestService.getScanDetailsWithoutAssets(scan2).getName();
        for (ScanDiff item : scanDiff) {
            item.setFirstScanName(firstScanName);
            item.setSecondScanName(secondScanName);
            if (item.getScanIds().contains(scan1)) {
                item.setFirstScan("true");

                List<String> ips = Arrays.asList(item.getIps().split(","));
                item.setCommonVulnFirstIps(ips);

                List<String> ports = Arrays.asList(item.getPorts().split(","));
                item.setCommonVulnFirstPorts(ports);

                List<String> protocols = Arrays.asList(item.getProtocols().split(","));
                item.setCommonVulnFirstProtocols(protocols);

                List<String> statuses = Arrays.asList(item.getStatuses().split(","));
                item.setCommonVulnFirstStatuses(statuses);
                
                List<String> riskScores = Arrays.asList(item.getRiskScores().split(","));
                item.setCommonVulnFirstRiskScores(riskScores);
                
            } else if (item.getScanIds().contains(scan2)) {
                item.setSecondScan("true");

                List<String> ips = Arrays.asList(item.getIps().split(","));
                item.setCommonVulnSecondIps(ips);

                List<String> ports = Arrays.asList(item.getPorts().split(","));
                item.setCommonVulnSecondPorts(ports);

                List<String> protocols = Arrays.asList(item.getProtocols().split(","));
                item.setCommonVulnSecondProtocols(protocols);

                List<String> statuses = Arrays.asList(item.getStatuses().split(","));
                item.setCommonVulnSecondStatuses(statuses);
                
                List<String> riskScores = Arrays.asList(item.getRiskScores().split(","));
                item.setCommonVulnSecondRiskScores(riskScores);
                
            } else {
                // zafiyet iki taramada da varsa
                if (item.getScanIds().contains("SAME")) {
                    item.setFirstScan("true");
                    item.setSecondScan("true");

                    List<String> ips = Arrays.asList(item.getIps().split(","));
                    item.setCommonVulnFirstIps(ips);
                    item.setCommonVulnSecondIps(ips);

                    List<String> ports = Arrays.asList(item.getPorts().split(","));
                    item.setCommonVulnFirstPorts(ports);
                    item.setCommonVulnSecondPorts(ports);

                    List<String> protocols = Arrays.asList(item.getProtocols().split(","));
                    item.setCommonVulnFirstProtocols(protocols);
                    item.setCommonVulnSecondProtocols(protocols);

                    List<String> statuses = Arrays.asList(item.getStatuses().split(","));
                    List<String> scan1statuses = new LinkedList<>();
                    List<String> scan2statuses = new LinkedList<>();
                    for (int i = 0; i < statuses.size(); i++) {
                        if (i % 2 == 0) {
                            scan1statuses.add(statuses.get(i));
                        } else {
                            scan2statuses.add(statuses.get(i));
                        }
                    }
                    item.setCommonVulnFirstStatuses(scan1statuses);
                    item.setCommonVulnSecondStatuses(scan2statuses);
                    
                    List<String> riskScores = Arrays.asList(item.getRiskScores().split(","));
                    item.setCommonVulnFirstRiskScores(riskScores);
                    item.setCommonVulnSecondRiskScores(riskScores);
                }
            }
            if (onlyDiff) {
                if (item.getScanIds().contains(scan1) || item.getScanIds().contains(scan2)) {
                    tempList.add(item);
                }
            }
        }
        if (onlyDiff) {
            return tempList;
        }
        return scanDiff;
    }

    private List<TicketStatus> getCustomStatusesFromConfiguration(List<TicketStatus> statuses, String customerId) {

        List<String> riskAccepted = configurationService.getByKeyAndCustomerId("riskAcceptedStatusVisibility", customerId);
        List<String> recheck = configurationService.getByKeyAndCustomerId("recheckStatusVisibility", customerId);
        List<String> onHold = configurationService.getByKeyAndCustomerId("onHoldStatusVisibility", customerId);
        List<String> inProgress = configurationService.getByKeyAndCustomerId("inProgressStatusVisibility", customerId);
        List<String> falsePositive = configurationService.getByKeyAndCustomerId("falsePositiveStatusVisibility", customerId);        
        if (riskAccepted.get(0).equals("false")) {
            statuses.removeIf(p -> p.getTicketStatusId().equals("3"));
        }
        if (recheck.get(0).equals("false")) {
            statuses.removeIf(p -> p.getTicketStatusId().equals("4"));
        }
        if (onHold.get(0).equals("false")) {
            statuses.removeIf(p -> p.getTicketStatusId().equals("5"));
        }
        if (inProgress.get(0).equals("false")) {
            statuses.removeIf(p -> p.getTicketStatusId().equals("6"));
        }
        if (falsePositive.get(0).equals("false")) {
            statuses.removeIf(p -> p.getTicketStatusId().equals("7"));
        }
        return statuses;

    }

    /**
     * Datatable yüklenirken önceki ve sonraki tarama tarihleri set edilir. Hem
     * planlı tarama, hem de planlı varlık keşfi için ortak kullanılır.
     *
     * @param scans
     * @param assetDiscoveries
     */
    private void setPreviousAndNextScanDates(List<ScheduledPentestScan> scans, List<ScheduledAssetDiscovery> assetDiscoveries) {

        if (scans != null) {
            // Planlı Tarama için
            for (ScheduledPentestScan scan : scans) {
                Date date = pentestService.getLastCompletedScanDateByScheduledScanId(scan.getScanId()); // Planlı taramaya ait son tarama tarihi
                String lastStatus = pentestService.getLastCompletedScanStatusByScheduledScanId(scan.getScanId()); // Planlı taramaya ait son tarama durumu
                DateFormat df = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
                String occurence = scan.getOccurrence().toString();
                Date now = new Date();
                if (date == null) {
                    // planlı tarama hiç üretilmemişse
                    if (now.after(scan.getScanDate())) {
                        // tarama vaktinde tetiklenmemiş (örn;sunucu kapalı), ya da tetiklenmiş fakat bir hatadan ötürü kaydedilememiş ise
                        String previous = df.format(scan.getScanDate());
                        scan.setPreviousScanDate(previous);
                        String next = calcualteNextScanDateByPeriodAndDate(occurence, scan.getScanDate(),scan.isScanWeekend());
                        scan.setNextScanDate(next);
                        scan.setSuccedded("false");
                    } else {
                        // tarama vakti gelmemiş ise
                        String next = df.format(scan.getScanDate());
                        scan.setNextScanDate(next);
                        scan.setPreviousScanDate("-");
                        scan.setSuccedded("false");
                    }
                } else {
                    if (Objects.equals(scan.getCompletedScanCount(), scan.getRecurrence())) {
                        // planlı tarama tamamlanmışsa
                        String previous = df.format(date);
                        scan.setPreviousScanDate(previous);
                        scan.setNextScanDate("-");
                        if (lastStatus.equals("COMPLETED")) {
                            scan.setSuccedded("true");
                        } else {
                            scan.setSuccedded("false");
                        }
                    } else {
                        // planlı tarama üretilmiş fakat tüm taramalar bitmemişse
                        String previous = df.format(date);
                        scan.setPreviousScanDate(previous);
                        String next = calcualteNextScanDateByPeriodAndDate(occurence, scan.getScanDate(), scan.isScanWeekend());
                        scan.setNextScanDate(next);
                        if (lastStatus.equals("COMPLETED")) {
                            scan.setSuccedded("true");
                        } else {
                            scan.setSuccedded("false");
                        }
                    }
                }
            }
        } else {
            // Planlı Keşif için
            for (ScheduledAssetDiscovery assetDiscovery : assetDiscoveries) {
                Date date = pentestService.getLastCompletedHostScanDateByScheduledScanId(assetDiscovery.getId()); // Planlı keşife ait son tarama tarihi
                String lastStatus = pentestService.getLastCompletedHostScanStatusByScheduledScanId(assetDiscovery.getId()); // Planlı keşife ait son tarama durumu
                DateFormat df = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
                String occurence = assetDiscovery.getLaunch().toString();
                Date now = new Date();
                if (date == null) {
                    // planlı keşif hiç üretilmemişse
                    if (now.after(assetDiscovery.getScanDate())) {
                        // tarama vaktinde tetiklenmemiş (örn;sunucu kapalı), ya da tetiklenmiş fakat bir hatadan ötürü kaydedilememiş ise
                        String previous = df.format(assetDiscovery.getScanDate());
                        assetDiscovery.setPreviousScanDate(previous);
                        String next = calcualteNextScanDateByPeriodAndDate(occurence, assetDiscovery.getScanDate() ,false);
                        assetDiscovery.setNextScanDate(next);
                        assetDiscovery.setSuccedded("false");
                    } else {
                        // keşif vakti gelmemiş ise
                        String next = df.format(assetDiscovery.getScanDate());
                        assetDiscovery.setNextScanDate(next);
                        assetDiscovery.setPreviousScanDate("-");
                        assetDiscovery.setSuccedded("false");
                    }
                } else {
                    if (Objects.equals(assetDiscovery.getCompletedScanCount(), assetDiscovery.getRecurrence())) {
                        // planlı keşif tamamlanmışsa
                        String previous = df.format(date);
                        assetDiscovery.setPreviousScanDate(previous);
                        assetDiscovery.setNextScanDate("-");
                        if (lastStatus.equals("COMPLETED")) {
                            assetDiscovery.setSuccedded("true");
                        } else {
                            assetDiscovery.setSuccedded("false");
                        }
                    } else {
                        // planlı keşif üretilmiş fakat tüm keşifler bitmemişse
                        String previous = df.format(date);
                        assetDiscovery.setPreviousScanDate(previous);
                        String next = calcualteNextScanDateByPeriodAndDate(occurence, assetDiscovery.getScanDate(),false);
                        assetDiscovery.setNextScanDate(next);
                        if (lastStatus.equals("COMPLETED")) {
                            assetDiscovery.setSuccedded("true");
                        } else {
                            assetDiscovery.setSuccedded("false");
                        }
                    }
                }
            }
        }
    }

    private String calcualteNextScanDateByPeriodAndDate(String occurence, Date scanDate, Boolean isScanWeekend) {
        DateFormat df = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
        String result = "-";
        Date now = new Date();
        Date scheduledDate = scanDate;
        switch (occurence) {
            case "DAILY":
                String next = df.format(scheduledDate);
                result = next;
                while (scheduledDate.before(now)) {
                    scheduledDate = DateUtils.addDays(scheduledDate, 1);
                    String nextt = df.format(scheduledDate);
                    result = nextt;
                }
                break;
            case "WEEKLY":
                String nextW = df.format(scheduledDate);
                result = nextW;
                while (scheduledDate.before(now)) {
                    scheduledDate = DateUtils.addDays(scheduledDate, 7);
                    String nextt = df.format(scheduledDate);
                    result = nextt;
                }
                break;
            case "MONTHLY":
                if(isScanWeekend == true) {
                    String nextM = df.format(scheduledDate);
                    result = nextM;
                    while (scheduledDate.before(now)) {
                        scheduledDate = DateUtils.addDays(scheduledDate, 28);
                        String nextt = df.format(scheduledDate);
                        result = nextt;
                    }
                    break;
                } else{
                    String nextM = df.format(scheduledDate);
                    result = nextM;
                    while (scheduledDate.before(now)) {
                        scheduledDate = DateUtils.addDays(scheduledDate, 30);
                        String nextt = df.format(scheduledDate);
                        result = nextt;
                    }
                    break;
                }
                
            case "QUARTERLY":
                String nextQ = df.format(scheduledDate);
                result = nextQ;
                while (scheduledDate.before(now)) {
                    scheduledDate = DateUtils.addDays(scheduledDate, 90);
                    String nextt = df.format(scheduledDate);
                    result = nextt;
                }
                break;
            case "YEARLY":
                String nextY = df.format(scheduledDate);
                result = nextY;
                while (scheduledDate.before(now)) {
                    scheduledDate = DateUtils.addDays(scheduledDate, 365);
                    String nextt = df.format(scheduledDate);
                    result = nextt;
                }
                break;
            default:
                // ON_DEMAND
                break;
        }
        return result;
    }

    private void escapeHtml(ScanVulnerability vulnerability) {

        if (vulnerability != null) {

            if (vulnerability.getVulnerability() != null) {

                if (vulnerability.getVulnerability().getDescription() != null) {
                    vulnerability.getVulnerability().setDescription(vulnerability.getVulnerability().getDescription().replaceAll(ESCAPE_REGEX_1, ESCAPE_REGEX_2));
                }
                if (vulnerability.getVulnerability().getSolution() != null) {
                    vulnerability.getVulnerability().setSolution(vulnerability.getVulnerability().getSolution().replaceAll(ESCAPE_REGEX_1, ESCAPE_REGEX_2));
                }
                if (vulnerability.getVulnerability().getConsequence() != null) {
                    vulnerability.getVulnerability().setConsequence(vulnerability.getVulnerability().getConsequence().replaceAll(ESCAPE_REGEX_1, ESCAPE_REGEX_2));
                }
                if (vulnerability.getVulnerability().getDiagnosis() != null) {
                    vulnerability.getVulnerability().setDiagnosis(vulnerability.getVulnerability().getDiagnosis().replaceAll(ESCAPE_REGEX_1, ESCAPE_REGEX_2));
                }
                if (vulnerability.getResult() != null) {
                    vulnerability.setResult(vulnerability.getResult().replaceAll(ESCAPE_REGEX_1, ESCAPE_REGEX_2));
                }
            }
        }

    }

    private void getToolVulnerabilitiesAndKbVulnerabilitiesForAggregation(List<ScanAsset> results, List<VulnerabilityKbItem> matchedIds, ImportObject importObject) {

        Map<String, String> hm = new HashMap<>();
        List<String> ids = new LinkedList<>();
        for (ScanAsset item : results) {
            // IMPORTTA BULUNAN ZAFİYETLER ALINIR
            for (ScanVulnerability vuln : item.getScanVulnerabilityList()) {
                String id = vuln.getVulnerability().getVulnNumber();
                String source = vuln.getVulnerability().getSource();
                String name = vuln.getVulnerability().getName();
                Vulnerability vulnerability = vuln.getVulnerability();
                if (vulnerability == null) {
                    // YENİ ZAFİYETSE DİREKT ALINIR
                    if (!ids.contains(id) && id != null) {
                        ids.add(id);
                        name = name.replace("\"", "\\\"");
                        hm.put(id, name);
                    }
                } else {
                    // DAHA ÖNCE EKLENMİŞ ZAFİYETSE VE KB İLE EŞLEŞMEMİŞSE
                    if (!ids.contains(id) && id != null && !matchedIds.stream().anyMatch(matched -> id.equals(matched.getVulnNumber()) && source.equals(matched.getScannerType()))) {
                        ids.add(id);
                        name = name.replace("\"", "\\\"");
                        hm.put(id, name);
                    }

                }
            }
        }
        importObject.setImportCategories(hm);
        VulnerabilityFilter kbFilter = new VulnerabilityFilter();
        String[] labelFilter = {};
        String[] problemAreaFilter = {};
        String[] rootCauseFilter = {};
        String[] category = {};
        kbFilter.setLabels(labelFilter);
        kbFilter.setProblemAreas(problemAreaFilter);
        kbFilter.setRootCauses(rootCauseFilter);
        kbFilter.setCategories(category);
        List<KBItem> categories = kBService.getKBItems(null, kbFilter);
        importObject.setKbCategories(categories);

    }

    private void filterImportResults(List<ScanAsset> results, List<ScanAsset> filteredResults, Integer level, String customerId, String[] assetGroup, ModelAndView mv, PentestScan scan, Source importSource) {

        String targets = "";
        List<AssetGroup> groups = new LinkedList<>();
        if (assetGroup.length != 0) {
            for (String item : assetGroup) {
                AssetGroup group = customerService.getAssetGroupById(item);
                groups.add(group);
            }
        } else {
            assetGroup = new String[]{""};
        }

        Integer vulnerabilityCount = 0;
        for (ScanAsset item : results) {
            List<ScanVulnerability> finalResults = new LinkedList<>();
            for (ScanVulnerability vulns : item.getScanVulnerabilityList()) {
                if (vulns.getVulnerability().getRiskLevel() != null && vulns.getVulnerability().getRiskLevel() >= level) {  //SEVİYE FİLTRESİ
                    finalResults.add(vulns);
                }
            }
            item.setScanVulnerabilityList(finalResults);
            if (!finalResults.isEmpty()) {      // FİLTRE SONUCU VARLIĞA AİT ZAFİYET VARSA
                Asset asset = customerService.getAssetByIp(item.getScannedIp(), customerId);
                if (asset == null) {            // VARLIK KAYITLI DEĞİLSE
                    if ("".equals(assetGroup[0])) {  //VARLIK FİLTRESİ YOKSA EKLE
                        Asset newAssset = new Asset();
                        newAssset.setIp(item.getScannedIp());
                        newAssset.setCustomerId(customerId);
                        newAssset.setOperatingSystem(item.getOperatingSystem());
                        newAssset.setMac(item.getMac());
                        newAssset.setHostname(item.getHostname());
                        newAssset.setCpe(item.getCpe());
                        if (importSource.equals(Source.FORTIFY) || importSource.equals(Source.NETSPARKER) || importSource.equals(Source.NETSPARKERENT) || importSource.equals(Source.WAPITI) || importSource.equals(Source.ARACHNI) || importSource.equals(Source.ACUNETIX)|| importSource.equals(Source.OWAPS)) {
                            newAssset.setAssetType(AssetType.APPLICATION.toString());
                        }
                        if (scan != null) {
                            String assetId = assetService.saveAsset(newAssset);
                            item.setAssetId(assetId);
                        }
                        filteredResults.add(item);
                        targets += item.getScannedIp() + ", ";
                        vulnerabilityCount += finalResults.size();

                    }

                } else {
                    if (scan != null) {  //Eşleştirme ekranı geçtikten sonra kaydetme ekranına gelmesi kontrolü
                        String newOs = item.getOperatingSystem();
                        if (!BizzyUtil.isEmpty(newOs)) {
                            customerService.updateAssetOperatingSystemByAssetId(asset.getAssetId(), newOs);
                        }

                        String newFqdn = item.getHostname();
                        if (!BizzyUtil.isEmpty(newFqdn)) {
                            customerService.updateHostnameByAssetId(asset.getAssetId(), newFqdn);
                        }

                        String newMac = item.getMac();
                        if (!BizzyUtil.isEmpty(newMac)) {
                            //mac güncellenir.
                            customerService.updateMacByAssetId(asset.getAssetId(), newMac);
                        }

                        String cpe = item.getCpe();
                        if (!BizzyUtil.isEmpty(cpe)) {
                            //mac güncellenir.
                            customerService.updateCpeByAssetId(asset.getAssetId(), cpe);
                        }
                    }
                    // VARLIK KAYITLIYSA
                    item.setAssetId(asset.getAssetId());
                    if (!"".equals(assetGroup[0])) {   // VARLIK FİLTRESİ VARSA
                        List<AssetGroup> list = asset.getGroups();
                        for (AssetGroup groupItem : groups) {
                            if (list.contains(groupItem)) {
                                filteredResults.add(item);   //VARLIK GRUBUNDAYSA EKLE
                                targets += item.getScannedIp() + ", ";
                                vulnerabilityCount += finalResults.size();
                            }
                        }
                    } else {              // VARLIK FİLTRESİ YOKSA EKLE
                        filteredResults.add(item);
                        targets += item.getScannedIp() + ", ";
                        vulnerabilityCount += finalResults.size();
                    }
                }

            }
        }

        if (!BizzyUtil.isEmpty(targets)) {
            targets = targets.substring(0, targets.length() - 2);
        }
        if (scan != null) {
            scan.setTargets(targets);
            scan.setIncludedIps(targets);
        }
        if (mv != null) {
            Integer assetCount = filteredResults.size();
            mv.addObject("assetCount", assetCount);
            mv.addObject("vulnerabilityCount", vulnerabilityCount);
        }
    }

    private void filterAppscanResults(List<ScanAsset> results, List<ScanAsset> filteredResults, Integer level, String customerId, String[] assetGroup, ModelAndView mv, PentestScan scan, AppScanReport data) {

        String targets = "";
        List<AssetGroup> groups = new LinkedList<>();
        if (assetGroup.length != 0) {
            for (String item : assetGroup) {
                AssetGroup group = customerService.getAssetGroupById(item);
                groups.add(group);
            }
        } else {
            assetGroup = new String[]{""};
        }

        Integer vulnerabilityCount = 0;

        for (ScanAsset item : results) {
            List<ScanVulnerability> finalResults = new LinkedList<>();
            for (ScanVulnerability vulns : item.getScanVulnerabilityList()) {
                if (vulns.getVulnerability().getRiskLevel() >= level) {  //SEVİYE FİLTRESİ
                    finalResults.add(vulns);
                }
            }
            item.setScanVulnerabilityList(finalResults);
            if (!finalResults.isEmpty()) {      // FİLTRE SONUCU VARLIĞA AİT ZAFİYET VARSA
                Asset asset = customerService.getAssetByIp(item.getScannedIp(), customerId);
                if (asset == null) {            // VARLIK KAYITLI DEĞİLSE
                    if ("".equals(assetGroup[0])) {  //VARLIK FİLTRESİ YOKSA EKLE
                        Asset newAssset = new Asset();
                        newAssset.setIp(item.getScannedIp());
                        newAssset.setCustomerId(customerId);
                        newAssset.setAssetType(AssetType.APPLICATION.toString());
                        if (scan != null) {
                            String assetId = assetService.saveAsset(newAssset);
                            item.setAssetId(assetId);
                        }
                        for (HostItem hostItem : data.getScanConfig().getHostItemList()) {
                            if (hostItem.getHost().equals(newAssset.getIp())) {
                                if (!BizzyUtil.isEmpty(hostItem.getOperatingSystem()) && !hostItem.getOperatingSystem().equals("Unknown") && !hostItem.getOperatingSystem().equals("Any")) {
                                    newAssset.setOperatingSystem(hostItem.getOperatingSystem());
                                }
                                List<AssetProperty> assetPropertyList = new LinkedList<>();
                                if (!BizzyUtil.isEmpty(hostItem.getWebServer()) && !hostItem.getWebServer().equals("Unknown") && !hostItem.getWebServer().equals("Any")) {
                                    AssetProperty assetProperty = new AssetProperty();
                                    assetProperty.setParameter(hostItem.getWebServer() + " (WebServer)");
                                    assetPropertyList.add(assetProperty);
                                }
                                if (!BizzyUtil.isEmpty(hostItem.getApplicationServer()) && !hostItem.getApplicationServer().equals("Unknown") && !hostItem.getApplicationServer().equals("Any")) {
                                    AssetProperty assetProperty = new AssetProperty();
                                    assetProperty.setParameter(hostItem.getApplicationServer() + " (AppServer)");
                                    assetPropertyList.add(assetProperty);
                                }
                                newAssset.setPassiveVulnerabilityParameters(assetPropertyList);
                                break;
                            }
                        }
                        filteredResults.add(item);
                        targets += item.getScannedIp() + ", ";
                        vulnerabilityCount += finalResults.size();
                    }

                } else {                        // VARLIK KAYITLIYSA
                    if (!"".equals(assetGroup[0])) {   // VARLIK FİLTRESİ VARSA
                        List<AssetGroup> list = asset.getGroups();
                        for (AssetGroup groupItem : groups) {
                            if (list.contains(groupItem)) {
                                filteredResults.add(item);   //VARLIK GRUBUNDAYSA EKLE
                                targets += item.getScannedIp() + ", ";
                                vulnerabilityCount += finalResults.size();
                            }
                        }
                    } else {              // VARLIK FİLTRESİ YOKSA EKLE
                        filteredResults.add(item);
                        targets += item.getScannedIp() + ", ";
                        vulnerabilityCount += finalResults.size();
                    }
                }
            }
        }

        if (!BizzyUtil.isEmpty(targets)) {
            targets = targets.substring(0, targets.length() - 2);
        }
        if (scan != null) {
            scan.setTargets(targets);
            scan.setIncludedIps(targets);
        }
        if (mv != null) {
            Integer assetCount = filteredResults.size();
            mv.addObject("assetCount", assetCount);
            mv.addObject("vulnerabilityCount", vulnerabilityCount);
        }

    }

    private void aggregationOnImport(List<ScanAsset> filteredResults, String[][] matches) {

        List<VulnerabilityKbItem> matchedIds = customerService.getMatchedVulnerabilityIds(null);

        for (ScanAsset scanAssetResult : filteredResults) {     // ZAFİTET-KB EŞLEŞTİRME FİLTRESİ
            List<ScanVulnerability> vulnerabilities = scanAssetResult.getScanVulnerabilityList();
            String[] temp = matches[matches.length - 1];
            if (temp.length == 1) {   //SADECE 1 EŞLEŞTİRME YAPILMIŞSA
                for (ScanVulnerability item : vulnerabilities) {
                    for (String[] array : matches) {  //MATCHES; FİLTREDE KULLANICININ GİRDİĞİ EŞLEŞTİRMELERDİR!
                        for (String arrayItem : array) {
                            if (arrayItem.equals(item.getVulnerability().getVulnNumber())) {
                                String id = item.getVulnerability().getVulnNumber();
                                String source = item.getVulnerability().getSource();
                                if (!matchedIds.stream().anyMatch(matched -> id.equals(matched.getVulnNumber()) && source.equals(matched.getScannerType()))) {
                                    String kbId = matches[matches.length - 1][0];
                                    customerService.matchVulnerabilities(id, kbId, source);
                                    VulnerabilityKbItem vulnKbItem = new VulnerabilityKbItem();
                                    vulnKbItem.setVulnNumber(id);
                                    vulnKbItem.setScannerType(source);
                                    matchedIds.add(vulnKbItem);
                                }
                            }
                        }
                    }
                }
            } else {          //1'DEN FAZLA EŞLEŞTİRME YAPILMIŞSA
                for (ScanVulnerability item : vulnerabilities) {
                    for (String[] array : matches) {  //MATCHES; FİLTREDE KULLANICININ GİRDİĞİ EŞLEŞTİRMELERDİR!
                        for (String arrayItem : array) {
                            if (arrayItem.equals(item.getVulnerability().getVulnNumber())) {
                                String id = item.getVulnerability().getVulnNumber();
                                String source = item.getVulnerability().getSource();
                                if (!matchedIds.stream().anyMatch(matched -> id.equals(matched.getVulnNumber()) && source.equals(matched.getScannerType()))) {
                                    String kbId = array[array.length - 1];
                                    customerService.matchVulnerabilities(id, kbId, source);
                                    VulnerabilityKbItem vulnKbItem = new VulnerabilityKbItem();
                                    vulnKbItem.setVulnNumber(id);
                                    vulnKbItem.setScannerType(source);
                                    matchedIds.add(vulnKbItem);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    @RequestMapping(value = "getVCSProjectList.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String getSVNProjectList(HttpServletRequest request, HttpServletResponse response) throws BizzySecurityException {
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        String repoUrl = ServletRequestUtils.getStringParameter(request, "repoUrl", "");
        String serverId = ServletRequestUtils.getStringParameter(request, "serverId", "");
        RepositoryRequest repoRequest = new RepositoryRequest();
        Server server = serverService.getServer(serverId, customerId);
        repoRequest.setVcsType(server.getType());
        if(server.getType().equals(ServerType.GIT.toString())) {
            repoRequest.setVcsPath(server.getDomain());
        } else {
            repoRequest.setVcsPath(repoUrl);
        }
        repoRequest.setVcsUsername(server.getUsername());
        repoRequest.setVcsPassword(server.getPassword());
        List<SelectOption> optionlist = new LinkedList<>();
        List<String> list = bizzyAgentService.getVCSProjectList(repoRequest, customerId);
        for(String  str : list) {
            SelectOption option = new SelectOption();
            option.setId(str);
            option.setText(str);
            optionlist.add(option);
        }
        if (list != null && list.size() > 0) {
            return gson.toJson(optionlist);
        } else {
            return "";
        }
    }

    private File multipartToFile(MultipartFile multipart, String fileName) throws IllegalStateException, IOException {
        File convFile = new File(Configuration.getHomeFolder().getPath() + "/tmp/" + String.valueOf(new Date().getTime()) + fileName);
        multipart.transferTo(convFile);
        return convFile;
    }

    @RequestMapping(value = "calendar.htm", method = {RequestMethod.GET})
    public ModelAndView calendar(HttpServletRequest request, HttpServletResponse response) throws BizzyException, BizzySecurityException {
        ModelAndView mv = new ModelAndView();
        User user = HttpUtil.getUser();
        String customerId = BizzyUtil.getCustomerIdByUser(user);
        List<CalendarProject> projects = pentestService.getAllCalendarProjectObjects(null);
        List<User> users = aaService.getPentestUsers();
        List<User> managers = aaService.getCompanyUsersByRole(customerId,"ROLE_COMPANY_MANAGER");
        users.addAll(managers);
        List<Customer> customers = customerService.getCustomers();
        Locale locale = RequestContextUtils.getLocale(request);
        String lang = locale.getLanguage();
        mv.addObject("selectedLanguage", lang);
        mv.addObject("projects", projects);
        mv.addObject("users", users);
        mv.addObject("customers", customers);
        return mv;
    }

    @RequestMapping(value = "saveCalendarEntry.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public void saveCalendarEntry(HttpServletRequest request, HttpServletResponse response) throws ServletRequestBindingException, ParseException {
        User user = HttpUtil.getUser();
        Schedule schedule = new Schedule();
        schedule.setId(ServletRequestUtils.getStringParameter(request, "id", ""));
        schedule.setTitle(ServletRequestUtils.getStringParameter(request, "title", ""));
        SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm", Locale.US); 
        String start = formatter.format(formatter.parse(ServletRequestUtils.getStringParameter(request, "start", "").split(" GMT")[0]));
        String end = formatter.format(formatter.parse(ServletRequestUtils.getStringParameter(request, "end", "").split(" GMT")[0]));
        schedule.setStart(start);
        schedule.setEnd(end);
        schedule.setAttendees(ServletRequestUtils.getStringParameters(request, "attendees[]"));
        schedule.setCategory(ServletRequestUtils.getStringParameter(request, "category", ""));
        schedule.setBgColor(ServletRequestUtils.getStringParameter(request, "bgColor", ""));
        schedule.setLocation(ServletRequestUtils.getStringParameter(request, "location", ""));
        pentestService.saveCalendarEntry(schedule, user.getUserId());
    }
    
    @RequestMapping(value = "checkUsersAvailability.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String checkUsersAvailability(HttpServletRequest request, HttpServletResponse response) throws ServletRequestBindingException, ParseException {
        User user = HttpUtil.getUser();
        String users [] = ServletRequestUtils.getStringParameters(request, "attendees[]");
        SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm", Locale.US); 
        String start = formatter.format(formatter.parse(ServletRequestUtils.getStringParameter(request, "start", "").split(" GMT")[0]));
        String end = formatter.format(formatter.parse(ServletRequestUtils.getStringParameter(request, "end", "").split(" GMT")[0]));
        Schedule schedule = new Schedule();
        schedule.setStart(start);
        schedule.setEnd(end);
        schedule.setAttendees(users);
        List<String> data = pentestService.checkUsersAvailability(schedule);
        return gson.toJson(data);
    }
    
    @RequestMapping(value = "updateCalendarEntry.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public void updateCalendarEntry(HttpServletRequest request, HttpServletResponse response) throws ServletRequestBindingException, ParseException {
        User user = HttpUtil.getUser();
        Schedule schedule = new Schedule();
        schedule.setId(ServletRequestUtils.getStringParameter(request, "id", ""));
        schedule.setTitle(ServletRequestUtils.getStringParameter(request, "title", ""));
        DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm", Locale.US); 
        String start = formatter.format(formatter.parse(ServletRequestUtils.getStringParameter(request, "start", "").split(" GMT")[0]));
        String end = formatter.format(formatter.parse(ServletRequestUtils.getStringParameter(request, "end", "").split(" GMT")[0]));
        schedule.setStart(start);
        schedule.setEnd(end);
        schedule.setAttendees(ServletRequestUtils.getStringParameters(request, "attendees[]"));
        schedule.setCategory(ServletRequestUtils.getStringParameter(request, "category", ""));
        schedule.setLocation(ServletRequestUtils.getStringParameter(request, "location", ""));
        pentestService.updateCalendarEntry(schedule, user.getUserId());
    }

    @RequestMapping(value = "deleteCalendarEntry.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public void deleteCalendarEntry(HttpServletRequest request, HttpServletResponse response) {
        User user = HttpUtil.getUser();
        String id = ServletRequestUtils.getStringParameter(request, "id", "");
        pentestService.deleteCalendarEntry(id, user.getUserId());
    }

    @RequestMapping(value = "getAllEntries.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String getAllEntries(HttpServletRequest request, HttpServletResponse response) {
        User user = HttpUtil.getUser();
        boolean getAll = ServletRequestUtils.getBooleanParameter(request, "all", true);
        String id = ServletRequestUtils.getStringParameter(request, "id", "");
        List<Schedule> schedules;
        //Belirli bir kişinin programına sadece manager bakabiliyor. Diğer rollere sadece kendi programlarını getiriyoruz.
        if(!(user.getRole().getId().equals("4")||user.getRole().getId().equals("2"))) {
            getAll = false;
        }
        if (!id.equals("") && (user.getRole().getId().equals("4")|| user.getRole().getId().equals("2"))) {
            getAll = false; 
            schedules = pentestService.getAllCalendarEntries(id, getAll);
        } else if (id.equals("") && user.getRole().getId().equals("4")) {
            getAll = true;
            schedules = pentestService.getAllCalendarEntries(user.getUserId(), getAll);
        } else {
            String userTag = user.getName()+" "+user.getSurname()+"/"+user.getUserId();
            schedules = pentestService.getAllCalendarEntries(userTag, getAll);
        }
        return gson.toJson(schedules);
    }
    
    @RequestMapping(value = "loadEfforts.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String loadEfforts(HttpServletRequest request, HttpServletResponse response) {
        User user = HttpUtil.getUser();
        String project = ServletRequestUtils.getStringParameter(request, "project", "");
        String userId = ServletRequestUtils.getStringParameter(request, "user", "");
        EffortFilter filter = new EffortFilter();
        if(project.equals("-1") || project.equals("")) {
             filter.setProject(null);
        } else {
             filter.setProject(project);
        }
      
        DataTablesRequest dataTablesRequest = DataTablesUtil.getRequest(request);
        List<Effort> efforts;
        int count;
        if((userId.equals("-1") ||userId.equals("")) && (user.getRole().getId().equals("4")|| user.getRole().getId().equals("2"))) {
            filter.setUser(null);
        } else if(!(userId.equals("-1") ||userId.equals("")) && (user.getRole().getId().equals("4")|| user.getRole().getId().equals("2"))) {
            filter.setUser(userId);
        } else{
            filter.setUser(user.getUserId());
        }
        efforts = pentestService.getAllEfforts(dataTablesRequest, filter);
        count = pentestService.getAllEffortsCount(filter);
        efforts.forEach((effort) -> {
            effort.setWorkLog(pentestService.transformDaysToLogString(Float.parseFloat(effort.getWorkLog())));
        });
        return DataTablesUtil.getResponse(dataTablesRequest.getDraw(), count, count, efforts);
    }
    
    @RequestMapping(value = "loadProjects.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String loadProjects(HttpServletRequest request, HttpServletResponse response) {
        User user = HttpUtil.getUser();
        if(user.getRole().getId().equals("4")|| user.getRole().getId().equals("2")) {
            DataTablesRequest dataTablesRequest = DataTablesUtil.getRequest(request);
            List<CalendarProject> projects;
            int count = pentestService.getAllCalendarProjectObjectsCount();
            projects = pentestService.getAllCalendarProjectObjects(dataTablesRequest);
            return DataTablesUtil.getResponse(dataTablesRequest.getDraw(), count, count, projects);
        } 
        else return "";  
    }
    
    
    @RequestMapping(value = "saveProject.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public void addProject(HttpServletRequest request, HttpServletResponse response) {
        User user = HttpUtil.getUser();
        if(user.getRole().getId().equals("4")|| user.getRole().getId().equals("2")) {
        	CalendarProject project = new CalendarProject();
            project.setBgColor(ServletRequestUtils.getStringParameter(request, "color", "").split("#")[1]);
            project.setProject(ServletRequestUtils.getStringParameter(request, "project", ""));
            project.setDuration(ServletRequestUtils.getIntParameter(request, "duration", 0));
            pentestService.saveCalendarProject(project);
        } else {
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            return;
        }
    }
    
    @RequestMapping(value = "deleteProject.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public void deleteProject(HttpServletRequest request, HttpServletResponse response) {
        User user = HttpUtil.getUser();
        if(user.getRole().getId().equals("4")|| user.getRole().getId().equals("2")) {
            String id = ServletRequestUtils.getStringParameter(request, "id", "");
            pentestService.deleteCalendarProject(id);
        } else {
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            return;
        }
    }
    
    @RequestMapping(value = "updateProject.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public void updateProject(HttpServletRequest request, HttpServletResponse response) {
        User user = HttpUtil.getUser();
        if(user.getRole().getId().equals("4")|| user.getRole().getId().equals("2")) {
        	CalendarProject project = new CalendarProject();
            String id = ServletRequestUtils.getStringParameter(request, "id", "");
            project.setProject(ServletRequestUtils.getStringParameter(request, "project", ""));
            project.setDuration(ServletRequestUtils.getIntParameter(request, "duration", 0));
            pentestService.updateCalendarProject(id, project);
        } else {
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            return;
        }
    }
    
    @RequestMapping(value = "addEffort.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public void addEffort(HttpServletRequest request, HttpServletResponse response) throws ParseException {
        User user = HttpUtil.getUser();
        Effort effort = new Effort();
        effort.setId(BizzyUtil.generateGUID());
        effort.setProject(ServletRequestUtils.getStringParameter(request, "project", ""));
        effort.setUserComment(ServletRequestUtils.getStringParameter(request, "comment", ""));
        //You can specify a time unit after a time value 'X', such as Xw, Xd, Xh or Xm, to represent weeks (w), days (d), hours (h) and minutes (m), respectively.
        String logStr = ServletRequestUtils.getStringParameter(request, "log", "");
        if(!RegexUtil.isWorklogValid(logStr)) {
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            return;
        }
        float minutes = pentestService.transformLogStringToDays(logStr);
        effort.setWorkLogNum(minutes);
        //Tue Jun 09 2020 12:00:00 GMT+0300 (GMT+03:00)
        
        DateFormat formatter = new SimpleDateFormat("EEE MMM dd yyyy HH:mm:ss", Locale.US); 
        String[] dates = ServletRequestUtils.getStringParameters(request, "dates[]");
        Date start = (Date) formatter.parse(dates[0].split(" GMT")[0]);
        effort.setStartDate(start);
        int count = 0;
        StringBuilder effortDates = new StringBuilder();
        for(String date: dates) {
            if(count != 0) {
                effortDates.append(", ");
            }
            effortDates.append(date);
            count++;
        }
        effort.setDates(effortDates.toString());
        effort.setUserId(user.getUserId());
        pentestService.saveCalendarEffort(effort);
    }
    
    @RequestMapping(value = "deleteEffort.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public void deleteEffort(HttpServletRequest request, HttpServletResponse response) {
        String id = ServletRequestUtils.getStringParameter(request, "id", "");
        pentestService.deleteCalendarEffort(id);
    }
    
    @RequestMapping(value = "updateEffort.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public void updateEffort(HttpServletRequest request, HttpServletResponse response) throws ParseException {
        User user = HttpUtil.getUser();
        Effort effort = new Effort();
        effort.setId(ServletRequestUtils.getStringParameter(request, "id", ""));
        effort.setProject(ServletRequestUtils.getStringParameter(request, "project", ""));
        effort.setUserComment(ServletRequestUtils.getStringParameter(request, "comment", ""));
        //You can specify a time unit after a time value 'X', such as Xw, Xd, Xh or Xm, to represent weeks (w), days (d), hours (h) and minutes (m), respectively.
        String logStr = ServletRequestUtils.getStringParameter(request, "log", "");
        if(!RegexUtil.isWorklogValid(logStr)) {
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            return;
        }
        float days = pentestService.transformLogStringToDays(logStr);
        effort.setWorkLogNum(days);
        DateFormat formatter = new SimpleDateFormat("EEE MMM dd yyyy HH:mm:ss", Locale.US); 
        String[] dates = ServletRequestUtils.getStringParameters(request, "dates[]");
        Date start = (Date) formatter.parse(dates[0].split(" GMT")[0]);
        effort.setStartDate(start);
        int count = 0;
        StringBuilder effortDates = new StringBuilder();
        for(String date: dates) {
            if(count != 0) {
                effortDates.append(", ");
            }
            effortDates.append(date);
            count++;
        }
        effort.setDates(effortDates.toString());
        effort.setUserId(user.getUserId());
        pentestService.updateCalendarEffort(effort);
    }
    
    @RequestMapping(value = "spentTimeOfProjectsGraph.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String spentTimeOfProjectsGraph(HttpServletRequest request, HttpServletResponse response) {
    	User user = HttpUtil.getUser();
    	if(user.getRole().getId().equals("4")|| user.getRole().getId().equals("2")) {
    		DataTablesRequest dataTablesRequest = DataTablesUtil.getRequest(request);
            String userId = ServletRequestUtils.getStringParameter(request, "userId", "");  
            String date = ServletRequestUtils.getStringParameter(request, "date", ""); 
            EffortFilter filter = new EffortFilter();
            filter.setUser(userId);
            if(!date.equals("")) {
            	DateFormat formatter = new SimpleDateFormat("dd.MM.yyyy", Locale.US); 
            	try {
					filter.setStartDate(formatter.parse(date.split("-")[0]));
					filter.setEndDate(formatter.parse(date.split("-")[1]));
				} catch (ParseException e) {
					response.setStatus(HttpServletResponse.SC_FORBIDDEN);
			        return "";
				}
            }
            List<CalendarProjectTimeGraph> graph = pentestService.getSpentTimeOfProjectsGraph(dataTablesRequest, filter);
            int count = pentestService.spentTimeOfProjectsGraphCount(filter);
            return DataTablesUtil.getResponse(dataTablesRequest.getDraw(), count, count, graph);
        } else {
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            return "";
        }
    	
    }
    
    @RequestMapping(value = "usersSpentTimeGraphByProject.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String usersSpentTimeGraphByProject(HttpServletRequest request, HttpServletResponse response) {
    	User user = HttpUtil.getUser();
    	if(user.getRole().getId().equals("4")|| user.getRole().getId().equals("2")) {
    		DataTablesRequest dataTablesRequest = DataTablesUtil.getRequest(request);
    		String project = ServletRequestUtils.getStringParameter(request, "project", "");
    		String date = ServletRequestUtils.getStringParameter(request, "date", ""); 
    		EffortFilter filter = new EffortFilter();
            filter.setProject(project);
            if(!date.equals("")) {
            	DateFormat formatter = new SimpleDateFormat("dd.MM.yyyy", Locale.US); 
            	try {
					filter.setStartDate(formatter.parse(date.split("-")[0]));
					filter.setEndDate(formatter.parse(date.split("-")[1]));
				} catch (ParseException e) {
					response.setStatus(HttpServletResponse.SC_FORBIDDEN);
			        return "";
				}
            }
            List<CalendarProjectTimeGraph> graph = pentestService.getUsersSpentTimeGraphByProject(dataTablesRequest, filter);
            for(CalendarProjectTimeGraph element : graph) {
            	User elementUser = aaService.getUserById(element.getName());
            	element.setName(elementUser.getName()+" "+elementUser.getSurname());
            }
            int count = pentestService.getUsersSpentTimeGraphByProjectCount(filter);
            return DataTablesUtil.getResponse(dataTablesRequest.getDraw(), count, count, graph);
        } else {
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            return "";
        }
    }
    
    @RequestMapping(value = "spentTimeCumulativeGraph.json", method = RequestMethod.POST, produces = HttpUtil.MIME_TYPE_JSON)
    @ResponseBody
    public String spentTimeCumulativeGraph(HttpServletRequest request, HttpServletResponse response) {
    	User user = HttpUtil.getUser();
    	if(user.getRole().getId().equals("4")|| user.getRole().getId().equals("2")) {
    		DataTablesRequest dataTablesRequest = DataTablesUtil.getRequest(request);
    		String userId = ServletRequestUtils.getStringParameter(request, "userId", "");  
            String project = ServletRequestUtils.getStringParameter(request, "project", "");
            String date = ServletRequestUtils.getStringParameter(request, "date", ""); 
            if(project.equals("-1") || project.equals("")) {
                project = null;
            }
            if(userId.equals("-1") || userId.equals("")) {
                userId = null;
            }      
            EffortFilter filter = new EffortFilter();
            filter.setUser(userId);
            if(!date.equals("")) {
            	DateFormat formatter = new SimpleDateFormat("dd.MM.yyyy", Locale.US); 
            	try {
					filter.setStartDate(formatter.parse(date.split("-")[0]));
					filter.setEndDate(formatter.parse(date.split("-")[1]));
				} catch (ParseException e) {
					response.setStatus(HttpServletResponse.SC_FORBIDDEN);
			        return "";
				}
            }
            filter.setProject(project);
            filter.setUser(userId);
            List<CalendarProjectTimeGraph> graph = pentestService.getSpentTimeCumulativeGraph(dataTablesRequest, filter);
            int count = pentestService.spentTimeCumulativeGraphCount(filter);
            return DataTablesUtil.getResponse(dataTablesRequest.getDraw(), count, count, graph);
    	} else {
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            return "";
        }
        
    }
    
    private void setPassiveVulnerabilitySpecificDetails(ScanVulnerability vuln, String customerId) {
        
        // scanName alanı kullanılmadığı için pasif zafiyetin aktifinin id'si bu alana set edilecek.
        try {
            if (!vuln.getVulnerability().getSource().equals("FORTIFY") && !vuln.getVulnerability().getSource().equals("CHECKMARX")) {
                String ip = vuln.getVulnerability().getAsset().getIp();
                String pluginId = vuln.getVulnerability().getVulnNumber();
                Integer port = vuln.getVulnerability().getPort().getPortNumber();
                String protocol = vuln.getVulnerability().getPort().getProtocol();
                String activeSvIdOfPassiveVulnerability = customerService.getActiveSvIdOfPassiveVulnerability(customerId, ip, pluginId, port, protocol);
                vuln.setScanName(activeSvIdOfPassiveVulnerability);
                List<PentestScan> scans = pentestService.getPassiveVulnerabilityHistory(customerId, ip, pluginId, port, protocol);
                vuln.setPassiveVulnerabilityHistory(scans);
            } else {
                String ip = vuln.getVulnerability().getIp();
                String pluginId = vuln.getVulnerability().getVulnNumber();
                String activeSvIdOfPassiveVulnerability = customerService.getActiveSvIdOfPassiveVulnerability(customerId, ip, pluginId, null, null);
                vuln.setScanName(activeSvIdOfPassiveVulnerability);
                List<PentestScan> scans = pentestService.getPassiveVulnerabilityHistory(customerId, ip, pluginId, null, null);
                vuln.setPassiveVulnerabilityHistory(scans);
            }

        } catch (Exception ex) {
            logger.log(LogLevel.ERROR, "Pasif zafiyetin aktif zafiyet id'sini almada hata! ", ex);
        }
        
    }
  
		
}
